<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IP相关内容</title>
    <url>/2023/04/17/IP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>这里是摘要</p>
<span id="more"></span>
<h2 id="ip基础知识">IP基础知识</h2>
<h3 id="原始ip地址表示">原始IP地址表示</h3>
<p>格式：<font color='cornflowerblue'><strong>32位</strong></font>正整数，<font color='cornflowerblue'><strong>点分十进制</strong></font>方便记忆</p>
<p>分类：ABCDE，D类是多播地址（用于将包发给特定组内的所有主机），E类留用。ABCDE类前两位分别为0，10，110，1110，1111</p>
<p>特殊IP地址：<font color='A2CD5A'><strong>主机号全为1</strong></font>——指定某个网络下所有主机，用于广播；<font color='A2CD5A'><strong>主机号全为0</strong></font>——指定某个网络</p>
<p>多播地址：</p>
<ul>
<li>224.0.0.0 ~ 224.0.0.255
为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet
上。</li>
<li>239.0.0.0 ~ 239.255.255.255
为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li>
</ul>
<p>IP地址分类的优缺点：</p>
<ul>
<li><font color='cornflowerblue'><strong>通过最多前4位就能确定地址类型</strong></font>，然后进而能够快速划分网络号和主机号，简单明了</li>
<li><font color='red'><strong>同一网络下没有地址层次</strong></font>，灵活性不足</li>
<li>与现实网络的匹配度不好，C类地址一个网络下只有200+个，而B类地址一个网络下6W+个</li>
</ul>
<h3 id="子网划分">子网划分</h3>
<p>子网是指在网络号的基础上，进一步将网络内主机进行划分，所以需要从主机号中借用若干位作为子网号。<strong>要使用子网，必须配置子网掩码</strong>。子网掩码中对应网络号（默认网络号+子网网络号）的位全为1。</p>
<p>基本的子网划分中，比如借走两位主机号，只能划分4-2=2个子网，这是因为全0和全1不使用。</p>
<p>外界是感知不到子网的存在的</p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" /></p>
<h3
id="无分类编址cidrclassless-inter-domain-routing">无分类编址CIDR（Classless
Inter-Domain Routing）</h3>
<p>不再对地址类型进行区分，也没有划分子网的概念</p>
<p>32位IP总共有两部分组成：网络前缀+主机号</p>
<p>表示形式：<font color='cornflowerblue'><strong>a.b.c.d/x</strong></font>，其中x说明前x位是网络前缀</p>
<p>CIDR中不会将主机号全0和全1的地址排除不使用</p>
<p>CIDR表示法给出任何一个IP地址，就相当于给出了一个CIDR地址块，这是由连续的IP地址组成的，所以CIDR表示法构成了超网，实现了路由聚合，即从一个IP地址就可以得知一个CIDR地址块。（通过x的大小确定32位中表示网络的前缀，将主机号置0或置1就可得到最小或最大地址）</p>
<h3 id="公有ip和私有ip">公有IP和私有IP</h3>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/22.jpg" /></p>
<p>A B C类IP地址中有公有IP和私有IP之分</p>
<p>公有IP由专门的IP地址分配机构统一分配，在整个互联网范围内保持唯一</p>
<p>私有IP由组织内部管理，可以重复</p>
<h3 id="ip转发">IP转发</h3>
<p>转发过程中，主机与路由器的区别在于主机对不是自身生成的数据报会丢弃；而路由器会进行转发</p>
<p>简单情况下，对一个主机，如果与目的地点到点连接或共享网络，那么IP数据报直接发送到目的地，不需要使用路由器。否则，主机将数据报发送到默认路由器，由该路由器进行交付。（直接交付）</p>
<p>转发过程中需要用到的关键信息存储在<font color='cornflowerblue'><strong>路由表</strong></font>中，表中一个条目<span
class="math inline">\(e_j\)</span>包含以下字段：</p>
<ul>
<li>目的地址<span class="math inline">\(d_j\)</span></li>
<li>掩码<span class="math inline">\(m_j\)</span></li>
<li>下一跳<span class="math inline">\(n_j\)</span></li>
<li>接口</li>
</ul>
<p>当接收到数据报时，首先提取目的IP地址<span
class="math inline">\(D\)</span>,查找转发表，如果有直接匹配的目的地址，转发给下一跳的地址</p>
<p>如果没有直接匹配的表项，计算网络前缀<span
class="math inline">\(d=(D\and m_{j})\)</span>，</p>
<p>如果是非本地网络，<span class="math inline">\(d\)</span>与<span
class="math inline">\(d_j\)</span>比较网络前缀，如果找到前缀匹配（最长前缀匹配）的，则转发到下一跳；如果没找到匹配的，转发给默认路由；如果没有默认路由，报错</p>
<p><font color='A2CD5A'><strong>（最长前缀匹配的含义是首先网络地址要先对的上，然后再找最长的，不是说直接看网络地址里有多少位相同，比如下图的例子）</strong></font></p>
<p><img src="image-20230417230944181.png" /></p>
<p><img src="image-20230417231004872.png" /></p>
<p><img src="image-20230417231027927.png" /></p>
<p><img src="image-20230417231050856.png" /></p>
<p><font color='red'><strong>（当使用环回地址时，数据报是不会流向网络的，在机器内部进行处理转发）</strong></font></p>
<h3 id="ip分片与重组">IP分片与重组</h3>
<p>当IP数据报大小大于MTU时，就会进行分片</p>
<p>重组的工作由目标主机完成，路由器不负责重组</p>
<p>之前在TCP里提过，为什么存在MTU的情况下要在TCP层设置MSS再分片，因为如果只在IP层分片，那么一个分片丢失之后，IP层没有超时重传，而是在TCP层超时重传，所以重传的是整个数据包。如果TCP有分片，那么只需要重传丢失的分片即可。</p>
<h3 id="ipv6">IPv6</h3>
<p>128位地址，16位一组，由冒号隔开</p>
<p>连续的0可以将其省略，用两个冒号隔开，但是，一个 IP
地址中只允许出现一次两个连续的冒号。</p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/28.jpg" /></p>
<p>IPv6亮点：</p>
<ul>
<li>可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址</li>
<li>包头包首部长度采用固定的值 <code>40</code>
字节，去掉了包头校验和，简化了首部结构（没有选项字段），减轻了路由器负荷（不允许路由器分片与重组），大大<strong>提高了传输的性能</strong></li>
<li>有应对伪造 IP
地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong></li>
</ul>
<h2 id="ip协议相关技术">IP协议相关技术</h2>
<h3 id="域名解析dns">域名解析DNS</h3>
<p><font color='cornflowerblue'><strong>进行域名和IP地址的转换</strong></font></p>
<p>工作流程：</p>
<ul>
<li>浏览器先检查自身缓存，是否有与域名对应的IP</li>
<li>如果没有会检查操作系统域名解析文件(hosts)</li>
<li>还是没有，会向本地DNS服务器发起查询请求</li>
<li>本地DNS服务器检查自己的缓存，有就返回，没有会去向根域名服务器请求</li>
<li>根域名服务器不会直接返回解析结果，而是将一个顶级域名服务器地址返回给本地DNS服务器</li>
<li>本地DNS再去向顶级域名服务器查询，顶级域名服务器会返回区域权威DNS服务器地址</li>
<li>本地DNS服务器再去向权威DNS服务器查询，后者将查询结果返回</li>
<li>本地DNS再将该IP返回给客户端</li>
</ul>
<h3 id="arp与rarp">ARP与RARP</h3>
<p><font color='cornflowerblue'><strong>ARP:
已知IP地址，获得对应的MAC地址</strong></font></p>
<ul>
<li>广播发送ARP请求，其中包含了源IP地址，源MAC地址，目的IP地址</li>
<li>所有设备收到ARP请求后，会提取目的IP与自己的IP比较，如果一致，就会在ARP响应中写入自己的MAC地址，然后送回</li>
</ul>
<p>操作系统获取到MAC之后一般会缓存一段时间</p>
<p><font color='cornflowerblue'><strong>RARP:
已知MAC地址，获得对应的IP地址</strong></font></p>
<p>通常这需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的
MAC 地址及其 IP 地址。</p>
<p>设备接入网络后：</p>
<ul>
<li>发送请求，请求中包含自己的MAC</li>
<li>RARP收到请求后会将对应IP返回给设备</li>
</ul>
<h3 id="动态获取ip地址dhcp">动态获取IP地址DHCP</h3>
<p>DHCP全程使用UDP广播通信</p>
<p>DHCP客户端监听68端口，而服务端监听的是67端口</p>
<p>工作流程：</p>
<ul>
<li>客户端首先发起DHCP发现报文，该报文是IP数据报，但是现在没有IP地址，也没有DHCP服务器地址，所以使用<font color='cornflowerblue'><strong>UDP广播</strong></font>，<font color='A2CD5A'><strong>源IP地址设置为0.0.0.0，广播目的地址为255.255.255.255</strong></font></li>
<li>DHCP收到DHCP DISCOVER，用DHCP提供报文进行响应，该报文仍然使用 IP
广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP
地址、子网掩码、默认网关、DNS
服务器以及<font color='cornflowerblue'><strong>IP
地址租用期</strong></font>。</li>
<li>客户端收到一个或多个服务器的 DHCP
提供报文后，从中选择一个服务器，并向选中的服务器发送<font color='cornflowerblue'>
<strong>DHCP 请求报文（DHCP
REQUEST）</strong></font>进行响应，回显配置的参数。</li>
<li>最后，服务端用 <font color='cornflowerblue'><strong>DHCP ACK
</strong></font>报文对 DHCP 请求报文进行响应，应答所要求的参数。</li>
</ul>
<p>IP租用期控制的是DHCP服务器分配的IP地址的使用时限，快到期时会向服务器发送请求进行租期延长</p>
<p>为了解决路由器不转发广播包的问题，设置了DHCP中继代理，对不同网段的 IP
地址分配也可以由一个 DHCP 服务器统一进行管理。</p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/37.jpg" /></p>
<h3 id="nat网络地址转换">NAT网络地址转换</h3>
<p>缓解IPv4地址耗尽的问题</p>
<p>网络地址端口转换<code>NAPT</code>（Network Address Port
Translation）则是把内部地址映射到外部网络的一个IP地址的<font color='red'><strong>不同端口</strong></font>上。</p>
<p>映射时自动生成路由器的转换表，问题：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT
转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>
<p>NAT穿透：设备主动获得公有IP，为自己建立端口映射条目，然后使用这个条目对外通讯</p>
<h3 id="互联网控制报文协议icmp">互联网控制报文协议ICMP</h3>
<p>功能：差错报文——回应网络错误，查询报文——查询网络信息</p>
<p>ICMP虽然是网络层协议，但实际上是使用IP协议进行发送</p>
<p>在IP通信中如果某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由
ICMP 负责通知。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP相关知识点</title>
    <url>/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>整理一下看过的TCP相关的内容，主要是顺着小林coding里的要点看下来的，有些不太明白的地方去《TCP/IP详解
卷1》翻了翻</p>
<p>主要内容：TCP头部关键信息、TCP和UDP的区别、三次握手四次挥手、TCP重传、流量控制和拥塞控制</p>
<span id="more"></span>
<h2 id="tcp头中的关键内容">TCP头中的关键内容</h2>
<p>32位序列号：在建立连接时生成随机数作为初始值（与时间有关，每4微妙值加1，同时也与一个根据四元组计算的哈希值有关），每发送N字节数据，该值就加N，通过此序列号<font color='red'><strong>可以保证接受到的数据包有序</strong></font></p>
<p>32位确认应答号：下一次希望收到的数据序列号，该应答号之前的数据已经被正常接收，可以<font color='red'><strong>用于处理丢包的问题</strong></font></p>
<p>控制位：<font color='red'><strong>ACK/RST/SYN/FIN</strong></font>/PSH/URG</p>
<p>源端口号、目的端口号</p>
<p>4位首部长度：存储的是首部长度有多少个4字节</p>
<p>校验和：校验首部+数据，如果接收方发现校验和有问题，会丢弃收到的段，发送方会超时重发</p>
<h2 id="tcp的特点以及与udp的区别">TCP的特点以及与UDP的区别</h2>
<p><font color='red'><strong>面向连接、可靠、字节流</strong></font></p>
<p>说明：必须一对一建立连接、保证报文一定能被接收方收到、不在字节流中插入记录标识符，每次发送的大小和接收的大小不一定相同，发送接收次数也不一定相同</p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">TCP</th>
<th style="text-align: center;">UDP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">先建立连接</td>
<td style="text-align: center;">即刻传输数据</td>
</tr>
<tr class="even">
<td style="text-align: center;">一对一</td>
<td style="text-align: center;">一对一、一对多、多对多</td>
</tr>
<tr class="odd">
<td style="text-align: center;">无差错、不丢失、不重复、有序</td>
<td style="text-align: center;">尽最大努力交付（QUIC可靠）</td>
</tr>
<tr class="even">
<td style="text-align: center;">有拥塞控制和流量控制</td>
<td style="text-align: center;">没有</td>
</tr>
<tr class="odd">
<td style="text-align: center;">首部20字节（不用选项的话）</td>
<td style="text-align: center;">固定8字节</td>
</tr>
<tr class="even">
<td style="text-align: center;">流式传输，没有边界</td>
<td style="text-align: center;">以数据包为单位发送</td>
</tr>
<tr class="odd">
<td style="text-align: center;">可以在传输层分片（大于MSS）</td>
<td
style="text-align: center;">不会在数据层分片，如果大于MTU会给IP层分片</td>
</tr>
<tr class="even">
<td style="text-align: center;">常用于 FTP文件传输； HTTP / HTTPS</td>
<td style="text-align: center;">常用于 DNS；
视频、音频等多媒体通信；广播</td>
</tr>
</tbody>
</table>
<h2 id="tcp连接">TCP连接</h2>
<p>建立TCP连接是为了客户端和服务端在以下方面达成共识：socket、序列号、窗口大小</p>
<p>一个TCP连接可以用<font color='cornflowerblue'><strong>（源地址、源端口、目的地址、目的端口）</strong></font>这样一个四元组表示</p>
<blockquote>
<p>如果协议不确定，（源地址、源端口、目的地址、目的端口、通信协议）这样一个五元组可以唯一确定一个会话（<font color='orange'><strong>隐含TCP和UDP是可以使用同样的端口的</strong></font>）</p>
<p>还有个七元组：（源地址、源端口、目的地址、目的端口、通信协议、服务类型、接口索引）</p>
</blockquote>
<h3 id="三次握手">三次握手</h3>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" /></p>
<blockquote>
<p>图片来源于<a
href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-和-udp-可以使用同一个端口吗">小林coding</a></p>
</blockquote>
<p><font color='red'><strong>为什么是三次握手？</strong></font></p>
<ol type="1">
<li>双方都经过了发送-接收的过程，同时ACK位保证了对方已知自己能够成功接收，同时同步双方的初始序列号。（两次：发送方不知道接收方能否成功接收，也就无法同步序列号；四次：冗余）</li>
<li><font color='cornflowerblue'><strong>防止无效的历史连接造成资源浪费</strong></font>（考虑client发送了一个SYN报文之后宕机了，然后在server没收到之前重启，又重新发了一个新的SYN报文，如果两次就能建立连接，此时假设server收到了旧SYN报文，发送一个SYN+ACK连接就已经建立了，然后客户端还得发RST去断开旧连接。）；<font color='cornflowerblue'><strong>防止冗余连接造成资源浪费</strong></font>（考虑client第一次发的SYN报文堵塞了，然后超时重发，如果两次握手，server收到任何一个之后发送SYN+ACK就建立连接了，假设server不知道自己的SYN+ACK是否被收到，再收到另一个SYN就会重复的建立连接）</li>
</ol>
<p><font color='red'><strong>ISN为什么要随时间变化？</strong></font></p>
<ol type="1">
<li><font color='cornflowerblue'><strong>防止历史报文被下一个相同四元组的连接错误接收</strong></font>（上一次连接中发送的数据如果因为网络拥塞等原因没有及时到达，而是在下一次相同四元组标识的连接中到达，可能会恰好与当前序号相符合，导致被错误接收）</li>
<li><font color='cornflowerblue'><strong>防止伪造ISN造成安全问题</strong></font></li>
</ol>
<p><font color='red'><strong>三次握手中每一次丢失会发生什么？</strong></font></p>
<ul>
<li>第一次丢失：server收不到就不会发SYN+ACK，client超时之后会重传,第一次超时时间为RTO，RTO之后重新发送，超时时间会设置为2RTO，再超时4RTO……以此类推，每次是上一次超时时间的2倍。<font color='orange'><strong>如果达到最大重传次数还没能收到SYN+ACK，client会断开连接</strong></font></li>
</ul>
<p><img src="image-20230412220953844.png" /></p>
<blockquote>
<p>可以看到超时重传时间1s 2s 4s 8s</p>
</blockquote>
<ul>
<li>第二次丢失：SYN+ACK包含两部分作用，如果丢失，<font color='orange'><strong>对客户端来说会认为自己的SYN没发到，超时重传；对服务端来说，自己的SYN发了之后一直没收到ACK，会超时重传SYN+ACK</strong></font>.客户端达到最大重传次数后等待一段时间断开连接，服务端达到最大重传次数后等待一段时间也断开连接.</li>
<li>第三次丢失：server会认为自己的SYN+ACK没有被收到，会超时重传，达到最大重传次数后等待一段时间，断开连接</li>
</ul>
<h3 id="四次挥手">四次挥手</h3>
<p><img
src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" /></p>
<blockquote>
<p>图片来源于<a
href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-和-udp-可以使用同一个端口吗">小林coding</a></p>
</blockquote>
<p><font color='red'><strong>为什么是四次挥手？</strong></font></p>
<p>TCP的半关闭连接，发送FIN意味着发送方不再发送数据了但是还可以接收数据。服务器在收到FIN之后，可能还有数据需要处理或发送回client，所以先发送一个ACK，当server也不会再发送数据时，才会发送FIN给client</p>
<p><font color='red'><strong>一定是四次挥手吗？</strong></font></p>
<p>也有可能是三次挥手，</p>
<ol type="1">
<li><font color='cornflowerblue'><strong>TCP延迟确认开启时</strong></font>，第二次第三次挥手会合并。</li>
</ol>
<p>TCP延迟确认的意思是：将ACK与数据一同发送，提高网络的利用效率，如果有需要发送的数据，会跟ACK一起发送；如果没有，会等待一段时间看是否有数据可以一同发送；如果等待过程中又接收到新的数据，ACK会停止等待立即发送。</p>
<p>（可以通过将socket设置里的TCP_QUICKACK置1关闭延迟确认）</p>
<ol start="2" type="1">
<li>server端没有数据要处理发送了，<font color='cornflowerblue'><strong>可能</strong></font>会将FIN和ACK合并发送</li>
</ol>
<p><font color='red'><strong>第一次挥手丢失了会发生什么？</strong></font></p>
<p>以client为主动关闭方。client会不断超时重传，直到达到上限（tcp_orphan_retries）后等待一段时间直接到close状态</p>
<p><font color='red'><strong>第二次挥手丢失了会发生什么？</strong></font></p>
<p>client收不到server的ACK，不断重传FIN报文，直到收到ACK或者到达最大重传次数，等待一段时间后client断开连接。</p>
<p><font color='red'><strong>第三次挥手丢失了会发生什么？</strong></font></p>
<p>server会不断超时重传，达到最大超时次数后，等待一段时间没收到就断开连接</p>
<p>client在收到第二次的ACK后，进入FIN_WAIT2状态，该状态有时长限制（tcp_fin_timeout），如果等不到server的FIN就会断开连接</p>
<p><font color='red'><strong>第四次挥手丢失了会发生什么？</strong></font></p>
<p>服务器收不到ACK报文，会不断重传第三次的FIN，直到到达最大重传次数，之后等待一段时间，退出LAST_ACK状态，CLOSE</p>
<p>客户端发送ACK之后，会进入TIME_WAIT状态并启动计时器（2Maximum Segment
Lifetime），每次如果能够收到重传的FIN，会重置计时器。如果收不到，等待2MSL后退出TIME_WAIT状态，CLOSE</p>
<p><font color='red'><strong>为什么TIME_WAIT等待时间是2MSL（为什么需要TIME_WAIT状态）？</strong></font></p>
<ol type="1">
<li>给FIN一次重发的机会。如果第一次FIN丢失或ACK丢失，第二次FIN重发和发送ACK返回到server的时间刚好能在第二个MSL内到达；或第二次FIN刚好能在2MSL之内到达，再次发送ACK</li>
<li>确保当前连接中的所有数据失效，不会留到下一个连接中造成影响。</li>
</ol>
<p><font color='red'><strong>TIME_WAIT过多的危害以及如何缓解</strong></font></p>
<p>TIME_WAIT状态时不会再有实际数据的传输，但仍然处于连接状态中：</p>
<ul>
<li>对client来说，会占用过多<font color='cornflowerblue'><strong>端口资源</strong></font>，导致无法处理新的连接</li>
<li>对server来说，由于每个TCP连接是由TCP四元组确定的，所以只要IP不同，端口资源的影响能够处理。但仍然会占用<font color='cornflowerblue'><strong>系统资源</strong></font>，如文件描述符、寄存器、CPU资源、内存资源等。</li>
</ul>
<p>优化方法：</p>
<ol type="1">
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps
选项。前者只能用于连接发起方，<strong>开启该功能后，在调用 connect()
函数时，内核会随机找一个 time_wait 状态超过 1
秒的连接给新的连接复用</strong>。后者开启了时间戳，所以有问题的数据包会根据时间戳是否过期进行丢弃，2MSL的一大作用失效。</li>
<li>net.ipv4.tcp_max_tw_buckets。<strong>当系统中处于 TIME_WAIT
的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT
连接状态重置</strong></li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ol>
<blockquote>
<p>SO_LINGER设置的是延迟关闭的时间，在l_linger为0，l_onoff非0的情况下，调用close后会立即发送RST，跳过四次挥手阶段</p>
<p>之前记混的一个：SO_REUSEADDR是允许完全重复的捆绑</p>
</blockquote>
<p><font color='red'><strong>服务器出现大量TIME_WAIT的原因</strong></font></p>
<p>TIME_WAIT状态是主动关闭方才会出现的状态，此情况说明服务器主动断开了大量TCP连接</p>
<ul>
<li>没有使用HTTP长连接</li>
</ul>
<p>HTTP长连接在HTTP/1.0中默认关闭，HTTP/1.1中默认开启。需要<font color='red'><strong>双方</strong></font>在请求-响应的header中开启Connection:
Keep-Alive选项。<font color='cornflowerblue'><strong>大多数 Web
服务的实现，不管哪一方禁用了 HTTP
Keep-Alive，都是由服务端主动关闭连接</strong></font>，那么此时服务端上就会出现
TIME_WAIT 状态的连接。</p>
<blockquote>
<p>TCP也有Keepalive，指的是<font color='cornflowerblue'><strong>TCP的保活机制</strong></font>。如果TCP连接中一直没有数据交互，触发了TCP保活机制，那么内核中的TCP协议栈会发送探测报文（一般保活功能是为服务器程序提供的）。客户主机必须处于以下四个状态之一：</p>
<ul>
<li><p>客户主机正常运行且从服务器可达。会正常响应探测报文，保活定时器复位</p></li>
<li><p>客户主机崩溃，并且关闭或者正在重新启动。无法响应探测报文，服务器将探测报文超时时间设置为75s，即每75s发送一个探测报文，如果10个之后没有收到响应，服务器认为客户主机已经关闭并终止连接（数值来自于《TCP/IP详解，卷1》，linux默认保活时间7200s，探测次数9次，时间间隔75s,也就是7875s之后会发现连接“死亡”）</p>
<p><img src="image-20230413093137164.png" /></p></li>
<li><p>客户主机正常运行，但从服务器不可达。与上边的状态相同</p></li>
<li><p>客户主机崩溃，但已经重新启动。服务器会收到响应，但是响应是一个RST，服务器终止连接</p></li>
</ul>
<p><font color='A2CD5A'><strong>P.S.
还有种情况是进程崩溃，这时OS会回收进程资源发送FIN报文，服务器是可以感知的</strong></font></p>
</blockquote>
<ul>
<li>HTTP长连接超时</li>
</ul>
<p>web服务软件一般会提供一个参数指定HTTP长连接的超时时间，以防止没有请求的连接占用资源。（nginx的keepalive_timeout参数）定时器到时间服务端会关闭该连接，出现TIME_WAIT状态</p>
<ul>
<li>HTTP长连接请求数量达到上限</li>
</ul>
<p>Web 服务端通常会有个参数，来定义一条 HTTP
长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。（nginx的keepalive_requests参数）</p>
<p><font color='red'><strong>服务器出现大量CLOSE_WAIT的原因</strong></font></p>
<p>CLOSE_WAIT出现是在收到FIN报文之后，向应用程序交付EOF，在调用close()之后会转为LAST_ACK状态</p>
<p><font color='cornflowerblue'><strong>当服务端出现大量 CLOSE_WAIT
状态的连接的时候，说明服务端的程序没有调用 close
函数关闭连接</strong></font></p>
<h2 id="tcp重传机制">TCP重传机制</h2>
<p>重传是TCP实现可靠传输的方式之一</p>
<h3 id="超时重传">超时重传</h3>
<p>发送数据时设置一个定时器，如果超时没有收到ACK（数据包丢失或者应答丢失），就会重发数据。</p>
<p>超时时间（RTO）的设定很重要，<font color='orange'><strong>过长：传输效率低；过短：不必要重传浪费资源，增加网络拥塞程度</strong></font></p>
<p>RTO的值应该略大于RTT（Round-Trip
Time）,因为RTT是描述数据包的往返时间的，如果正常的话，RTT内发送方会收到ACK应答。但是路由器和网络流量均会变化，因此<font color='cornflowerblue'><strong>RTT也可能会经常发生变化，所以TCP应该跟踪其变化并相应地改变RTO</strong></font></p>
<p>RTT的估计需要采样RTT的时间，并且要加权平均，因为网络状况是不断变化的；另外还需要采样RTT的波动范围：</p>
<p><img src="image-20230413101400179.png" /></p>
<p>A是加权平滑的RTT，M是新测量到的RTT，D是被平滑的均值偏差</p>
<p>g=0.125,h=0.25</p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP
的策略是<font color='cornflowerblue'><strong>超时间隔加倍</strong></font>。</p>
<p>也就是<font color='cornflowerblue'><strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></font></p>
<p><font color='red'><strong>超时重传的问题是超时周期可能相对较长</strong></font></p>
<h3 id="快速重传">快速重传</h3>
<p>快速重传<font color='cornflowerblue'><strong>以数据驱动重传</strong></font></p>
<p>快速重传的工作方式是当收到三个相同的 ACK
报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" /></p>
<p>快速重传解决了超时重传超时周期过长的问题，但仍然存在<font color='red'><strong>不确定需要重传的数据报文</strong></font>的问题</p>
<p>上图中只重传Seq2没有问题，但是如果Seq3-5中也有丢失（比如Seq3），此时发送方收到的仍然是ACK2，所以<font color='A2CD5A'><strong>重传之后会继续收到三个ACK3，然后再重传Seq3</strong></font></p>
<h3 id="sack-selective-acknowledgment">SACK (Selective
Acknowledgment)</h3>
<p>选择性确认，需要在TCP头部的选项字段中加一个SACK，含义为已收到的数据的信息，在ACK报文中将SACK返回给发送方。</p>
<p>发送方收到三个相同的ACK报文后，触发快速重传机制，同时读取SACK信息，确定后续丢失的数据并重传，比如上图中，收到三个ACK2，说明2之前的都已被成功接收，然后SACK=3-5，所以2之后的也没有丢失，只重传2</p>
<p>通过net.ipv4.tcp_sack可以确认该功能是否开启</p>
<p><img src="image-20230413104620567.png" /></p>
<h3 id="duplicate-sack">Duplicate SACK</h3>
<p>使用了 SACK
来告诉发送方有哪些数据<font color='red'><strong>被重复接收</strong></font>了</p>
<p>SACK是不是D-SACK，取决于ACK的值和SACK范围之间的大小关系，比如ACK=1000，SACK=1500-3000,那就说明是1000-1500没收到；如果ACK为3000，SACK=2000-2500，显然就是说2000-2500数据重复接收了</p>
<p>D-SACK的优点有：</p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK
包丢了</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了（被网络延迟的包可能会在快速重传之后到接收方，接收方这时候可以通过SACK反馈给发送方）</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了</li>
</ul>
<h2 id="tcp流量控制">TCP流量控制</h2>
<h3 id="滑动窗口">滑动窗口</h3>
<p>使用滑动窗口控制发送的数据量：</p>
<p><img src="image-20230413133935036.png" /></p>
<blockquote>
<p>图片来自《TCP/IP详解 卷1》，为发送窗口</p>
</blockquote>
<ul>
<li><font color='cornflowerblue'><strong>提供窗口</strong></font>的大小是由ACK中<font color='cornflowerblue'><strong>窗口大小字段</strong></font>控制的</li>
<li><font color='A2CD5A'><strong>可用窗口</strong></font>根据确认<font color='A2CD5A'><strong>序列号</strong></font>计算，指的是可以立即发送的数据量（无须等待之前的ACK）</li>
<li>关闭close：左边界右移，发生在已发送数据得到ACK确认时</li>
<li>打开open：右边界右移，发生在确认数据得到处理时</li>
<li>收缩shrink：右边界左移，RFC1122不支持该做法，但TCP必须要能处理该问题</li>
</ul>
<p><font color='red'><strong>总之，发送方的窗口由接收方通告，ACK确定左边界位置，头部窗口大小字段配合ACK确定右边界</strong></font></p>
<h3 id="流量控制">流量控制</h3>
<p>发送方根据接收方的实际接收能力控制发送的数据量</p>
<p>通过滑动窗口实现，而滑动窗口则是OS开辟的一块缓存空间，所以有可能会被OS调整。如果先减少缓存再收缩窗口，有可能出现丢包的现象。<font color='cornflowerblue'><strong>TCP
规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></font></p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" /></p>
<h3 id="窗口关闭">窗口关闭</h3>
<p>问题：接收方窗口为0后通知发送方，发送方会停止发送数据。如果之后接收方重新打开窗口，通知发送方的报文丢失，会导致双方相互等待，导致死锁。</p>
<p>解决：TCP为每个连接设定一个定时器，<font color='cornflowerblue'><strong>只要收到对方的0窗口通知，就启动定时器</strong></font>。定时器超时，会发送窗口探测报文，如果对方收到探测报文，会回答自己的接收窗口大小，此后：</p>
<ul>
<li>如果接收窗口还是0，那么重置计时器</li>
<li>如果接收窗口打开，那么死锁解除</li>
</ul>
<p>窗口探测一般为3次，每次大约30-60s</p>
<h3 id="糊涂窗口综合征silly-window-syndrome">糊涂窗口综合征（Silly
Window Syndrome）</h3>
<p>出现该问题时，发送方发送的都是一些较小的数据段，导致每个报文段中真正有用的数据相对于头部信息的比例较小，传输效率较低。（<font color='A2CD5A'><strong>比如，接收方处理数据的速度非常慢，然后慢慢发送方的窗口就变为0，然后接收方处理完几个字节的数据接着就通告对方窗口打开了，发送方欣喜若狂，直接发了几个字节还不如头部长的数据过去</strong></font>）</p>
<p>SWS会出现在基于窗口的流量控制中，尤其是在不使用固定大小报文段的情况。从上边这个例子可以看出，发送方和接收方都可能导致SWS：接收方有个小窗口就立即通告；发送方有个小数据段就立即发送。</p>
<p>对症下药，避免SWS的规则如下（<font color='cornflowerblue'><strong>同时满足</strong></font>）：</p>
<ol type="1">
<li><p><font color='red'><strong>接收端不通告小的窗口值。</strong></font>根据RFC1122描述的接收算法，当前窗口&lt;min(MSS,recv_buffer/2)时，不通告比当前窗口更大的窗口值。该规则可以使用在处理接收数据使得可用缓存增大中，或者响应窗口探测报文时</p></li>
<li><p><font color='red'><strong>发送端不发送小的报文段。</strong></font>主要用Nagle算法控制发送时机，为避免SWS，当满足以下条件<font color='cornflowerblue'><strong>之一</strong></font>时才能发送</p>
<ol type="1">
<li>全长（MSS）报文段，窗口大小大于MSS</li>
<li>数据段长度&gt;=接收端<font color='cornflowerblue'><strong>通告过的最大窗口值</strong></font>的一半（这个条件主要用于比较旧的原始主机）</li>
<li>之前所有数据的ACK都已被接收，或禁用了Nagle算法</li>
</ol>
<blockquote>
<p>根据<a href="https://datatracker.ietf.org/doc/html/rfc896">RFC
896</a>，Nagle实际上控制的是网络拥塞，其目的定义为“The solution is to
inhibit the sending of new TCP segments when new outgoing data arrives
from the user if any previously transmitted data on the connection
remains unacknowledged.”</p>
<p>也就是说每个TCP连接上最多只能有一个未被确认的数据段，如果之前的数据有ACK没收到不会继续发送</p>
<p>RFC9293中没有规定Nagle算法的实现，这里给个wikipidia上的伪代码描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> there is new data to send then</span><br><span class="line">    <span class="keyword">if</span> the window size ≥ MSS and available data is ≥ MSS then</span><br><span class="line">        send complete MSS segment now</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> there is unconfirmed data still in the pipe then</span><br><span class="line">            enqueue data in the buffer until an acknowledge is received</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            send data immediately</span><br><span class="line">        end <span class="keyword">if</span></span><br><span class="line">    end <span class="keyword">if</span></span><br><span class="line">end <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">getsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(<span class="type">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TCP_NODELAY opt: %d\n&quot;</span>,value);</span><br></pre></td></tr></table></figure>
<p>用上边的code测试了Nagle算法默认应该是关闭的，小林那里提到默认是打开的，应该是OS的默认设置啥的不一样吧233</p></li>
</ol>
<h2 id="tcp拥塞控制">TCP拥塞控制</h2>
<p>流量控制是避免发送方的数据不会填满接收方缓存，导致数据丢失</p>
<p>拥塞控制是对网络而言，避免发送方的数据填满整个网络。网络拥堵时如果继续发送大量数据，可能会导致延迟、丢失，然后TCP重传，恶性循环。</p>
<p>所以发送方会维护一个<font color='cornflowerblue'><strong>拥塞窗口</strong></font>cwnd,此时发送窗口的值为min(cwnd,rwnd)，其变化的基本逻辑就是出现拥塞减小；没有拥塞增大</p>
<p>所以就需要进行拥塞检测，但是没有一个明确的信号可以告知发送方拥塞发生，那发送方直接就看丢包。出现了丢包超时重传，就认为发生了网络拥塞</p>
<h3 id="慢启动">慢启动</h3>
<p>发生时间：TCP连接建立时；检测到重传超时导致的丢包；TCP发送端长时间处于空闲状态（可能）；</p>
<blockquote>
<p>RFC5681中对慢启动目的和使用情况的解释：Beginning transmission into a
network with unknown conditions requires TCP to slowly probe the network
to determine the available capacity, in order to avoid congesting the
network with an inappropriately large burst of data.The slow start
algorithm is used for this purpose at the beginning of a transfer, or
after repairing loss detected by the retransmission timer.</p>
</blockquote>
<p>这里假设初始窗口大小为1
SMSS（以下就省略SMSS这个单位了；另，具体的IW设定方式在RFC5681有介绍），收到一个数据段的ACK后cwnd=2，然后发送2个数据段，如果成功收到新的ACK，cwnd=4，cwnd=8……也就是<font color='red'><strong>当发送方每收到一个
ACK，拥塞窗口 cwnd 的大小就会加 1</strong></font></p>
<blockquote>
<p>可以看出慢启动的增长是个指数增长，看似很快，但称其为慢启动意思是与一开始就以最大可用速率发送相比已经算慢了</p>
</blockquote>
<p><img src="image-20230413164455176.png" /></p>
<blockquote>
<p>图源自《TCP/IP详解 卷1》</p>
</blockquote>
<p>慢启动发送数据段的数量达到慢启动门限（cwnd&gt;=ssthresh）后会进入拥塞避免算法</p>
<h3 id="拥塞避免">拥塞避免</h3>
<p>进入拥塞避免之后，cwnd的增长值变为线性，此时每接收到1个ACK,cwnd =
cwnd + SMSS*SMSS/cwnd.这个式子化简一下就是cwnd = cwnd + (1/k)*SMSS</p>
<blockquote>
<p>cwnd = cwnd + SMSS*SMSS/cwnd</p>
<p>cwnd = k*SMSS + SMSS*SMSS/(k*SMSS)</p>
<p>cwnd = k*SMSS + SMSS/k</p>
<p>将cwnd=k*SMSS代回，cwnd = cwnd + (SMSS/k)</p>
</blockquote>
<p>假设ssthresh=8，那么发送八个数据段，收到8个ACK后cwnd=9，然后再发9个数据段cwnd=10，就变为了一个累加增长。</p>
<p><img src="image-20230413165618984.png" /></p>
<h3 id="快速恢复">快速恢复</h3>
<p>cwnd继续增长，如果出现了快速重传中的三个相同ACK，TCP就认为现在发送超出了网络传输能力的范围，<font color='red'><strong>此时将ssthresh减小为cwnd/2，但不小于2*SMSS，cwnd=ssthresh+3</strong></font></p>
<p>之后：</p>
<ul>
<li>重传丢失的数据包</li>
<li>如果再收到重复ACK，cwnd+=1</li>
<li>如果收到新的ACK,cwnd=ssthresh</li>
</ul>
<p>这个过程中，首先目的是为了减小cwnd，因为已经发生了拥塞，然后中间cwnd的增加是为了尽快将丢失的数据包发送给目标，最后收到新的ACK说明重传成功了，然后再将cwnd减小。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题部分题解（2023.4.12之前）</title>
    <url>/2023/04/12/leetcode%E5%88%B7%E9%A2%98%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%882023-4-12%E4%B9%8B%E5%89%8D%EF%BC%89/</url>
    <content><![CDATA[<p>主要是链表相关的一些题目，也包含一些其他乱七八糟的</p>
<span id="more"></span>
<h2 id="剑指offer-30.-包含min函数的栈">剑指offer 30.
包含min函数的栈</h2>
<p>辅助栈，一个栈记录当前栈里的所有元素；另一个栈包含每次加入新元素时当前的最小值。</p>
<p>调用min函数时直接从辅助栈里返回栈顶元素。</p>
<p>pop时需要注意，如果原始栈顶的元素在辅助栈顶存在，则说明该元素被push时是一个最小值，同样需要被pop</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; originStack,minStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        minStack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=minStack.<span class="built_in">top</span>()) minStack.<span class="built_in">push</span>(x);</span><br><span class="line">        originStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = originStack.<span class="built_in">top</span>();</span><br><span class="line">        originStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tmp==minStack.<span class="built_in">top</span>()) minStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minStack.<span class="built_in">top</span>()!=INT_MAX) <span class="keyword">return</span> minStack.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> minStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-24.-反转链表">剑指offer 24. 反转链表</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>逐节点将next的关系反转即可，要做到这一点，需要做到如下步骤，假设输入链表中两个节点为prev和cur，且prev-&gt;next
= cur：</p>
<ol type="1">
<li>先记录下当前节点的下一个节点tmp = cur-&gt;next;</li>
<li>反转两个节点的关系，即cur-&gt;next = prev;</li>
<li>继续处理下一组节点，更新prev = cur,cur = tmp;</li>
<li>根据以上的步骤，当cur在第一个节点时，prev应该为nullptr</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-35.-复制复杂的链表">剑指offer 35. 复制复杂的链表</h2>
<p>链表中每个节点除了有next指向下一个节点之外，还有random指向一个随机节点。</p>
<p>复制过程中，在处理当前节点时，其random节点可能还没有生成，导致无法将二者连接</p>
<p>所以容易想到先遍历一遍，把每个节点对应的复制出来的新节点先存储起来，这个过程用哈希表存储。</p>
<p>然后在遍历一遍，这次遍历是对哈希表中存储的新节点（值）进行的，此时已经保证所有节点都生成了，将存储的所有节点next和random链接起来即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; mp;</span><br><span class="line">    Node* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        mp[cur] = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);<span class="comment">//复制新节点</span></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;<span class="comment">//重新遍历新节点，此时相当于用原链表的节点做键去查找新节点</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        mp[cur]-&gt;next = mp[cur-&gt;next];<span class="comment">//更新复制出来的节点的next关系</span></span><br><span class="line">        mp[cur]-&gt;random = mp[cur-&gt;random];<span class="comment">//更新random关系</span></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节约空间：拼接+拆分</p>
<p>先将原链表每个节点之后复制一个新节点（完成复制所有节点）</p>
<p>访问原节点的random指向节点时，新节点为cur-&gt;next，由于每个节点对应的新节点都在其之后，所以其random指向节点应为cur-&gt;random-&gt;next（更新完所有random关系）</p>
<p>再遍历一遍链表，把旧节点拆分掉，两个链表设置好头节点然后间隔1个设置next关系即可（更新完所有next关系）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        cur = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;random)&#123;</span><br><span class="line">            cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head-&gt;next;</span><br><span class="line">    Node* pre = head;</span><br><span class="line">    Node* res = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-58.-左旋转字符串">剑指offer 58. 左旋转字符串</h2>
<p>将字符串前n个字符移动到字符串尾部</p>
<p>思路：字符串被分成了两部分，为了使这两部分的位置对调，可以考虑整体反转；但整体反转之后每部分的内部也发生了反转，所以先在每部分内部局部反转，再整体反转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>()+n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>类似题目：<a
href="https://leetcode.cn/problems/reverse-words-in-a-string/">151.
反转字符串中的单词</a></strong></p>
<p>给一个字符串s,反转其中<strong>单词的顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>
<p>思路是相同的，加上考虑原地反转降低空间复杂度至O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> k = <span class="number">0</span>;<span class="comment">//k是负责原地复制反转的指针</span></span><br><span class="line">        <span class="type">size_t</span> i = <span class="number">0</span>,j = <span class="number">0</span>;<span class="comment">//i是探路的快指针，j是慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>() &amp;&amp; s[i]==<span class="string">&#x27; &#x27;</span>) i++;<span class="comment">//快指针先去找所有连续的空格</span></span><br><span class="line">            <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()) <span class="keyword">break</span>;<span class="comment">//快指针到结尾了，因为找空格是一次新的局部反转的开始，所以说明已经对最后一个单词做完了局部反转</span></span><br><span class="line">            j = i;<span class="comment">//慢指针跟上，指到某个单词的开始位置</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>() &amp;&amp; s[i]!=<span class="string">&#x27; &#x27;</span>) i++;<span class="comment">//快指针继续找所有的单词字符</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+j,s.<span class="built_in">begin</span>()+i);<span class="comment">//局部反转</span></span><br><span class="line">            <span class="keyword">if</span>(k!=<span class="number">0</span>) s[k++] =<span class="string">&#x27; &#x27;</span>;<span class="comment">//k控制将所有单词从原字符串开头开始复制，所以如果k不在开头，要加一个空格将两个单词隔开</span></span><br><span class="line">            <span class="keyword">while</span>(j!=i) s[k++] = s[j++];<span class="comment">//复制反转后的单词</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + k,s.<span class="built_in">end</span>());<span class="comment">//擦除多余的空格</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="comment">//全局反转</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="C:\Users\er1so\Documents\Tencent%20Files\540188512\FileRecv\MobileFile\IMG_20230214_155323.jpg" /></p>
<h2 id="剑指offer-53---i.-在排序数组中查找数字-i">剑指offer 53 - I.
在排序数组中查找数字 I</h2>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8 输出: 2</p>
<p>示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6 输出: 0</p>
<p>以后排序数组的搜索先想想二分……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftRes = <span class="number">-1</span>,rightRes = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>,rb = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//搜索最左边界</span></span><br><span class="line">        <span class="keyword">while</span>(lb&lt;rb)&#123;</span><br><span class="line">            <span class="type">int</span> mid = lb + (rb - lb) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                <span class="comment">//搜最左边界时，如果大于等于target说明左边界不可能在mid右侧</span></span><br><span class="line">                rb = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                lb = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftRes = lb;</span><br><span class="line">        <span class="comment">//搜索最右边界</span></span><br><span class="line">        lb = <span class="number">0</span>;</span><br><span class="line">        rb = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lb&lt;rb)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (lb+rb+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                <span class="comment">//搜最右边界时，如果小于等于target说明有边界不可能在mid左侧</span></span><br><span class="line">                lb = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rb = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rightRes = lb;</span><br><span class="line">        <span class="keyword">if</span>(leftRes&gt;=<span class="number">0</span> &amp;&amp; leftRes&lt;nums.<span class="built_in">size</span>()</span><br><span class="line">        &amp;&amp; rightRes&gt;=<span class="number">0</span> &amp;&amp; rightRes&lt;nums.<span class="built_in">size</span>()</span><br><span class="line">        &amp;&amp; nums[rightRes]==target &amp;&amp; nums[leftRes]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRes - leftRes + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-53---ii.-0n-1中缺失的数字">剑指offer 53 - II.
0～n-1中缺失的数字</h2>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
<p>以后排序数组的搜索先想想二分……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lb = <span class="number">0</span>,rb = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lb&lt;rb)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (lb+rb+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]=mid)&#123;</span><br><span class="line">            <span class="comment">//如果mid的索引和元素值一致，说明其左边数字全是存在的，应该更新lb</span></span><br><span class="line">            lb = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rb = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当左边界与右边界相等时，可能已经指向该缺失的数字，但是还有一种可能是缺失的数字在数组之外</span></span><br><span class="line">    <span class="comment">//正常应该return lb;，如果缺失数字则应该返回lb+1</span></span><br><span class="line">    <span class="keyword">if</span>(nums[lb]!=lb) <span class="keyword">return</span> lb;</span><br><span class="line">    <span class="keyword">return</span> lb+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除链表中倒数第n个结点">删除链表中倒数第N个结点</h2>
<p>双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="type">int</span> tmp = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            first = first-&gt;next;<span class="comment">//先把first移动n-1个位置，使first和second保持n-1的间距</span></span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//同时移动直到first到达结尾节点，此时second指向待删除节点的前节点</span></span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        ListNode* res = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>辅助栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        stack&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = s.<span class="built_in">top</span>();</span><br><span class="line">        tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">        ListNode* res = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-04.-二维数组中的查找">剑指offer 04.
二维数组中的查找</h2>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减
的顺序排序，每一列都按照从上到下 非递减
的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n次二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>||matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> lb = <span class="number">0</span>,rb = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(lb&lt;rb)&#123;</span><br><span class="line">                <span class="type">int</span> mid = (lb+rb+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][mid]&lt;=target) lb = mid;</span><br><span class="line">                <span class="keyword">else</span> rb = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][lb]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标志数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>||matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;matrix.<span class="built_in">size</span>()&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]&gt;target) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;target) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" /></p>
<h2 id="剑指offer-11.-旋转数组的最小数字">剑指offer 11.
旋转数组的最小数字</h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，称之为数组的旋转。</p>
<p>返回旋转数组的<strong>最小元素</strong></p>
<p><strong>因为「二分」的本质是二段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。</strong></p>
<p><img
src="https://pic.leetcode-cn.com/1617852745-LoBNPK-image.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>,rb = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lb&lt;rb &amp;&amp; nums[<span class="number">0</span>]==nums[rb]) rb--;</span><br><span class="line">        <span class="keyword">while</span>(lb&lt;rb)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (lb+rb)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=nums[rb])&#123;</span><br><span class="line">                rb = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                lb = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lb];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-50.-第一个只出现一次的字符">剑指offer 50.
第一个只出现一次的字符</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; keys;<span class="comment">//记录keys被添加到哈希表里的顺序，第二次遍历直接按序遍历哈希表</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c :s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(c)==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                mp[c] = <span class="number">1</span>;</span><br><span class="line">                keys.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k : keys)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[k]==<span class="number">1</span>) <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(c)==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                mp[c] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//延迟删除，如果当前字符出现超过1次，但不在队首，</span></span><br><span class="line">                <span class="comment">//那么该字符不会影响最终结果，可以先不处理</span></span><br><span class="line">                mp[c]++;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; mp[q.<span class="built_in">front</span>()]&gt;<span class="number">1</span>) q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>()?<span class="string">&#x27; &#x27;</span>:q.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="求x的平方根">求x的平方根</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意数据范围</span></span><br><span class="line"><span class="comment">//这个地方虽然是求平方不超过x的最大的，但是该模板计算mid会溢出</span></span><br><span class="line"><span class="comment">//所以改成求平方大于等于x的最小的，如果平方值为x则直接返回，否则-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>||x==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">int</span> lb = <span class="number">1</span>,rb = x;</span><br><span class="line">        <span class="keyword">while</span>(lb&lt;rb)&#123;</span><br><span class="line">            <span class="type">int</span> mid = lb+(rb-lb)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)mid*mid&gt;=x)&#123;</span><br><span class="line">                rb = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)mid*mid&lt;x)&#123;</span><br><span class="line">                lb = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)lb*lb==(<span class="type">long</span> <span class="type">long</span>)x ? lb : lb<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-28.-对称的二叉树">剑指offer 28. 对称的二叉树</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-26.-树的子结构">剑指offer 26. 树的子结构</h2>
<p>要判断B是否是A的子结构，直接从根节点开始判断，递归比较每个节点即可</p>
<p><img
src="https://pic.leetcode-cn.com/19a78f61f77a982e31505fe36ceae2b906be5a8c05f22d112d3aff132bc0b3a5-image.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="literal">nullptr</span>||B==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contains</span>(A,B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//开始递归时保证了B不可能为空，此时B为空说明已经全部搜索完</span></span><br><span class="line">        <span class="keyword">if</span>(A==<span class="literal">nullptr</span>||A-&gt;val!=B-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contains</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="built_in">contains</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是，判断B是否是A的子结构，<strong>不一定从A的根节点开始判断</strong></p>
<p>所以加入递归的条件，如果从根节点开始判断B不是A的子结构，那么再尝试从左右子树中判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="literal">nullptr</span>||B==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contains</span>(A,B)||<span class="built_in">isSubStructure</span>(A-&gt;left, B) ||<span class="built_in">isSubStructure</span>(A-&gt;right, B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//开始递归时保证了B不可能为空，此时B为空说明已经全部搜索完</span></span><br><span class="line">        <span class="keyword">if</span>(A==<span class="literal">nullptr</span>||A-&gt;val!=B-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//B不为空但是A已经为空了，或者二者当前节点值不相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contains</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="built_in">contains</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="环形链表">141. 环形链表</h2>
<p>判断链表中是否有环</p>
<p>可以用哈希表记录是否出现过该节点判断</p>
<p>也可以用Floyd
判圈算法，假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置
head，而快指针在位置
head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" /></p>
<p><strong>入环点位置分析</strong></p>
<p>假设在紫色位置处快慢指针相遇，则慢指针走过<span
class="math inline">\(a+b\)</span>，快指针走过<span
class="math inline">\(a+n(b+c)+b=a+(n+1)b+c\)</span></p>
<p>按照快慢指针的步幅关系，快指针的距离一定是慢指针的2倍： <span
class="math display">\[
2(a+b)=a+(n+1)b+c
\]</span> <span class="math display">\[
a=(n-1)(b+c)+c
\]</span>
根据这个关系，在快慢指针相遇时，新指针ptr从链表头出发与慢指针以同样步幅移动，走过a到达入环点时，慢指针一定与其在入环点相遇</p>
<h2 id="删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素
II</h2>
<p><img src="image-20230220214657810.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val==tmp)&#123;</span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》笔记（13-16章）</title>
    <url>/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p>《C++ Primer》 13-16章笔记</p>
<span id="more"></span>
<h2 id="第13章-拷贝控制">第13章 拷贝控制</h2>
<p><strong>拷贝构造函数、移动构造函数</strong>负责定义用同类型的另一个对象初始化本对象时做什么</p>
<p><strong>拷贝赋值运算符、移动赋值运算符</strong>定义将同类型的另一个对象赋予同类型对象时做什么</p>
<p><strong>析构函数</strong>定义了此类型对象销毁时做什么</p>
<h3 id="拷贝赋值与销毁">拷贝、赋值与销毁</h3>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<p>构造函数+<strong>第一个参数是自身类类型的引用+任何额外参数都有默认值</strong></p>
<p>拷贝函数在几种情况下都会被隐式的使用，因此拷贝函数不应该是explicit的</p>
<p>一般情况下，<strong>合成构造函数</strong>会将给定对象中每个<strong>非static参数成员</strong>逐个拷贝到正在创建的对象中。对类类型成员会使用其拷贝构造函数来拷贝；对内置类型成员则直接拷贝</p>
<p>拷贝初始化发生的情况：</p>
<ul>
<li>用=定义变量时会发生</li>
<li>将一个对象作为实参传递给一个<strong>非引用类型</strong>的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
<li>标准库容器初始化或是调用其insert或push成员</li>
</ul>
<h4 id="拷贝赋值运算符">拷贝赋值运算符</h4>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用</p>
<p>将右侧对象中每个非static成员赋予左侧运算对象的对应成员</p>
<h4 id="析构函数">析构函数</h4>
<p>释放对象使用的资源，销毁对象的非static数据成员</p>
<p>不能重载，每个类只有一个</p>
<p>析构函数<strong>首先执行函数体</strong>，然后销毁成员，按初始化顺序<strong>逆序销毁</strong></p>
<p>销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。<strong>智能指针是类类型，具有析构函数，智能指针在析构阶段自动销毁</strong></p>
<p>什么时候调用析构函数：</p>
<ul>
<li>变量离开其作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其中元素被销毁</li>
<li>动态分配的对象，对指向它的指针应用delete运算符被销毁时</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h4 id="三五法则">三/五法则</h4>
<p><strong>如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符</strong></p>
<p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>
<h4 id="使用default">使用=default</h4>
<p>在类内修饰成员声明时，会隐式的声明为内联的；如果不希望内联，应该仅在类外定义使用=default</p>
<h4 id="阻止拷贝">阻止拷贝</h4>
<p>例如，iostream类阻止了拷贝，避免多个对象写入或读取相同的IO缓冲</p>
<p>新标准下可以通过拷贝构造函数和拷贝赋值运算符定义为deleted
function来阻止拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span>&#123;</span><br><span class="line">    <span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span> = (<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>=delete</strong>必须出现在函数第一次声明的时候</li>
<li>可以对任何函数指定=delete，而只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default</li>
<li><strong>析构函数不能是deleted
function</strong>,否则，不能定义该类型的变量，也不能释放指向该类型动态分配对象的指针</li>
<li><strong>合成的拷贝控制成员可能是deleted</strong>,如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为deleted
function</li>
</ul>
<h3 id="拷贝控制和资源管理">拷贝控制和资源管理</h3>
<p>行为像值的类：拷贝构造和拷贝赋值时对内部成员进行拷贝</p>
<p>行为像指针的类：拷贝构造拷贝赋值中使用shared_ptr的引用计数管理资源</p>
<h3 id="交换操作">交换操作</h3>
<h3 id="动态内存管理类">动态内存管理类</h3>
<p>move函数，在utility头文件中</p>
<h3 id="对象移动">对象移动</h3>
<p>移动而非拷贝对象在某些情况下会大幅提升性能</p>
<p>标准库容器、string和shared_ptr既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝</p>
<h4 id="右值引用">右值引用</h4>
<p><strong>回忆：左值和右值是表达式的属性，一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值</strong></p>
<p>右值引用是必须绑定到右值的引用。我们<strong>通过&amp;&amp;获得右值引用。</strong></p>
<p>右值引用有一个重要的性质：只能绑定到一个将要销毁的对象。</p>
<p>常规引用（左值引用）不能将其绑定到要求转换的表达式、字面常量或者返回右值的表达式上。<strong>右值引用可以，但不能直接将右值引用直接绑定到一个左值上</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;<span class="comment">//正确，左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;<span class="comment">//错误，i是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;<span class="comment">//错误，i*42是个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>;<span class="comment">//正确，const引用可以绑定到右值上</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><strong>进一步区分左值右值：</strong></p>
<ul>
<li>返回左值引用的函数，连同赋值、下标、解引用和前置递增、前置递减运算符，返回的都是左值表达式</li>
<li>返回非引用类型的函数，连同算术、关系、位、后置递增和后置递减运算符，都生成右值。可以将const左值引用或者右值引用绑定到这类表达式上</li>
<li>左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时对象。</li>
<li>变量是左值，<strong>即便该变量是右值引用类型它也是左值</strong></li>
</ul>
<p><strong>标准库move函数：</strong></p>
<p>显式地将一个左值转换为对应的右值引用类型，move函数可以获得绑定到左值上的右值引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>
<p><strong>调用move意味着承诺除了对rr1赋值或者销毁之外，将不再使用它</strong></p>
<p>使用move的代码应该使用std::move，这也可以避免潜在的名字冲突</p>
<h4 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h4>
<p>让自己的类型支持移动操作，需要定义这两个成员</p>
<p>这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”而非拷贝资源
****</p>
<p><strong>移动构造函数</strong></p>
<p>移动构造函数的第一个参数是该类类型的一个引用，但是是右值引用。</p>
<p>移动构造函数除了完成资源移动外，还必须确保移动后<strong>源对象处于销毁无害的状态</strong></p>
<p>移动构造函数不分配任何新内存 ****</p>
<p><strong>移动赋值运算符</strong></p>
<p>必须正确处理自赋值。</p>
<p>移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p>
<hr />
<p><strong>合成的移动操作</strong></p>
<p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为之合成移动构造函数和移动赋值运算符了。</p>
<p><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。</strong></p>
<p><img src="image-20230303163225705.png" /></p>
<hr />
<p>如果拷贝构造和移动构造并存，根据构造或赋值传入参数的类型，处理方式是：移动右值，拷贝左值。<strong>但如果没有移动构造函数，右值也被拷贝</strong></p>
<hr />
<p><strong>移动迭代器（cpp11）</strong></p>
<p>移动迭代器解引用运算符生成的是一个右值引用</p>
<p>标准库的make_move_iterator函数可以将一个普通迭代器转换为一个移动迭代器。</p>
<p>原迭代器的所有其他操作在移动迭代器中都照常工作。</p>
<p>需要注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此只有在确信算法在为一个元素赋值或者将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法</p>
<h4 id="右值引用和成员函数">右值引用和成员函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以强制指出this指向的对象（左侧运算对象）的属性是左值或者右值，使用引用限定符&amp;或&amp;&amp;，位置在参数列表后放置</p>
<p>const限定和引用限定同时使用时，const限定必须在前</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">func</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符</p>
<h2 id="第14章-重载运算与类型转换">第14章 重载运算与类型转换</h2>
<h3 id="基本概念">基本概念</h3>
<p>operator+要定义的运算符号</p>
<p>重载运算符函数的参数数量和运算符作用的运算对象数量一样多</p>
<p>除了operator()之外，其他重载运算符不能含有默认实参</p>
<p>如果一个运算符函数是成员函数，第一个运算对象绑定到隐式的this指针上，所以此时参数数量=运算符作用的运算对象-1</p>
<p><strong>不能重定义内置类型的运算含义</strong></p>
<p>重载运算符作为成员还是非成员函数的选择：</p>
<p><img src="image-20230308151158091.png" /></p>
<p>对于最后一条：如果重载被定义为类成员函数，那么左侧运算对象一定是所属类的一个对象。所以如果要使运算符有对称性，不应该定义为成员函数</p>
<p>比如string s = "hi" + s;是非法的，因为operator
+被定义为string的类成员函数，该语句等价于“hi”.operator+(s);，而其类型为const
char*，根本就无法调用。</p>
<h3 id="输入和输出运算符">输入和输出运算符</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> X&amp; x);</span><br></pre></td></tr></table></figure>
<p>第一个参数是非常量ostream对象的引用：非常量-&gt;向流写入内容会改变其状态；引用-&gt;流不允许拷贝。</p>
<p>输出运算符重载时尽量减少格式化操作，专注于输出对象的内容。使用户有权控制输出细节。</p>
<hr />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is,X&amp; x);</span><br></pre></td></tr></table></figure>
<p><strong>输入运算符必须处理可能的输入失败的情况，而输出运算符不需要</strong></p>
<p>输入时可能发生下列错误：</p>
<ul>
<li>流含有错误类型的数据读取操作时（输入和被赋值变量类型不匹配）</li>
<li>读取操作到达文件末尾或者遇到输入流的其他错误</li>
</ul>
<p>输入运算符负责检测错误，同时从错误中恢复</p>
<h3 id="算术和关系运算符">算术和关系运算符</h3>
<p>一般定义为非成员函数以允许对左侧或右侧对象进行转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X <span class="keyword">operator</span>+(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> X&amp; rhs);</span><br><span class="line">X <span class="keyword">operator</span>+(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs)&#123;</span><br><span class="line">    X tmp = lhs;</span><br><span class="line">    tmp+= rhs;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>相等运算符和不等运算符在实现中应该把具体工作委托给另外一个，而其只负责调用对方实现自身的功能。</p>
<hr />
<p>对于关系运算符，如&lt;，如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑重载该运算符</p>
<p>如果类同时还包含==，则当且仅当&lt;定义和==产生的结果一致时才定义&lt;运算符</p>
<h3 id="赋值运算符">赋值运算符</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il);</span><br></pre></td></tr></table></figure>
<p>注意赋值运算符改变了左侧运算对象本身，按照之前的准则，应该定义为类成员函数，且返回左侧对象的引用。形参类型可以按照需求进行定义</p>
<p>复合赋值运算符也要返回左侧对象的引用。</p>
<h3 id="下标运算符">下标运算符</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> n);</span><br><span class="line"><span class="type">const</span> string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p>下标运算符必须是成员函数</p>
<p>如果一个类包含下标运算符，则通常会定义两个版本：一个返回<strong>普通引用</strong>，一个是<strong>类的常量成员</strong>并且返回<strong>常量引用</strong></p>
<h3 id="递增和递减运算符">递增和递减运算符</h3>
<p>建议设定为成员函数，要同时定义前置版本和后置版本</p>
<hr />
<p><strong>前置版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X&amp; <span class="keyword">operator</span>++();</span><br><span class="line">X&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>
<p><strong>后置版本</strong></p>
<p>为了区分前置盒后置版本，在后置重载的生命中增加一个额外的int形参，但该形参不会被使用。调用后置运算符时，编译器会为这个形参提供一个值为0的实参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X X::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    X tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">X <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>后置版本的实现可以调用前置版本来完成实际工作</p>
<p>因为内置的后置递增递减运算符返回的时对象运算之前的值，所以后置版本的重载返回类型设置为值类型。</p>
<h3 id="成员访问运算符">成员访问运算符</h3>
<p>箭头运算符完成的是解引用+成员访问</p>
<p>箭头运算符必须是类的成员，解引用运算符不必须是类的成员，但一般也设置为类的成员。</p>
<p>成员访问一般不会改变对象状态，所以重载函数定义为const成员，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</p>
<h3 id="函数调用运算符">函数调用运算符</h3>
<p>如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;<span class="number">0</span>?-val:val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;</span><br><span class="line"><span class="type">int</span> ui = <span class="built_in">absObj</span>(i);</span><br></pre></td></tr></table></figure>
<p><strong>如果类定义了调用运算符，则该类的对象称作函数对象</strong></p>
<p>函数对象类中的包含的其他数据数据成员可以被用于定制调用运算符中的操作（比如定义一个打印字符串类，重载operator()，数据成员中有分隔符可以使用）</p>
<p>函数对象常常作为泛型算法的实参</p>
<hr />
<h4 id="lambda是函数对象">lambda是函数对象</h4>
<p>编写一个lambda后，编译器将表达式翻译为一个未命名类的对象，该类中含有一个重载的函数调用运算符。<strong>在默认情况下，该类的函数调用运算符是一个const成员函数</strong></p>
<p>如果lambda的捕获变量为值捕获，这种类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数并初始化数据成员</p>
<p><img src="image-20230309085907880.png" /></p>
<h4 id="标准库定义的函数对象">标准库定义的函数对象</h4>
<p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，在functional头文件中</p>
<p><img src="image-20230309090211045.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">intAdd</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())</span><br></pre></td></tr></table></figure>
<p>标准库规定其函数对象对于指针也同样适用。</p>
<h4 id="可调用对象与function">可调用对象与function</h4>
<p>C++中可调用的对象：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。</p>
<p>调用形式（call
signature）指明返回类型以及传递给调用的实参类型，一种调用形式对应一个函数类型。<strong>不同类型可能具有相同的调用形式</strong></p>
<p>下面几个可调用对象共用一种调用形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int(int,int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123;<span class="keyword">return</span> i%j;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> de,<span class="type">int</span> di)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> de/di;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>function定义于functional头文件中，是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，该信息表示对象的调用形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;;</span><br></pre></td></tr></table></figure>
<p><img src="image-20230309103334548.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>重载的函数与function</strong></p>
<p>不能直接将重载函数的名字存入function类型的对象中，会产生二义性问题</p>
<p>解决方法：存储函数指针、使用lambda消除二义性</p>
<h3 id="重载类型转换与运算符">重载、类型转换与运算符</h3>
<h4 id="类型转换运算符">类型转换运算符</h4>
<p>负责将一个类类型的值转换成其他类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//一般形式，type指某种类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以面向除void之外的任意类型进行定义，只要该类型能作为函数的返回类型</li>
<li><strong>不允许转换成数组或者函数类型</strong></li>
<li>允许转换为指针或者引用类型</li>
<li><strong>没有显式的返回类型，没有形参</strong></li>
<li><strong>必须定义为类的成员函数</strong></li>
</ul>
<hr />
<p><strong>显式的类型转换运算符</strong>——explicit</p>
<p>声明为explicit之后，只能通过显式的请求进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line">si+<span class="number">3</span>;<span class="comment">//错误</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si)+<span class="number">3</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><img src="image-20230309111432646.png" /></p>
<h4 id="避免含有二义性的类型转换">避免含有二义性的类型转换</h4>
<p>如果类中包含一个或多个类型转换，必须确保在类类型和目标类型之间只存在唯一一种转换方式。</p>
<p>考虑以下情况：</p>
<p>A类中包含以B类为参数的转换构造函数，B类中存在转换成A类型的类型转换运算符。如果有以下语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B b;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">A a = <span class="built_in">f</span>(b);</span><br></pre></td></tr></table></figure>
<p>则会产生二义性，因为不知道应该使用哪种方式将B类型的b转换为A类型</p>
<p>如果确实想执行该调用，就必须显式指明调用的类型转换方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());</span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));</span><br></pre></td></tr></table></figure>
<p><strong>无法使用强制类型转换来解决二义性</strong></p>
<hr />
<p>再考虑以下情况，类中定义的一组类型转换，其转换源或转换目标类型本身可以通过其他类型转换联系在一起</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);<span class="comment">//最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//最好不要创建两个转换目标都是算术类型的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);<span class="comment">//二义性错误，f(A::operator int())或f(A::operator double())</span></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;<span class="comment">//二义性错误，f(A::A(int))或f(A::A(double))</span></span><br></pre></td></tr></table></figure>
<p><strong>根本原因是上述调用中所需要的标准类型转换级别一致</strong></p>
<hr />
<p><img src="image-20230309145325762.png" /></p>
<hr />
<p><strong>重载函数与转换构造函数</strong></p>
<p>再考虑以下情况，二义性问题会进一步加重</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> D&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>在传入实参时显式地构造类型可以消除二义性，但出现这种情况通常表示程序设计存在问题。</p>
<h4 id="函数匹配与重载运算符">函数匹配与重载运算符</h4>
<ul>
<li>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数</li>
<li>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载运算符，会产生二义性问题</li>
</ul>
<h2 id="第15章-面向对象程序设计">第15章 面向对象程序设计</h2>
<h3 id="oop概述">OOP概述</h3>
<p>核心思想：数据抽象、继承和动态绑定</p>
<p>数据抽象：将类接口和实现分离</p>
<p>继承：定义相似的类型并对其相似关系建模</p>
<p>动态绑定：一定程度上忽略相似类型的区别，以统一的方式使用其对象</p>
<hr />
<p>基类、派生类</p>
<p>基类负责定义在层次关系中所有类共有的成员。每个派生类定义各自特有的成员</p>
<p>对于某些函数，基类希望其派生类各自定义适合自身的版本，<strong>此时基类将这些函数声明为虚函数。派生类必须在其内部对所有重新定义的虚函数进行声明</strong></p>
<hr />
<p>动态绑定</p>
<p>函数的运行版本由实参决定，即在运行时选择函数的版本</p>
<p>在CPP中，当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定</p>
<h3 id="定义基类和派生类">定义基类和派生类</h3>
<p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作</p>
<hr />
<h4 id="基本知识">基本知识</h4>
<p><strong>成员函数与继承</strong></p>
<p>基类的成员函数可以被分为两种：</p>
<ul>
<li>希望派生类进行<strong>覆盖（override）</strong>的函数</li>
<li>希望派生类直接继承而不改变的函数</li>
</ul>
<p>对于前者，基类通常将其定义为虚函数。当使用指针或者引用调用虚函数时，该调用将被动态绑定。根据指针或引用所绑定的对象类型不同，调用基类的版本或者派生类的版本</p>
<p>虚函数声明：virtual关键字，<strong>只能出现在类内部的声明语句而不能用于外部的函数定义</strong></p>
<p>虚函数范围：任何<strong>构造函数之外的非静态函数</strong>都可以是虚函数</p>
<p>非虚函数的解析过程发生在编译时而非运行时</p>
<hr />
<p><strong>派生类的声明形式</strong></p>
<p>使用类派生列表明确指出从哪个类继承而来</p>
<p><strong>声明时不能包含派生列表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>;<span class="comment">//声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>派生类中的虚函数</strong></p>
<p>如果派生类没有覆盖基类中某个虚函数，则该虚函数的行为类似于其他的普通成员。<strong>派生类会直接继承其在基类中的版本</strong></p>
<p>派生类可以在覆盖的函数前使用virtual关键字，但不是必须</p>
<p>也可以在形参列表后边添加override关键字，override的次序在const后面或引用限定符&amp;、&amp;&amp;后面</p>
<hr />
<p><strong>派生类对象及派生类向基类的类型转换</strong></p>
<p>编译器隐式执行派生类到基类的转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote item;</span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote* p = &amp;item;</span><br><span class="line">p = &amp;bulk;</span><br><span class="line">Quote&amp; r = bulk;</span><br></pre></td></tr></table></figure>
<p>能够进行转换的原因是每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该部分上。所以不存在基类向派生类的自动类型转换。</p>
<p>判断基类和派生类转换是否可行看的是被转换对象静态类型，因为编译器只能检查静态类型来推断转换是否合法。dynamic_cast请求类型转换的安全检查将在运行时执行。static_cast的转换可以强制覆盖掉编译器的检查工作。使用时要确保转换是安全的。</p>
<p>注意，<strong>派生类向基类之间的自动类型转换只对指针或引用类型有效</strong>。对于对象之间的转换，其实是调用了构造函数或者赋值运算符，一个对象作为参数传入，在该过程中发生了类型转换。</p>
<hr />
<p><strong>派生类构造函数</strong></p>
<p>对于从基类中继承而来的成员，派生类必须<strong>使用基类的构造函数来初始化</strong>，即每个类控制它自己的成员初始化过程。</p>
<p><img src="image-20230310094400689.png" /></p>
<p>初始化顺序：初始化基类部分，按照声明顺序依次初始化派生类成员</p>
<hr />
<p><strong>派生类使用基类成员</strong></p>
<p>可以访问基类的公有成员和受保护成员</p>
<hr />
<p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的<strong>唯一定义</strong>。不论从基类中派生出多少派生类。</p>
<p>静态成员也遵循访问控制规则，即如果在基类中是private的，则派生类无权访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statemem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(cosnt Derived&amp; obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//以下访问都是合法的</span></span><br><span class="line">    Base::<span class="built_in">statemem</span>();</span><br><span class="line">    Derived::<span class="built_in">statemem</span>();</span><br><span class="line">    obj.<span class="built_in">statemem</span>();</span><br><span class="line">    <span class="built_in">statemem</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>被用作基类的类</strong></p>
<p>如果某个类被用作基类，则该类必须<strong>已经定义而非仅仅声明</strong></p>
<p>直接基类、间接基类</p>
<hr />
<p><strong>防止继承的发生</strong></p>
<p>C++11新标准，在类名后跟一个关键字<strong>final</strong></p>
<h4 id="类型转换与继承">类型转换与继承</h4>
<p>之前提到，可以将基类的指针（<strong>包括智能指针</strong>）或引用绑定到派生类对象上，说明<strong>当使用基类指针时，实际上所绑定对象的真实类型可能是基类类型，也可能是派生类类型</strong></p>
<p><strong>静态类型与动态类型</strong></p>
<p>静态类型：编译时已知，是在变量声明时的类型或表达式生成的类型</p>
<p>动态类型：运行时可知，是变量或表达式表示的内存中对象的类型</p>
<p><strong>如果表达式既不是指针也不是引用，则动态类型和静态类型永远一致。</strong></p>
<h3 id="虚函数">虚函数</h3>
<blockquote>
<p>总结：</p>
<p>这一节内容比较琐碎，可以大致分为三个：</p>
<ol type="1">
<li>虚函数在基类中的定义，需要virtual关键字，含义为想要子类去覆盖的函数</li>
<li>虚函数的通过指针或者引用的调用在运行时才会被解析，由此产生了本节中的默认实参或回避虚函数机制等小知识点</li>
<li>虚函数在派生类在的定义形式</li>
</ol>
<p>其中最重要的是第二点，动态绑定</p>
</blockquote>
<p><strong>虚函数的调用在运行时才被解析</strong></p>
<p>由于虚函数在运行时才能确定调用了哪个版本，所以<strong>所有虚函数都必须有定义。</strong></p>
<p><strong>动态绑定只有当通过指针或者引用调用虚函数时才会发生</strong>，如果使用普通类型的表达式调用虚函数时，编译时就会确定实际调用的版本。</p>
<hr />
<p><strong>派生类中的虚函数</strong></p>
<ul>
<li>不是必须加virtual关键字</li>
<li>如果在派生类中覆盖继承过来的虚函数，需要保持形参类型的完全一致</li>
<li>返回类型也必须匹配，除了一个例外情况：返回类型是类本身的引用或指针时</li>
</ul>
<hr />
<p><strong>final和override说明符</strong></p>
<p>override关键字说明派生类中的虚函数，好处是使得程序员的意图更加清晰（说明这个函数是虚函数的覆盖，而不是重载的新函数），并且让编译器可以发现一些错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;<span class="comment">//错误，覆盖的虚函数一定要参数匹配，被认为是一个新函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//错误，只有虚函数才能覆盖</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>final关键字作用是禁止<strong>后续</strong>任何尝试覆盖该函数的操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;<span class="comment">//后续的继承不允许覆盖f1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span> : D2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>override和final说明符出现在形参列表和尾置返回类型之后</p>
<hr />
<p><strong>虚函数与默认实参</strong></p>
<p>默认实参的判定是根据实际运行的函数版本中的默认实参来判定的。</p>
<p>如果虚函数使用默认实参，则基类与派生类中定义的默认实参最好一致。</p>
<hr />
<p><strong>回避虚函数的机制</strong></p>
<p>某些情况下，希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本</p>
<p>方法：使用作用域运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p><strong>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的机制</strong></p>
<p><img src="image-20230310152341558.png" /></p>
<h3 id="抽象基类">抽象基类</h3>
<p><strong>纯虚函数</strong></p>
<p>引入目的：</p>
<p>1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p>
<p>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>纯虚函数实际上告诉用户（程序员）当前函数是没有实际意义的，并且告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。</p>
<p>纯虚函数无须定义，在函数声明语句最后加=0即可说明该函数为纯虚函数</p>
<p>=0只能出现在<strong>类内部</strong>的虚函数声明语句处</p>
<blockquote>
<p><strong>虚函数和纯虚函数</strong></p>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了<strong>允许用基类的指针来调用子类的这个函数。</strong></p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现（虽然纯虚函数也可以被定义，但从从目的上分析就是没有实现）。</p>
<p>定义纯虚函数是为了<strong>实现一个接口，起到一个规范的作用</strong>，规范继承这个类的程序员必须实现这个函数。</p>
</blockquote>
<hr />
<p><strong>抽象基类</strong></p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类</p>
<p>抽象基类负责定义接口，后续其他类可以覆盖接口</p>
<p><strong>不能直接创建一个抽象基类的对象</strong></p>
<p>值得注意的是。<strong>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</strong></p>
<h3 id="访问控制和继承">访问控制和继承</h3>
<p><strong>protected</strong></p>
<ul>
<li>对用户而言不可访问</li>
<li>对派生类成员和友元来说可访问</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对象对基类对象中的受保护成员没有任何访问特权</li>
</ul>
<p>对于最后一条，考虑如下例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">(D&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">(B&amp;)</span></span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(D&amp; d)</span></span>&#123;d.j = d.prot_mem = <span class="number">0</span>;&#125;<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B&amp; b)</span></span>&#123;b.prot_mem = <span class="number">0</span>&#125;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<hr />
<p>继承来的成员访问权限的影响来自两方面：1.成员在基类中的访问说明符
2.在派生类的派生列表中的访问说明符</p>
<p><strong>派生访问说明符对派生类的成员和友元能否访问其直接基类的成员没什么影响</strong>，其目的是控制派生类用户（使用者和派生类的派生类）对基类成员的访问权限</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">原本访问权限</th>
<th style="text-align: center;">public继承方式</th>
<th style="text-align: center;">protected继承方式</th>
<th style="text-align: center;">private继承方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">public</td>
<td style="text-align: center;">public</td>
<td style="text-align: center;">protected</td>
<td style="text-align: center;">private</td>
</tr>
<tr class="even">
<td style="text-align: center;">protected</td>
<td style="text-align: center;">protected</td>
<td style="text-align: center;">protected</td>
<td style="text-align: center;">private</td>
</tr>
<tr class="odd">
<td style="text-align: center;">private</td>
<td style="text-align: center;">不可用</td>
<td style="text-align: center;">不可用</td>
<td style="text-align: center;">不可用</td>
</tr>
</tbody>
</table>
<p>上表中，比如原本在基类中为public成员，派生类通过private继承后，在派生类中的访问权限变为private，在非成员函数调用时或者进一步派生时变得不可访问</p>
<hr />
<p><strong>派生类向基类转换的可访问性</strong></p>
<p><img src="image-20230313185210156.png" /></p>
<hr />
<p><strong>友元与继承</strong></p>
<p>友元关系不能继承，每个类负责控制各自成员的访问权限</p>
<p>A类的友元不能访问A类派生类的private成员，<strong>但是可以访问派生类的基类部分（即派生类中基类部分由基类本身控制）</strong>；A类友元的派生类也不能访问A类的private成员。</p>
<hr />
<p><strong>改变个别成员的可访问性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">private</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本来size和n是D的私有成员，然而现在使用using语句改变了这些成员的可访问性</p>
<p><strong>派生类只能为那些它可以访问的名字提供using声明</strong></p>
<hr />
<p><strong>默认的继承保护级别</strong></p>
<p>struct默认public继承，class默认private继承</p>
<h3 id="继承中的类作用域">继承中的类作用域</h3>
<p><strong>编译时的名字查找</strong></p>
<p>即使动态类型和静态类型可能不一致，但能使用哪些成员仍然是由<strong>静态类型</strong>决定的</p>
<p><strong>继承中的名字冲突</strong></p>
<p>派生类的成员将隐藏同名的基类成员</p>
<p>可以使用作用域运算符来使用隐藏的成员</p>
<p>除了覆盖继承而来的虚函数之外，最好不要在派生类中重用其他定义在基类中的名字</p>
<p><img src="image-20230313193243811.png" /></p>
<p>从上图可知，<strong>名字查找先于类型检查</strong></p>
<p><img src="image-20230313193358593.png" /></p>
<hr />
<p><strong>虚函数与作用域</strong></p>
<p>只有基类和派生类中的虚函数有相同的形参列表，才能通过基类的指针或引用调用派生类的虚函数。</p>
<p><strong>调用非虚函数时不会发生动态绑定，实际调用的函数版本又指针的静态类型决定</strong></p>
<h3 id="构造函数与拷贝控制">构造函数与拷贝控制</h3>
<h4 id="虚析构函数">虚析构函数</h4>
<p>基类通常应该定义一个虚析构函数，这样可以动态分配继承体系中的对象</p>
<p>基类中的析构函数是虚函数，将确保delete基类指针时运行正确的析构函数版本</p>
<p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>
<h4 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h4>
<p>默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式使用基类的拷贝（或移动）构造函数</p>
<p><img src="image-20230314164638203.png" /></p>
<p>派生类的赋值运算符也必须显式地为其基类部分赋值</p>
<p><img src="image-20230314164736325.png" /></p>
<p>析构的顺序与构造的顺序相反，派生类的析构函数首先执行，然后是基类的析构函数</p>
<h4 id="继承的构造函数">继承的构造函数</h4>
<p>C++11新标准中，派生类能够重用其直接基类定义的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> B::B;<span class="comment">//重用B的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using作用域构造函数时，该语句令编译器产生代码。对基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数</p>
<p><strong>构造函数的using声明不会改变该构造函数的访问级别</strong>，比如基类的私有构造函数在派生类中还是私有</p>
<p>using声明语句也不能指定explicit或者constexpr，如果基类的构造函数是explicit或者constexpr，则继承的构造函数也有相同的属性</p>
<p>基类的构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p>
<p>派生类不会继承构造函数的情况：</p>
<ul>
<li>派生类定义的构造函数与基类构造函数有相同的参数列表</li>
<li>默认、拷贝、移动构造函数不会被继承</li>
</ul>
<h3 id="容器与继承">容器与继承</h3>
<p>当派生类对象赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容</p>
<p>当希望在容器中存放具有继承关系的对象时，实际上存放的通常是<strong>基类的指针</strong>。这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;B&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;B&gt;());</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;D&gt;());</span><br></pre></td></tr></table></figure>
<h2 id="第16章-模板与泛型编程">第16章 模板与泛型编程</h2>
<h3 id="定义模板">定义模板</h3>
<h4 id="函数模板">函数模板</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funct</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>模板定义中，模板参数列表不能为空</p>
<p>调用函数模板时，编译器通常用函数实参为我们推断模板实参</p>
<p>编译器用推断出的模板参数实例化一个特定版本的函数</p>
<p><strong>模板中可以定义非类型参数</strong>，一个非类型参数表示一个值而非一个类型，通过<strong>类型名</strong>而非class或typename指定非类型参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N,<span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非类型模板参数实参必须是常量表达式</strong></p>
<p>inline和constexpr说明符要放在参数列表之后，返回类型之前</p>
<p>模板程序应该尽量减少对实参类型的要求</p>
<p>编译器遇到模板定义时，并不生成代码，只有当我们实例化出模板的一个特定版本时才会生成代码。</p>
<p>函数模板和类模板成员函数的定义通常放在头文件中，因为编译器生成一个实例化版本要掌握其定义</p>
<hr />
<h4 id="类模板">类模板</h4>
<p>与函数模板的区别在于，编译器不能为类模板推断模板参数类型，必须在模板名后的尖括号中提供额外信息</p>
<p>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化</p>
<p>在类模板的作用域内，我们可以直接使用模板名而不必指定模板实参</p>
<p>模板类型别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T,<span class="type">unsigned</span>&gt;</span><br></pre></td></tr></table></figure>
<p>类模板中的static成员：不能把静态成员的定义放在类中，但是可以在类的外部通过使用范围解析运算符
:: 来定义静态变量从而对它进行初始化。</p>
<p>相同类型如int对应的类模板的对象之间的static成员是共享的，不同类型之间如int,float,char对应的类模板的对象之间的static是不共享的。</p>
<hr />
<h4 id="模板参数">模板参数</h4>
<p>声明中的模板参数与定义中的模板参数不必相同。</p>
<p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>
<p>对于模板代码而言，假定T是模板类型参数，当遇到T::mem这样的代码时，编译器不知道mem是一个类型名还是一个static数据成员的名字，直至实例化时才会知道。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T::size_type * p;</span><br></pre></td></tr></table></figure>
<p>编译器不知道是size_type数据成员与p相乘还是定义一个size_type类型的p</p>
<p>默认情况下，C++假定通过作用域运算符访问的是名字而非类型。</p>
<p>所以，如果想使用一个类型时，必须显式的告诉编译器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11开始，可以为函数和类模板提供默认实参。无论何时使用类模板，模板名之后都要接尖括号，尖括号指明类必须从一个模板实例化而来。</p>
<p>如果希望使用提供的默认实参，<strong>就在模板名之后跟一个空的尖括号对</strong></p>
<hr />
<h4 id="成员模板">成员模板</h4>
<p>类中包含的本身是模板的成员函数，这种成员被称为成员模板。<strong>成员模板不能是虚函数</strong></p>
<hr />
<h4 id="控制实例化">控制实例化</h4>
<p><img src="image-20230316105433811.png" /></p>
<h3 id="模板实参推断">模板实参推断</h3>
<h4 id="类型转换与模板类型参数">类型转换与模板类型参数</h4>
<p>对函数模板传递的实参，通常不进行类型转换，而是生成一个新的模板实例，只有有限的几种类型转换会自动应用于实参：</p>
<ul>
<li><strong>顶层const</strong>无论在形参还是实参中都会被忽略。</li>
<li>非const对象的引用或指针传递给const的引用或指针形参。</li>
<li><strong>形参不是引用类型</strong>，则可以对数组或函数类型的实参应用指针转换，数组实参转换为指向其首元素的指针；函数实参转换为一个该函数类型的指针。</li>
</ul>
<p>如果不是模板参数，则可以对实参进行正常的类型转换</p>
<h4 id="函数模板显式实参">函数模板显式实参</h4>
<h3 id="重载与模板">重载与模板</h3>
<h3 id="可变参数模板">可变参数模板</h3>
<h3 id="模板特例化">模板特例化</h3>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》笔记（8-12章）</title>
    <url>/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%888-12%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p>《C++ Primer》 8-12章笔记</p>
<span id="more"></span>
<h2 id="第八章">第八章</h2>
<h3 id="io类">IO类</h3>
<p>IO对象无拷贝或赋值，进行IO操作的函数通常以引用方式传递和返回流</p>
<p>读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的</p>
<p>流的状态（iostate类型的constexpr值）：</p>
<ul>
<li><p>badbit置位，系统级错误，不可恢复</p></li>
<li><p>failbit置位，通常可修正，流可以继续使用</p></li>
<li><p>eofbit，文件结束位置，文件结束时failbit也会置位</p></li>
<li><p>goodbit，值为0表示流未发生错误，前三个任一个被置位则错误</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> oldState = cin.<span class="built_in">rdstate</span>();<span class="comment">//rdstate返回流当前状态</span></span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">process_input</span>(cin);</span><br><span class="line">cin.<span class="built_in">setstate</span>(oldState);<span class="comment">//cin置为原有状态</span></span><br></pre></td></tr></table></figure>
<h4 id="管理输出缓冲">管理输出缓冲</h4>
<p>每个输出流都管理一个缓冲区，刷新缓冲的原因有：</p>
<ul>
<li>程序正常结束，作为main函数return操作的一部分，缓冲区刷新</li>
<li>缓冲区满</li>
<li>endl操纵符显式刷新（另，flush刷新缓冲区但不输出额外字符，ends插入一个空字符然后刷新缓冲区）</li>
<li>每个输出操作后用操作符unitbuf设置流的内部状态，清空缓冲区。<strong>cerr默认是设置unitbuf的</strong></li>
<li>一个输出流被关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;unitbuf;</span><br><span class="line">cout&lt;&lt;nounitbuf;</span><br></pre></td></tr></table></figure>
<p><strong>如果程序崩溃，输出缓冲区不会被刷新</strong></p>
<h4 id="关联输入和输出流">关联输入和输出流</h4>
<p><strong>交互式系统，所有输出都会在读操作之前被打印</strong></p>
<p>每个流最多同时关联到一个流，但多个流可以同时关联到一个ostream</p>
<h3 id="文件输入输出">文件输入输出</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(inFile)</span></span>;<span class="comment">//C++11中inFile可以是库类型string对象，也可以是C风格字符数组</span></span><br><span class="line">ofstream out;</span><br></pre></td></tr></table></figure>
<p>一旦一个文件流被打开，就保持与对应文件的关联；为了关联另外一个文件，首先必须关闭close()已经关联的文件</p>
<p>fstream对象被销毁时，close会自动被调用</p>
<h4 id="文件模式">文件模式</h4>
<p>app是每次写操作前定位到文件末尾；ate是打开文件后立刻定位到文件末尾</p>
<p>trunc是截断文件（打开文件时清空已打开的文件流）</p>
<p>out模式默认是trunc模式</p>
<h3 id="string流">string流</h3>
<p>sstream.str()返回string流所保存的string的拷贝</p>
<p>sstream.str(s)将s拷贝到string流中，返回void</p>
<h2 id="第九章">第九章</h2>
<h3 id="顺序容器概述">顺序容器概述</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 50%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">容器</th>
<th style="text-align: center;">访问方式</th>
<th style="text-align: center;">操作特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">vector</td>
<td style="text-align: center;">快速随机访问（因为内存中连续存储）</td>
<td style="text-align: center;">尾部插入删除元素快</td>
</tr>
<tr class="even">
<td style="text-align: center;">deque</td>
<td style="text-align: center;">快速随机访问</td>
<td style="text-align: center;">头尾插入删除元素快</td>
</tr>
<tr class="odd">
<td style="text-align: center;">list</td>
<td
style="text-align: center;">只能双向顺序访问（额外内存开销较大）</td>
<td style="text-align: center;">在任何位置插入删除都很快</td>
</tr>
<tr class="even">
<td style="text-align: center;">forward_list</td>
<td
style="text-align: center;">只能单向顺序访问（额外内存开销较大）</td>
<td style="text-align: center;">在任何位置插入删除都很快</td>
</tr>
<tr class="odd">
<td style="text-align: center;">array</td>
<td style="text-align: center;">快速随机访问</td>
<td style="text-align: center;">不能添加删除元素</td>
</tr>
<tr class="even">
<td style="text-align: center;">string</td>
<td style="text-align: center;">快速随机访问（因为内存中连续存储）</td>
<td style="text-align: center;">尾部插入删除元素快</td>
</tr>
</tbody>
</table>
<p>forward_list和array是C++新标准增加的类型</p>
<p>array与内置数组比更安全更易用，其大小固定。</p>
<p>forward_list没有size操作，因为保存或计算其大小会多出额外开销</p>
<p><strong>选择容器的一些基本原则：</strong></p>
<ul>
<li>没有很好的理由就用vector</li>
<li>程序有很多小元素且空间额外开销很重要，ban掉list和forward_list</li>
<li>要在容器中间插入删除，用list或forward_list</li>
<li>仅在头尾操作，deque</li>
<li>只需要在读取输入时在中间插入，读取完后随机访问：考虑在输入阶段用list，完成后拷贝到vector中</li>
</ul>
<h3 id="容器库概览">容器库概览</h3>
<h4 id="迭代器">迭代器</h4>
<p>forward_list不支持迭代器的--运算符</p>
<p>开头带r的反向迭代器</p>
<h4 id="容器定义和初始化">容器定义和初始化</h4>
<p>只有顺序容器（不包括array）的构造函数才能接受大小参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n,t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个容器为另一个容器的拷贝时，两个容器的类型和元素类型必须匹配。但<strong>通过传递迭代器参数拷贝一个范围时，就不要求容器类型和元素类型是相同的了，只要能将拷贝的元素转换到所需类型即可</strong></p>
<h4 id="array具有固定大小">array具有固定大小</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,42&gt; a;</span><br></pre></td></tr></table></figure>
<p>一个默认构造的array是非空的，包含与其大小一样多个元素，且元素均被默认初始化。</p>
<p><strong>内置数组不能拷贝或为另一数组赋值，但array没有此限制</strong></p>
<h4 id="赋值和swap">赋值和swap</h4>
<p>array不允许用花括号列表进行赋值（可以用于初始化），也不支持assign</p>
<p>赋值运算符要求左右运算对象具有相同的类型</p>
<p>顺序容器还定义一个名为assign的成员，<strong>允许从一个不同但相容的类型赋值，或者从容器的一个子序列赋值</strong></p>
<p>除array外，<strong>swap操作中元素本身并未交换，无任何拷贝删除插入操作，只是交换两个容器的内部数据结构，保证常数时间内完成</strong></p>
<p>对string调用swap会导致迭代器、引用、指针失效，<strong>其他容器不会</strong></p>
<p>array完成swap操作后，原有的迭代器等绑定的元素不变，变得是元素值</p>
<p>其他顺序容器swap后，迭代器等指向仍然指向之前的元素，但是元素本身所属的容器已经发生了变化</p>
<h3 id="顺序容器操作">顺序容器操作</h3>
<h4 id="添加元素">添加元素</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(p,t);c.<span class="built_in">emplace</span>(p,args)<span class="comment">//在迭代器p指向的元素之前创建值为t或由args创建的元素，返回指向新添加的元素的迭代器</span></span><br><span class="line">c.<span class="built_in">insert</span>(p,n,t);<span class="comment">//在p指向元素之前插入n个t，返回指向添加的第一个元素的迭代器</span></span><br><span class="line">c.<span class="built_in">insert</span>(p,b,e);<span class="comment">//将迭代器b和e指定范围内的元素添加到p之前，迭代器不能指向c中的元素,左闭右开区间b-e</span></span><br><span class="line">c.<span class="built_in">insert</span>(p,il);<span class="comment">//将一个元素值列表il插入到p之前</span></span><br></pre></td></tr></table></figure>
<p>*<strong>forward_list有自己专有版本的insert和emplace</strong></p>
<p>*<strong>forward_list不支持push_back和emplace_back</strong></p>
<p>*<strong>vector和string不支持push_front和emplace_front</strong></p>
<p><strong>向vector或string或deque插入元素会使所有指向容器的迭代器引用指针都会失效</strong></p>
<p>emplace构造而非拷贝元素（CPP11）,传入emplace的参数必须与元素类型的构造函数参数匹配</p>
<h4 id="访问元素">访问元素</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">at</span>(n)<span class="comment">//返回下标为n的元素的引用</span></span><br></pre></td></tr></table></figure>
<p><strong>front back at</strong>返回的都是引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>() = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; v = c.<span class="built_in">back</span>();<span class="comment">//v是引用</span></span><br><span class="line">v = <span class="number">1024</span>;<span class="comment">//如果c不是常量容器，可以改变c中元素</span></span><br><span class="line"><span class="keyword">auto</span> v2 = c.<span class="built_in">back</span>();<span class="comment">//v2不是引用，是c.back()的拷贝</span></span><br><span class="line">v2 = <span class="number">0</span>;<span class="comment">//并未改变c中元素</span></span><br></pre></td></tr></table></figure>
<p><strong>forward_list不使用back</strong></p>
<p><strong>at只适用于string array deque vector</strong></p>
<h4 id="删除元素">删除元素</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line">c.<span class="built_in">erase</span>(p);<span class="comment">//删除p所指元素，返回指向被删元素之后元素的迭代器</span></span><br><span class="line">c.<span class="built_in">erase</span>(b,e);<span class="comment">//删除b和e所指定范围内的元素,左闭右开区间b-e</span></span><br><span class="line">c.<span class="built_in">clear</span>();<span class="comment">//删除c中所有元素</span></span><br></pre></td></tr></table></figure>
<p>*<strong>forward_list有自己专有版本的erase</strong></p>
<p>*<strong>forward_list不支持pop_back</strong></p>
<p>*<strong>vector和string不支持pop_front</strong></p>
<p><strong>删除deque中除首尾位置之外的元素会使所有迭代器引用指针失效。指向vector或string删除点之后位置的迭代器引用指针都会失效</strong></p>
<p>erase会保留原有的空间，但是容器的size参数会变化</p>
<h4 id="forward_list中的特殊操作">forward_list中的特殊操作</h4>
<p>因为单向链表无法访问一个元素的前驱，所以在单向链表中添加或删除元素是操作<strong>给定元素之后的元素</strong>完成的</p>
<p><img src="image-20230412103039799.png" /></p>
<h4 id="改变容器大小">改变容器大小</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">resize</span>(size);</span><br><span class="line">c.<span class="built_in">resize</span>(size,newinit);</span><br></pre></td></tr></table></figure>
<p><strong>resize缩小容器时，指向被删除元素的迭代器引用和指针都会失效；对vector/string/deque进行resize可能导致迭代器、指针、引用失效</strong></p>
<h4 id="容器操作可能导致迭代器失效">容器操作可能导致迭代器失效</h4>
<p><img src="image-20230412103049700.png" /></p>
<h3 id="vector对象是如何增长的">vector对象是如何增长的</h3>
<p>vector元素连续存储</p>
<p>导致，添加元素时：若没有空间容纳新元素，容器必须分配新的内存空间将已有元素移动过去再添加新元素，释放旧空间</p>
<p>标准库实现中：当不得不获取新的内存空间时，vector和string的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器大小管理操作</span></span><br><span class="line">c.<span class="built_in">capacity</span>();<span class="comment">//c可以保存的元素数，只适用于vector string</span></span><br><span class="line">c.<span class="built_in">reserve</span>(m);<span class="comment">//分配至少能容纳m个元素的内存空间，只适用于vector string</span></span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>()<span class="comment">//将capacity减少为和size相同大小，只适用于vector string deque</span></span><br></pre></td></tr></table></figure>
<p><strong>需求大小小于当前容量时，reserve不会回收内存空间，而是什么也不做</strong></p>
<p><strong>resize不会改变容器的容量</strong></p>
<p><strong>shrink_to_fit是CPP11的新操作，但具体实现可以忽略其请求，也即调用该函数也不保证一定会退回内存空间</strong></p>
<h3 id="额外的string操作">额外的string操作</h3>
<p><img src="image-20230412103102881.png" /></p>
<p>确实。</p>
<h3 id="容器适配器">容器适配器</h3>
<p>适配器是标准库中的通用概念。容器、迭代器、函数都有适配器</p>
<p>stack queue priority_queue</p>
<p>没有提供与元素保存相关的数据结构实现，通过调用底层的基础容器来实现其功能</p>
<p><img src="image-20230412103128233.png" /></p>
<blockquote>
<p>C++中的容器适配器是干什么的呢？我们已有容器（比如vector、list、deque），他们支持的的操作很多，比如插入，删除，迭代器访问等等。而我们希望这个容器表现出来的是栈的样子：先进后出，入栈出栈等等，此时，我们没有必要重新动手写一个新的数据结构，而是把原来的容器重新封装一下，改变它的接口，就能把它当做栈使用了。
原文链接：https://blog.csdn.net/qq_21989927/article/details/109392756</p>
</blockquote>
<h2 id="第十章">第十章</h2>
<h3 id="概述">概述</h3>
<p>大多数定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法</p>
<p>一般情况下，泛型算法不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作</p>
<p>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作（比如find的==完成给定值和每个元素的比较）</p>
<p><strong>算法永远不会执行容器的操作，只会运行于迭代器之上，执行迭代器的操作</strong></p>
<h3 id="初识泛型算法">初识泛型算法</h3>
<h4 id="只读算法">只读算法</h4>
<p><strong>accumulate</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>accumulate定义在头文件numeric中，第三个参数是和的初值。<strong>第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型</strong></p>
<p>只读算法最好使用cbegin和cend，但是如果要使用返回的迭代器改变元素的值，则需要使用非常量版本</p>
<p><strong>equal</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">equal</span>(roster1.<span class="built_in">cbegin</span>(),roster1.<span class="built_in">cend</span>(),roster2.<span class="built_in">cbegin</span>());</span><br></pre></td></tr></table></figure>
<p>确定两个序列是否保存相同的值，<strong>roster1和roster2</strong>的容器类型和元素类型都不必相同，只要能用==比较即可</p>
<p><strong>equal假设第二个序列至少与第一个序列一样长</strong></p>
<h4 id="写容器元素的算法">写容器元素的算法</h4>
<p><strong>注意序列原大小至少不小于要求算法写入的元素数目</strong></p>
<p><strong>fill</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>);<span class="comment">//从参数1开始指定参数2个元素赋值参数3</span></span><br></pre></td></tr></table></figure>
<p><strong>back_inserter</strong></p>
<p>定义在头文件iterator中</p>
<p>一种保证算法有足够元素空间容纳输出数据的方法是使用插入迭代器</p>
<p>通过back_inserter赋值时，与赋值号右侧相等的元素被添加到容器中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;<span class="comment">//empty</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);</span><br><span class="line">*it = <span class="number">42</span>;<span class="comment">//vec = &#123;42&#125;, call push_back to add 42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="拷贝算法">拷贝算法</h4>
<p><strong>copy</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">sizeof</span>(a1)/<span class="built_in">sizeof</span>(*a1)];</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1),<span class="built_in">end</span>(a1),a2);</span><br></pre></td></tr></table></figure>
<p>前两个参数表示一个输入范围，第三个参数表示目的序列起始位置</p>
<p><strong>目的序列至少要包含与输入序列同样多的元素</strong></p>
<p>copy返回目的位置递增后的迭代器的值，上例中返回a2尾元素之后的位置</p>
<p><strong>replace</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">replace</span>(il.<span class="built_in">begin</span>(),il.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);</span><br><span class="line"><span class="built_in">replace_copy</span>(il.<span class="built_in">cbegin</span>(),il.<span class="built_in">cend</span>(),<span class="built_in">back_inserter</span>(ivec),<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//保留原序列不变，第三个参数指出调整后序列的保存位置</span></span><br></pre></td></tr></table></figure>
<h5 id="attention"><strong>Attention:</strong></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),<span class="number">10</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这段程序是错误的，因为泛型算法对容器的要求是有足够的元素，而非足够的空间，即便使用了reserve，vec仍然为空，而fill_n在不适用back_inserter的情况下没有插入新元素的能力</p>
<h4 id="重排容器的算法">重排容器的算法</h4>
<p>sort排序</p>
<p>unique重排输入序列，将相邻重复项消除，并返回一个指向不重复值范围末尾的迭代器（不是真的删除元素，而是覆盖相邻的重复元素）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; vec&#123; <span class="string">&quot;adsad&quot;</span>,<span class="string">&quot;vsf&quot;</span>,<span class="string">&quot;dsad&quot;</span>,<span class="string">&quot;dsad&quot;</span>,<span class="string">&quot;quie&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">vec.<span class="built_in">erase</span>(ret, vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="image-20230412103146767.png" /></p>
<h3 id="定制操作">定制操作</h3>
<h4 id="向算法传递函数">向算法传递函数</h4>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为一元谓词（接受一个参数）和二元谓词。接受谓词参数的算法对输入序列中的元素调用谓词。</p>
<h4 id="lambda表达式cpp11">lambda表达式（CPP11）</h4>
<p>一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数，其形式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list](parameters list)-&gt;<span class="keyword">return</span> type &#123;function body&#125;</span><br></pre></td></tr></table></figure>
<p>捕获列表和函数体必须被包含，参数列表和返回类型可以忽略</p>
<p>lambda的调用方式也使用调用运算符</p>
<p><strong>lambda不能有默认参数</strong></p>
<p>lambda表达式只能使用明确指明的变量，将需要使用到局部变量包含在其捕获列表中使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">for_each(begin,end,function)</span><br></pre></td></tr></table></figure>
<p>对迭代器[begin,end)范围内的元素执行function操作</p>
<h4 id="lambda捕获和返回">lambda捕获和返回</h4>
<p>定义lambda时，编译器生成一个与lambda对应的新的未命名类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象，向函数传递的参数就是该对象，lambda所捕获的变量都有对应的类数据成员，在lambda对象创建时被初始化。</p>
<h5 id="值捕获引用捕获">值捕获、引用捕获</h5>
<p>值捕获的前提是变量可拷贝，被捕获变量的值在lambda创建时被拷贝</p>
<p>引用捕获的变量与其他任何类型的引用的行为相似。<strong>要保证被引用的对象在lambda执行时是存在的</strong></p>
<p><strong>尽量保持lambda的变量捕获简单化</strong></p>
<h5 id="隐式捕获">隐式捕获</h5>
<p>让编译器根据lambda体中的代码自动推断使用哪些变量</p>
<p>捕获列表中&amp;告诉编译器采用引用捕获方式；=表示采用值捕获方式</p>
<p>混合使用隐式捕获和显式捕获</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[&amp;,c](<span class="type">const</span> string&amp; s)&#123;&#125;);</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=,&amp;os](<span class="type">const</span> string&amp; s)&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>需要为一个lambda定义返回类型时，必须使用尾置返回类型</p>
<h4 id="参数绑定">参数绑定</h4>
<p>可以将bind看作一个通用的函数适配器，接受一个可调用对象，生成新的可调用对象适应原对象的参数列表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable,args_list);</span><br></pre></td></tr></table></figure>
<p>args_list为参数列表，其中可能包含_1,_2等占位符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s,string::size_type sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size,_1,<span class="number">6</span>);</span><br><span class="line">string s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s);</span><br><span class="line"><span class="keyword">auto</span> findif_ret = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(check_size,std::placeholders::_1,sz));</span><br></pre></td></tr></table></figure>
<p>_1,_2等占位符定义在名为placeholders的命名空间中</p>
<p>auto check6 =
bind(check_size,_1,6);指用check6调用时的第一个参数作为check_size的第一个参数，6作为check_size的第二个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f,a,b,_2,c,_1);</span><br><span class="line"><span class="built_in">g</span>(X,Y);</span><br><span class="line"><span class="built_in">f</span>(a,b,Y,c,X);</span><br></pre></td></tr></table></figure>
<p>传给g的参数按照位置绑定至占位符，实际上调用的是f(a,b,Y,c,X);</p>
<p>绑定引用参数使用ref()或者cref()，二者返回一个对象包含给定参数的引用，该对象是可拷贝的。</p>
<p>因为bind函数中不是占位符的参数会通过<strong>拷贝</strong>传递给bind返回的可调用对象中，而有时被绑定的参数类型无法拷贝，或者希望以引用方式传递</p>
<h3 id="再探迭代器">再探迭代器</h3>
<h4 id="插入迭代器">插入迭代器</h4>
<p>是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素</p>
<p>back_inserter front_inserter
inserter(只有在支持front或back相关操作时才能使用)</p>
<p>inserter(c,iter)会将元素插入到c中iter指向的元素之前的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">inserter</span>(c,iter);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">it = c.<span class="built_in">insert</span>(it,val);</span><br><span class="line">++it;</span><br></pre></td></tr></table></figure>
<h4 id="iostream迭代器">iostream迭代器</h4>
<p>istream_iterator
ostream_iterator。将对应的流当作一个特定类型的元素序列来处理。使用流迭代器，可以用泛型算法从流对象读取数据或向流对象写入数据</p>
<p><strong>创建流迭代器时，必须指定迭代器将要读写的对象类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>;<span class="comment">//从cin读取int</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;aflie&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_it</span><span class="params">(in)</span></span>;<span class="comment">//从文件读取字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//流迭代器构造vector</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it_iter</span><span class="params">(cin)</span>,eof</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(it_iter,eof)</span></span>;</span><br><span class="line"><span class="comment">//使用算法操作流迭代器</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it_iter</span><span class="params">(cin)</span>,eof</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">accumulate</span>(it_iter,eof)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout,<span class="string">&quot; &quot;</span>)</span></span>;<span class="comment">//第二个参数为每个值后输出一个空格，该参数必须是字符串字面常量或指向空字符结尾的字符数组的指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e :vec)&#123;</span><br><span class="line">    *out_iter++ = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过copy打印</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),out_iter);</span><br></pre></td></tr></table></figure>
<h4 id="反向迭代器">反向迭代器</h4>
<p>除了forward_list，其他容器都支持反向迭代器</p>
<p>反向迭代器的base()函数，返回其对应的普通迭代器</p>
<p><img src="image-20230412103209477.png" /></p>
<p>普通迭代器和反向迭代器的关系反映了左闭合区间的特性，关键在于<span
class="math inline">\([line.crbegin(),rcomma)\)</span>和<span
class="math inline">\([rcomma.base(),line.cend())\)</span>元素范围相同</p>
<h3 id="泛型算法结构">泛型算法结构</h3>
<p>对算法分类：算法需求的迭代器；算法是否读、写或重排序列、参数传递</p>
<h4 id="类迭代器">5类迭代器</h4>
<p>算法所要求的迭代器操作可以分为五类：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">迭代器类型</th>
<th style="text-align: center;">支持的操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">输入迭代器</td>
<td style="text-align: center;">只读 不写 单遍扫描 只能递增</td>
</tr>
<tr class="even">
<td style="text-align: center;">输出迭代器</td>
<td style="text-align: center;">只写 不读 单遍扫描 只能递增</td>
</tr>
<tr class="odd">
<td style="text-align: center;">前向迭代器</td>
<td style="text-align: center;">读写 多遍扫描 只能递增</td>
</tr>
<tr class="even">
<td style="text-align: center;">双向迭代器</td>
<td style="text-align: center;">读写 多遍扫描 递增递减</td>
</tr>
<tr class="odd">
<td style="text-align: center;">随机访问迭代器</td>
<td style="text-align: center;">读写 多遍扫描 支持全部迭代器运算</td>
</tr>
</tbody>
</table>
<p><strong>向算法传递正确类型的迭代器</strong></p>
<p><img
src="https://camo.githubusercontent.com/0c1fb0929b2bdb32700f32ff61d0975359134b6c2c5a8997aafee80463c7ba36/68747470733a2f2f63732d6f666665722d313235313733363636342e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f432b2b5f53544c5f4974657261746f725f312e706e67" /></p>
<p>多个istream_iterator输入迭代器的问题：istream_iterator的++是调用read()（*stream&gt;&gt;value）读取流中的一个值，所以对一个迭代器++会导致另一个迭代器下次++时读取不到想要的值。因此只能用于单遍扫描的算法</p>
<h4 id="算法形参模式">算法形参模式</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alg</span>(beg,end,others);</span><br><span class="line"><span class="built_in">alg</span>(beg,end,dest,others);</span><br><span class="line"><span class="built_in">alg</span>(beg,end,beg2,others);</span><br><span class="line"><span class="built_in">alg</span>(beg,end,beg2,end2,others);</span><br></pre></td></tr></table></figure>
<h4 id="算法命名规范">算法命名规范</h4>
<p>算法命名规范处理诸如：如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题</p>
<ul>
<li>使用重载形式传递谓词，代替&lt;或==,如sort/unique</li>
<li>_if版本接受谓词代替元素值，如find_if</li>
<li>_copy拷贝版本将算法结果写入指定输出位置</li>
</ul>
<h3 id="特定容器算法">特定容器算法</h3>
<p>list和forward_list定义了若干个成员函数形式的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lst.<span class="built_in">merge</span>(lst2);<span class="comment">//将来自lst2的元素合并入lst，二者都必须是有序的，默认用&lt;运算符</span></span><br><span class="line">lst.<span class="built_in">merge</span>(lst2,comp);<span class="comment">//合并，但使用给定的比较操作</span></span><br><span class="line"><span class="comment">//以上二者合并之后lst2都变为空</span></span><br><span class="line">lst.<span class="built_in">remove</span>(val);<span class="comment">//调用erase删除与给定值相等的每个元素</span></span><br><span class="line">lst.<span class="built_in">remove_if</span>(pred);<span class="comment">//调用erase删除令谓词为真的每个元素</span></span><br><span class="line">lst.<span class="built_in">reverse</span>();<span class="comment">//反转lst中元素</span></span><br><span class="line">lst.<span class="built_in">sort</span>();</span><br><span class="line">lst.<span class="built_in">sort</span>(comp);</span><br><span class="line">lst.<span class="built_in">unique</span>();</span><br><span class="line">lst.<span class="built_in">unique</span>(pred);</span><br></pre></td></tr></table></figure>
<h2 id="第11章-关联容器">第11章 关联容器</h2>
<p>关联容器支持高效的关键字查找和访问</p>
<p>8个关联容器，无序/有序 set/map 可重复/不重复</p>
<h3 id="关联容器概述">关联容器概述</h3>
<p>关联容器不支持顺序容器位置相关的操作，如push_front push_back等</p>
<p>关联容器的迭代器都是双向的</p>
<p>初始化map时，必须提供关键字类型和值类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,string&gt; authors = &#123;&#123;<span class="string">&quot;Hoy&quot;</span>,<span class="string">&quot;James&quot;</span>&#125;,&#123;<span class="string">&quot;Austin&quot;</span>,<span class="string">&quot;Jane&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>允许关键字相同时，使用multimap或者multiset</strong></p>
<p>有序容器中，关键字类型必须定义元素比较的方法。可以定义自己的操作来代替关键字上的&lt;运算符，该操作必须在关键字类型上定义一个严格弱序（小于等于）</p>
<p><strong>为了使用自己定义的操作，在定义multiset时必须提供关键字类型和比较操作类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_date &amp;lhs,<span class="type">const</span> Sales_date&amp; rhs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">sibn</span>()&lt;rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">mulitset&lt;Sales_data,<span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用decltype获得一个函数指针类型时，必须加上一个*指出我们要使用一个给定函数类型的指针。</p>
<h4 id="pair类型">pair类型</h4>
<p>包含于utility头文件</p>
<p><strong>map的每个元素就是一个pair对象</strong></p>
<p>两个成员是public的，分别命名为first和second</p>
<h3 id="关联容器操作">关联容器操作</h3>
<p>key_type指的是容器的关键字类型</p>
<p>mapped_type为每个关键字关联的类型（就是键值对中值的类型）,只有map系列容器有该类型</p>
<p>value_type是容器中元素的类型，map为pair</p>
<h4 id="关联容器迭代器">关联容器迭代器</h4>
<p>set类型虽然同时定义了iterator和const_iterator，但两种类型都只能读访问set中的元素。</p>
<h4 id="添加元素-1">添加元素</h4>
<p>向map中insert元素时，元素类型必须是pair</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">word_count.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>c.insert(v)插入单一元素返回值为pair，first给出指向具有给定关键字元素的迭代器；second给出bool值，指出元素是插入成功还是已经存在容器中。</p>
<p>c.insert(b,e)/c.insert(il)插入若干个元素，返回值为void</p>
<p>c.insert(p,v)从p指定位置开始搜索新元素应该存储的位置，返回值为一个迭代器</p>
<h4 id="删除元素-1">删除元素</h4>
<p>可以传递给erase一个关键字或者一个迭代器或者一个范围</p>
<h4 id="map下标操作">map下标操作</h4>
<p>set类型不支持下标</p>
<p>只能对非const的map使用下标操作，因为下标运算符有可能插入一个新元素</p>
<p>加入对一个空map进行下标操作mp["a"]=1;</p>
<ul>
<li>在mp中搜索a关键字的元素，未找到</li>
<li>将一个新的键值对插入到mp中</li>
<li>取出新插入的元素，赋值1</li>
</ul>
<h4 id="访问元素-1">访问元素</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">lower_bound</span>(k);<span class="comment">//有序容器操作，指向第一个关键字不小于k的元素</span></span><br><span class="line">c.<span class="built_in">upper_bound</span>(k);<span class="comment">//有序容器操作，指向第一个关键字大于k的元素</span></span><br><span class="line">c.<span class="built_in">equal_range</span>(k);<span class="comment">//返回一个pair，表示关键字等于k的范围</span></span><br></pre></td></tr></table></figure>
<h3 id="无序容器">无序容器</h3>
<p>C++11新定义</p>
<p>不使用比较运算符组织元素，而是使用哈希函数和关键字类型的==运算符</p>
<p><strong>不能直接定义关键字类型为自定义类类型的无序容器</strong>，需要提供函数代替==运算符和哈希值计算函数</p>
<h2 id="第12章-动态内存">第12章 动态内存</h2>
<p>全局对象在程序启动时分配，程序结束时销毁</p>
<p>局部自动对象在进入其定义所在的程序块时被创建，离开块时被销毁</p>
<p>局部static对象在第一次使用前分配，程序结束时销毁</p>
<p><strong>动态分配的对象生存期与在哪里创建无关，只有显式被释放时才会销毁对象</strong></p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">静态内存</td>
<td
style="text-align: center;">保存局部static对象、类static数据成员、定义在任何函数之外的变量</td>
</tr>
<tr class="even">
<td style="text-align: center;">栈内存</td>
<td style="text-align: center;">定义在函数内的非static对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">自由空间（堆）</td>
<td style="text-align: center;">存储程序运行时动态分配的对象</td>
</tr>
</tbody>
</table>
<h3 id="动态内存和智能指针">动态内存和智能指针</h3>
<p>new和delete进行动态内存的管理：new在动态内存中为对象分配空间并返回一个指向该对象的指针；delete接受一个动态对象的指针，销毁对象，释放与之关联的内存</p>
<p>为了<strong>更容易且更安全</strong>地使用动态内存，新标准库在<strong>memory头文件</strong>中提供了两种<strong>智能指针</strong>，与普通指针的区别是它负责自动释放所指对象</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">share_ptr</td>
<td style="text-align: center;">允许多个指针指向同一个对象</td>
</tr>
<tr class="even">
<td style="text-align: center;">unique_ptr</td>
<td style="text-align: center;">独占所指向的对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">weak_ptr</td>
<td
style="text-align: center;">一种弱引用，指向shared_ptr所管理的对象</td>
</tr>
</tbody>
</table>
<p>均支持的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p.<span class="built_in">get</span>();<span class="comment">//返回p中所保存的指针</span></span><br><span class="line">p.<span class="built_in">swap</span>(q);</span><br><span class="line"><span class="built_in">swap</span>(p,q);<span class="comment">//交换p,q中的指针</span></span><br></pre></td></tr></table></figure>
<h4 id="shared_ptr">shared_ptr</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;</span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;</span><br></pre></td></tr></table></figure>
<p>默认初始化的智能指针中保存着一个空指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_shared</span>&lt;T&gt;(args);<span class="comment">//返回一个shared_ptr，指向动态分配的类型为T的用args初始化的对象</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q)</span></span>;<span class="comment">//拷贝，会递增q中的计数器</span></span><br><span class="line">p.<span class="built_in">use_count</span>();<span class="comment">//返回与p共享对象的智能指针数量，可能很慢，主要用于调试</span></span><br><span class="line">p.<span class="built_in">unique</span>();<span class="comment">// return true if p.use_count()==1;</span></span><br></pre></td></tr></table></figure>
<p>可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>。shared_ptr作为参数传递给函数以及作为函数的返回值时，所关联的计数器都会+1。<strong>shared_ptr赋值时会递增右侧指针的计数器，递减左侧指针的引用计数</strong></p>
<p><strong>一旦计数器变为0，就会自动释放自己所关管理的对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q;<span class="comment">//给r赋值令其指向另一个地址</span></span><br><span class="line">	<span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line">	<span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line">	<span class="comment">//r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20160713165319815" /></p>
<p>程序使用动态内存的原因：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象之间共享数据</li>
</ul>
<h4 id="直接管理内存">直接管理内存</h4>
<h5 id="new动态分配和初始化对象">new动态分配和初始化对象</h5>
<p>默认情况下动态分配的对象是默认初始化的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>可以使用直接初始化方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *pv = <span class="keyword">new</span> vector&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以使用值初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br></pre></td></tr></table></figure>
<h5 id="动态分配const对象">动态分配const对象</h5>
<p>用new分配const对象是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>同样，一个动态分配的const对象必须进行初始化</p>
<h5 id="内存耗尽">内存耗尽</h5>
<p>内存耗尽时new表达式失败，抛出一个bad_alloc类型的异常</p>
<p>阻止抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式称为定位new，如果定位new不能分配所需内存，会返回一个空指针</p>
<h5 id="释放动态内存">释放动态内存</h5>
<p>delete表达式执行：<strong>销毁给定的指针指向的对象，释放对应的内存</strong></p>
<h5 id="指针值和delete">指针值和delete</h5>
<p>传递给delete的指针必须满足两个条件之一<strong>1.指向动态分配的内存；2.空指针</strong></p>
<p>编译器不能分辨指针指向的是动态分配对象还是静态分配对象，也不能分辨指针所指向的内存是否已经释放了
<strong>空悬指针</strong></p>
<p>一个问题是，即便delete释放内存后，再将指针设置为nullptr，也只能提供有限的保护，因为可能有其他指向该已释放内存的指针，这些指针变为空悬指针。</p>
<h4 id="shared_ptr和new结合使用">shared_ptr和new结合使用</h4>
<p>可以用new返回的指针初始化智能指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>接受指针参数的智能指针构造函数是explicit的</strong>，必须使用直接初始化形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放所关联的对象（除非提供自己的Deleter代替delete）</p>
<h4
id="不要混合使用普通指针和智能指针">不要混合使用普通指针和智能指针</h4>
<p>当一个shared_ptr绑定到一个普通指针时，就不应该再用内置指针访问shared_ptr所指向的内存了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(x);<span class="comment">//错误，不能进行隐式转换</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));<span class="comment">//合法，但内存会被释放</span></span><br><span class="line"><span class="type">int</span> j = *x;<span class="comment">//未定义行为，x是一个空悬指针</span></span><br></pre></td></tr></table></figure>
<p><strong>永远不要用get初始化另外一个智能指针或未另一个智能指针赋值</strong>：使用get初始化的智能指针与原智能指针是各自独立的，当一个智能指针的计数器为0释放内存后，另一个智能指针就会变为空悬指针。</p>
<h4 id="智能指针和异常">智能指针和异常</h4>
<p>发生异常退出函数时，局部对象会被销毁，如果局部对象是智能指针，则会在销毁时检查计数确定是否需要释放内存</p>
<p>而普通指针不会自动释放内存，需要在异常发生位置人为delete</p>
<p><strong>智能指针基本规范：</strong></p>
<ul>
<li>不使用相同的内置指针值初始化或reset多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个智能指针</li>
<li>如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了</li>
<li>如果用智能指针管理非动态分配资源，一定要传递一个删除器</li>
</ul>
<h4 id="unique_ptr">unique_ptr</h4>
<p>某个时刻只能有一个unique_ptr指向一个给定对象</p>
<p>需要将unique_ptr绑定到一个new返回的指针上，且<strong>必须采用直接初始化形式</strong>。因为unique_ptr不支持普通的拷贝或者赋值操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u.<span class="built_in">realease</span>();<span class="comment">//放弃对指针的控制权，返回指针，并将u置为空</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.release);</span><br></pre></td></tr></table></figure>
<p>可以调用release或reset将指针的所有权从一个非const
unique_ptr转移给另一个unique_ptr</p>
<p><strong>release不会释放内存，release如果不把控制权交给另一个指针，就要负责资源释放</strong></p>
<p><strong>unique_ptr不能拷贝的例外规则：可以拷贝或赋值一个将要被销毁的unique_ptr</strong></p>
<h4 id="weak_ptr">weak_ptr</h4>
<p>不控制所指对象生存期的智能指针，指向一个由shared_ptr管理的对象</p>
<p>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数，shared_ptr销毁时不会考虑是否有weak_ptr指向对象</p>
<p>weak_ptr与共享对象的shared_ptr共享计数器</p>
<p>w.expired(); return w.use_count()==0 ? true : false;</p>
<p>w.lock();
如果expired为true返回空shared_ptr，否则返回指向w的对象的shared_ptr</p>
<p><strong>要用一个shared_ptr初始化weak_ptr</strong></p>
<h3 id="动态数组">动态数组</h3>
<h4 id="new和数组">new和数组</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()];<span class="comment">//方括号中必须是整型，但不必是常量</span></span><br></pre></td></tr></table></figure>
<p>new得到的是数组元素类型的指针</p>
<p>分配的内存根本不是数组类型，所以不能对动态数组调用begin或者end</p>
<p>也不能用<strong>范围for</strong>语句处理动态数组中的元素</p>
<p>默认使用默认初始化，如下方式使用值初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()]();</span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>不能用auto分配数组</strong></p>
<p>可以动态分配一个空数组，new返回一个非空指针，类似于尾后指针</p>
<h4 id="allocator类">allocator类</h4>
<p>将内存分配和对象构造分离开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);</span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p,n);<span class="comment">//从p地址开始的内存被释放，n必须是p创建时所要求的大小，p不能为空，必须指向allocator分配的内存</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(p,args);<span class="comment">//args被传递给构造函数，在p指向的内存位置中构造一个对象</span></span><br><span class="line">alloc.<span class="built_in">destroy</span>(p);<span class="comment">//对p指向的对象执行析构函数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》笔记（1-7章）</title>
    <url>/2023/04/12/%E3%80%8ACPP-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%881-7%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p>《C++ Primer》 1-7章笔记</p>
<span id="more"></span>
<h2 id="第一章">第一章</h2>
<p>标准库定义的4个IO对象：cin cout cerr clog</p>
<p>输入输出运算符返回其左侧运算对象作为其计数结果</p>
<p>UNIX系统中，文件结束符输入使用ctrl+D</p>
<p>保持代码格式的一致性</p>
<p>使用文件重定向：$addItem &lt;inFile &gt; outFile
该命令从inFile文件中读取，并将输出结果写入outFile中</p>
<h2 id="第二章">第二章</h2>
<h3 id="基本内置类型">基本内置类型</h3>
<p>C++定义了一套算术类型和空类型在内的基本数据类型</p>
<p>C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long
long(C++11)至少和一个long一样大</p>
<p>一个字节要至少能容纳机器基本字符集中的字符</p>
<p>字符型被分为了char,signed char,unsigned
char,需要注意类型char和类型signed
char并不一样，<strong>类型char会表现为signed char或unsigned
char的一种，具体是哪种由编译器决定</strong></p>
<p>在算术表达式中不要使用char或bool。因为char在不同机器上是有符号的或者无符号的。</p>
<p>执行浮点数运算选用double，因为float通常精度不够且双精度浮点数和单精度的计算代价相差无几</p>
<p><strong>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数</strong>。e.g.
8bit unsigned char表示0-255，如果赋值-1所得结果为255（-1%256）</p>
<blockquote>
<p>整数商c=a/b 计算模或者取余 r = a - c*b</p>
<p><strong>当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。</strong></p>
<p><strong>当符号不一致时，求模运算结果的符号和b一致，求余运算结果的符号和a一致。</strong></p>
<p>取模和取余区别在于，取模运算在取c的值时向无穷小方向舍入（-1/5=-0.2向无穷小方向取整得-1）；取余运算在取c的值的时候向0方向舍入(-1/5=-0.2向0取整得到0)，第二步是相同的。</p>
<p>所以取模时计算机向无穷小方向舍入，即c=-1，r=(-1)-(-1)*256=255;</p>
</blockquote>
<blockquote>
<p>-1转unsigned</p>
<p>int类型原码表示为1000 0000 0000 0000 0000 0000 0000 0001</p>
<p>但在int类型在内存中的存储为补码（负数补码除符号位原码取反+1）</p>
<p>所以其在内存中表示为1111 1111 1111 1111 1111 1111 1111 1110+1</p>
<p>但unsigned类型认为是正数，所以其补码存储与原码相同</p>
<p>也就是2^32-1</p>
<p>所以强转为unsigned之后值为2^32-1</p>
</blockquote>
<p><strong>切勿混用带符号类型和无符号类型</strong></p>
<p>如果反斜线后面跟着的八进制数字超过3个，只有前三个数字与之构成转义序列，而十六进制的。</p>
<h3 id="变量">变量</h3>
<p><strong>初始化和赋值是两个完全不同的操作</strong>，初始化的含义是创建变量时赋予其一个初始值，赋值的含义是把对象当前值擦除以一个新值代替。</p>
<p><strong>列表初始化：</strong>C++11，用花括号初始化变量。<strong>如果使用列表初始化切初始值存在丢失信息的风险，则编译器将报错</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">1.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;,b=&#123;ld&#125;<span class="comment">//错误，因为存在丢失信息风险</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">c</span>(ld),d=ld;<span class="comment">//正确,但是确实丢失了一部分值</span></span><br></pre></td></tr></table></figure>
<h4 id="变量定义与声明的关系">变量定义与声明的关系</h4>
<p>C++分离式编译，允许程序分割为若干文件，每个文件可被独立编译。</p>
<p><strong>声明</strong>使得名字为程序所知，<strong>定义</strong>负责创建与名字关联的实体</p>
<p>如果要
声明一个变量而非定义它，就在变量名前加<strong>extern</strong>关键字</p>
<p><strong>任何包含了显式初始化的声明即成为定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;<span class="comment">//声明i但不定义</span></span><br><span class="line"><span class="type">int</span> j;<span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<p>在函数体内部，如果试图初始化一个由extern标记的变量，将引发错误。</p>
<p><strong>变量只能被定义一次，但可以被多次声明</strong>。</p>
<p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须且只能出现在一个文件中。</p>
<h4 id="作用域">作用域</h4>
<p>一旦声明之后，全局作用域内的名字在整个程序范围内都可使用。</p>
<p><strong>覆盖规则</strong></p>
<h3 id="复合类型">复合类型</h3>
<h4 id="引用">引用</h4>
<p>引用为对象起了另外一个名字。<strong>引用必须被初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure>
<p><strong>定义引用时，程序把引用和它的初始值绑定在一起，而不是拷贝给引用</strong>，所以，<strong>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。</strong></p>
<p>引用不是一个对象，<strong>所以不能定义引用的引用。</strong></p>
<p>一句定义多个引用时，每个引用标识符都必须以&amp;开头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>,i2=<span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> &amp;ri = i,&amp;ri2 = i2;</span><br></pre></td></tr></table></figure>
<p>引用不能绑定在字面值或者表达式计算结果上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;refVal = <span class="number">10</span>;<span class="comment">//wrong</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = dval;<span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
<h4 id="指针">指针</h4>
<p>指针本身就是一个对象，允许赋值和拷贝</p>
<p>取地址符&amp; 解引用符*</p>
<p>使用nullptr初始化得到空指针（C++11)</p>
<p>NULL预处理变量，在cstdlib中定义，值为0</p>
<p><strong>新标准下，最好使用nullptr，尽量避免使用NULL</strong></p>
<p><strong>把int变量直接赋给指针是错误的操作</strong></p>
<p>如果两个指针存放的地址值相同则它们相等</p>
<p>void*指针可以存放任意对象的地址，但并不了解对象的类型</p>
<p><strong>指向指针的引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;<span class="comment">//r是对指针p的引用</span></span><br><span class="line">r = &amp;i;<span class="comment">//相当于对p赋给i的地址</span></span><br><span class="line">*r = <span class="number">0</span>;<span class="comment">//设置为空</span></span><br></pre></td></tr></table></figure>
<p><strong>要理解r的类型，最简单的方法是从右向左阅读r的定义，离变量名最近的符号对变量类型有最直接的影响</strong></p>
<h3 id="const限定符">const限定符</h3>
<p>必须初始化</p>
<p><strong>默认状态下，const对象仅在文件内有效</strong></p>
<p>定义一个常量之后，编译器在编译过程中把所有用到该常量的地方都替换成对应值。</p>
<p>文件之间共享：extern关键字，只需要定义一次</p>
<h4 id="const的引用">const的引用</h4>
<p><strong>指把引用绑定到const对象上</strong></p>
<p>对常量的引用与普通引用的区别在于不能修改其所绑定的对象</p>
<p><strong>所以也不能通过一个非常量引用去指向一个常量对象，因为非常量引用理论上是可以被修改的，二者相矛盾</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;<span class="comment">//correct</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//wrong</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;<span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
<p><strong>引用的类型必须与其所引用对象的类型一致，但例外1：初始化常量引用时允许使用任意表达式作为初始值，只要表达式结果能转换成引用的类型。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解</p>
<p>double dval = 3.14; const int &amp;ri = dval;</p>
<p>编译器为了确保让ri绑定一个整数，把上述代码变为：</p>
<p>const int tmp = dval; const int &amp;ri = tmp;</p>
<p>所以绑定的是一个临时量，由于对const的引用不会改变值，所以是合法的</p>
<p>但如果ri不是常量，上述过程如果可以执行的话，改变ri相当于改变了绑定的临时量，而使用绑定肯定是想改变dval的值，所以这种方法不能达到目的，C++也就将这种行为归为非法</p>
</blockquote>
<p><strong>常量引用仅对可参与的操作进行了限定，对引用的对象本身是否是常量未作限定</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;</span><br><span class="line">r2 = <span class="number">0</span>;<span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人理解：常量引用只是在引用上加const限定，被绑定对象本身是否为const类型均可，但无论何种情况都不能<strong>通过引用</strong>对被绑定对象进行修改。更多的可能还是用于参数传递时保证参数不被修改。</p>
</blockquote>
<h4 id="指针和const">指针和const</h4>
<p>指向常量的指针不能用于改变其所指1对象的值。<strong>要想存放常量对象地址，只能使用指向常量的指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;<span class="comment">//错误，必须使用指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;<span class="comment">//correct</span></span><br><span class="line">*cptr = <span class="number">32</span>;<span class="comment">//wrong;</span></span><br></pre></td></tr></table></figure>
<p>同理于常量引用，上述例子中pi是非常量也是可以的。</p>
<p><strong>const指针</strong></p>
<p>指针与引用不同的地方在于，指针是对象，所以允许把指针本身设定为常量。<strong>常量指针必须初始化。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>从右向左理解最后一行：pip是变量名，const说明pip是一个常量，*说明pip是一个常量指针，const
double说明pip指向一个双精度浮点常量</p>
<blockquote>
<p>理解：</p>
<p>int errNumb = 0; int *const curErr = &amp;errNumb;</p>
<p>这个例子中，用errNumb = 3;或者*curErr =
15;这样的方法去修改值是合法的，这完全取决于被指向的变量类型是否为const。常量指针的意义在于<strong>其指向的地址是不可以修改的</strong></p>
</blockquote>
<h4 id="顶层const">顶层const</h4>
<p><strong>顶层const对任意类型适用，表示修饰对象本身是个常量，底层const表示指针或引用所指的对象是一个常量</strong></p>
<p>底层const的限制不能忽视，当执行对象拷贝操作时，拷入和拷出的对象必须具有相同的<strong>底层const</strong>资格，或者两个对象数据类型必须能够转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;<span class="comment">//顶层const，不能改变p1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci =<span class="number">42</span>;<span class="comment">//顶层const,不能改变ci</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;<span class="comment">//允许改变p2，底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;<span class="comment">//右顶层，左底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;<span class="comment">//底层const</span></span><br><span class="line">i = ci;<span class="comment">//正确，ci顶层const无影响</span></span><br><span class="line">p2 = p3;<span class="comment">//正确，p3顶层const，二者指向对象类型相同；</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = p3;<span class="comment">//错误，p3底层const，p1没有</span></span><br><span class="line">p2 = p3;<span class="comment">//正确，二者都是底层const</span></span><br><span class="line">p2 = &amp;i;<span class="comment">//正确，非常量向常量转换</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;<span class="comment">//错误，ci底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h4 id="constexpr">constexpr</h4>
<p>值不会改变且编译过程能得到结果的表达式</p>
<p>一个表达式是否是常量表达式由其数据类型和初始值共同决定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxFiles = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = maxFiles + <span class="number">1</span>;<span class="comment">//y</span></span><br><span class="line"><span class="type">int</span> staffSize = <span class="number">7</span>;<span class="comment">//n</span></span><br></pre></td></tr></table></figure>
<p>声明为constexpr类型以便由编译器验证变量的值是否是常量表达式（cpp11）</p>
<p><strong>一般来说，如果认定变量是一个常量表达式，就声明成constexpr类型</strong></p>
<p><strong>如果在constexpr声明中定义了一个指针，则constexpr限定符仅对指针有效，与其所指的对象无关</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是指向整数的常量指针（顶层const）</span></span><br></pre></td></tr></table></figure>
<h3 id="处理类型">处理类型</h3>
<p>typedef</p>
<p>using wages = double;(C++11)</p>
<p><img src="image-20230412102604379.png" /></p>
<blockquote>
<p>pstring是char<em>,const pstring修饰的是pstring，所以等同于 char
</em>const</p>
<p>const pstring cstr = 0与pstring const cstr=0是一样的意思</p>
<p>const char* 和char const *没有区别，const出现在base
type旁边修饰的就是base type，与左右无关。</p>
</blockquote>
<h4 id="autocpp11">auto(cpp11)</h4>
<p>让编译器去分析表达式所属的类型</p>
<p>使用auto在一条语句声明多个变量时，一条语句中变量的初始基本数据类型必须一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
<p><strong>使用引用时auto的类型是引用对象的类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>,&amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;<span class="comment">//a is an int</span></span><br></pre></td></tr></table></figure>
<p><strong>auto一般会忽略顶层const</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i,&amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;<span class="comment">//b is an int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;<span class="comment">// d is a const pointer</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;<span class="comment">//e is a pointer pointing to a const int.</span></span><br></pre></td></tr></table></figure>
<p><strong>使用const
auto明确指出推断出的类型是一个顶层const</strong></p>
<h4 id="decltypec11">decltype(c++11)</h4>
<p>作用是选择并返回操作数的数据类型，但在此过程中编译器不实际计算表达式的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;</span><br></pre></td></tr></table></figure>
<p><strong>decltype返回的类型包括顶层const和引用在内</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>，&amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x类型为const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y类型为const int&amp;</span></span><br></pre></td></tr></table></figure>
<p><strong>如果decltype使用的表达式不是变量，则decltype返回表达式结果对应的类型</strong></p>
<p><strong>有些表达式将向decltype返回一个引用类型，意味着该表达式的结果对象能作为一条赋值语句的左值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(*p) c;</span><br></pre></td></tr></table></figure>
<p>解引用返回一个左值，该语句中c的类型为int&amp;</p>
<blockquote>
<p>当程序员使用 decltype(exp)
获取类型时，编译器将根据以下三条规则得出结果：</p>
<ul>
<li>如果 exp
是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么
decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp)
的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么
decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么
decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>声明为返回（到对象的）左值引用/右值引用/对象的函数，用于函数调用表达式中时，形成的表达式值类别分别是左值/亡值/纯右值。然后
decltype
对该表达式的结果，还原了函数的返回类型。（https://www.zhihu.com/question/279641558）</p>
</blockquote>
<h3 id="自定义数据结构">自定义数据结构</h3>
<p><strong>C++11规定可以为数据成员提供一个类内初始值，创建对象时没有初始值的成员将被默认初始化</strong></p>
<h2 id="第三章">第三章</h2>
<h3 id="命名空间的using声明">命名空间的using声明</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using namspace::name</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br></pre></td></tr></table></figure>
<p><strong>每个名字都要独立的using语句声明</strong></p>
<p><strong>头文件不应该包含using声明</strong>，因为头文件的内容会拷贝到所有引用它的文件中，导致所有的文件中都会有声明，可能产生冲突。</p>
<h3 id="标准库类型string">标准库类型string</h3>
<p>可变长字符序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//连续n个字符c组成的串</span></span><br></pre></td></tr></table></figure>
<p><strong>使用=执行的是拷贝初始化，否则执行的是直接初始化</strong></p>
<h4 id="string对象上的操作">string对象上的操作</h4>
<p>读取操作时会自动忽略开头空格、换行、制表等并从第一个真正的字符开始读入，直到下一处空白为止。</p>
<p>size函数返回string::size_type类型的值，该类型与机器无关，是一个无符号类型的值</p>
<p><strong>如果一条表达式中已经有了size()就不要再混用int了</strong></p>
<p>string的比较规则：</p>
<ul>
<li>如果两个string长度不同且较短的string每个字符都与较长的string对应位置的字符相同，则较短的string小于较长的</li>
<li>一般比较的结果是string对象中第一对相异字符比较的结果。</li>
</ul>
<p><strong>使用加法时必须确保<em>每个加号</em>两侧对象至少有一个是string(不可均为字符字面值或字符串字面值)</strong></p>
<p><strong>为了与C兼容，CPP的字符串字面值不是标准库类型string的对象</strong></p>
<h4 id="处理string对象中的字符">处理string对象中的字符</h4>
<p>范围for处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : str)&#123;</span><br><span class="line">    <span class="comment">//handle c here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下标迭代处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> idx = <span class="number">0</span>;idx!=str.<span class="built_in">size</span>();idx++)&#123;</span><br><span class="line">    <span class="comment">//handle c here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标准库类型vector">标准库类型vector</h3>
<p>vector是一个类模板（<strong>不是类型</strong>），编译器根据类模板创建类的过程称为实例化。</p>
<h4 id="初始化vector对象">初始化vector对象</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;;<span class="comment">//10个默认初始化元素</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>&#125;;<span class="comment">//10个hi</span></span><br></pre></td></tr></table></figure>
<p>v7，v8提供的值不能作为元素初始值，编译器在确认无法执行列表初始化后，会尝试使用默认值初始化vector对象</p>
<h4 id="向vector对象中添加元素">向vector对象中添加元素</h4>
<h4 id="其他vector操作">其他vector操作</h4>
<p>使用size_type需要首先指定它是由那种类型定义的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type<span class="comment">//y</span></span><br><span class="line">vector::size_type<span class="comment">//n</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器">迭代器</h3>
<p>end成员负责返回指向容器尾元素的下一位置的迭代器</p>
<p><strong>如果容器为空，begin和end返回的都是尾迭代器</strong></p>
<blockquote>
<p>使用!=和迭代器判断而非下标：因为这种风格在标准库提供的所有容器上都有效</p>
<p>所有的标准库容器的迭代器都定义了==和!=,但大多数没有定义小于运算符</p>
</blockquote>
<p>begin和end具体的返回类型由对象是否是常量决定，如果对象是常量，返回const_iterator，否则返回iterator</p>
<p>cbegin和cend一定返回const_iterator</p>
<p><strong>箭头运算符把解引用和成员访问两个操作结合在一起</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>();</span><br><span class="line">it-&gt;<span class="built_in">empty</span>();<span class="comment">//二者等价</span></span><br></pre></td></tr></table></figure>
<p><strong>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</strong>（9.3.6）</p>
<h4 id="迭代器运算">迭代器运算</h4>
<p>两个迭代器相减得到的是其距离，即右侧迭代器向前移动多少位置能追上左侧的，其类型为<strong>difference_type的带符号整数</strong>，即距离可正可负。</p>
<h3 id="数组">数组</h3>
<p>数组大小确定不变，所以对某些特殊的应用程序而言运行时性能较好，但损失了灵活性</p>
<p><strong>声明数组时其大小必须是一个常量表达式</strong></p>
<p>列表初始化时：</p>
<ul>
<li>没有指明维度，编译器根据初始值数量推测</li>
<li>指明维度，<strong>初始值总数量不应超出维度</strong>；如果小于维度，则其他的会被设置为默认值</li>
</ul>
<p><strong>字符数组</strong>注意留出空字符的空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> a[<span class="number">6</span>] = <span class="string">&quot;daniel&quot;</span>;<span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
<p>数组不能拷贝和赋值（某些编译器扩展可以）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//含有10个指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*pArr)[<span class="number">10</span>];<span class="comment">//指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<p>[]image-20230412102638060.png)</p>
<h4 id="指针和数组">指针和数组</h4>
<p>大多数表达式中对数组对象的使用其实是使用一个指向首元素的指针</p>
<p><strong>decltype</strong>对数组使用结果依然是数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;...&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a) a2;</span><br><span class="line">a2[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>end和begin函数分别以数组作为参数，返回指向尾元素下一位置和首元素的指针（C++11）</p>
<p>两个指针也可以相减，返回类型为ptrdiff_t,带符号机器相关类型</p>
<p>两个指针也可以&lt; !=等运算，类似于迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>];<span class="comment">//ia[3]</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>];<span class="comment">//ia[0]</span></span><br></pre></td></tr></table></figure>
<p>数组初始化vector对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">avec</span><span class="params">(begin(a),end(a))</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">avec2</span><span class="params">(a+<span class="number">1</span>,a+<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组">多维数组</h3>
<p><img src="image-20230412102652469.png" /></p>
<h2 id="第四章">第四章</h2>
<h3 id="基础">基础</h3>
<h4 id="基本概念">基本概念</h4>
<p>一元运算符 二元运算符 三元运算符</p>
<h5 id="左值和右值"><strong>左值和右值：</strong></h5>
<p>左值可以位于赋值语句左侧，右值则不能（C）</p>
<p><strong>当一个对象被用作左值，用的是对象的身份（在内存中的位置）；被用作右值时，用的是对象的值（CPP）</strong></p>
<p><strong>重要原则：</strong>需要右值的地方可以用左值代替，但不能把右值当作左值使用</p>
<p>几种情况：</p>
<ul>
<li>赋值运算符需要一个非常量左值作为左侧运算对象，结果仍然是一个左值</li>
<li>取地址符作用于一个左值运算对象，返回指向该运算对象的指针，该指针是<strong>右值</strong>（？用的是指针的内容，也即运算对象的地址）</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string/vector下标运算符求值结果为左值</li>
<li>内置类型和迭代器递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值</li>
</ul>
<h4 id="求值顺序">求值顺序</h4>
<p>&amp;&amp; || ?:
,四种运算符只有当左侧条件成立才继续求右侧对象的值</p>
<h3 id="算术运算符">算术运算符</h3>
<p><strong>算术运算符的运算对象和求值结果都是右值</strong></p>
<p>除了-m导致溢出的情况，其他时候(-m)/n=m/(-n)=-(m/n)；m%(-n)=m%n,(-m)%n=-(m%n)</p>
<blockquote>
<p><strong>当m和m符号一致时，求模运算和求余运算所得的值一致，因此结果一致。</strong></p>
<p><strong>当符号不一致时，求模运算结果的符号和n一致，求余运算结果的符号和m一致。</strong></p>
</blockquote>
<h3 id="逻辑和关系运算符">逻辑和关系运算符</h3>
<p><strong>逻辑和关系运算符的运算对象和求值结果都是右值</strong></p>
<h3 id="赋值运算符">赋值运算符</h3>
<p><strong>赋值运算符左侧运算对象必须是可修改的左值，运算结果也是左侧运算对象，并且是一个左值</strong></p>
<p>赋值运算符满足右结合律</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ival = jval = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>赋值运算符优先级相对较低，通常需要给赋值部分加上括号使其符合原意</p>
<h3 id="递增递减运算符">递增递减运算符</h3>
<p>前置版本：先将对象+-1，改变后的对象作为求值结果</p>
<p>后置版本：将对象+-1，但求值结果是改变之前的值的副本</p>
<p><strong>除非必须，否则不用后置版本</strong>（后置版本会进行原始值的储存。如果不需要修改前的值会造成浪费）</p>
<h3 id="条件运算符">条件运算符</h3>
<p><strong>当条件运算符的两个表达式都是左值或者能转换为同一种左值类型时，运算结果为左值；否则结果为右值</strong></p>
<p>条件运算符优先级非常低</p>
<h3 id="位运算符">位运算符</h3>
<p>强烈建议位运算符只对无符号类型处理</p>
<p>e.g.
右移之后高位会插入符号位副本或者值为0的二进制位，视具体环境而定</p>
<h3 id="sizeof运算符">sizeof运算符</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (type);<span class="comment">//</span></span><br><span class="line"><span class="keyword">sizeof</span> expr;<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>第二章返回表达式结果类型的大小，并不实际计算运算对象的值。</p>
<p>sizeof返回值是一个常量表达式</p>
<p><strong>对数组执行sizeof得到整个数组所占空间大小，等价于对数组中所有元素sizeof运算并求和</strong></p>
<p><strong>对string或vector运算只返回该类型固定部分的大小，不会计算对象中元素占用了多少空间</strong></p>
<h3 id="类型转换">类型转换</h3>
<p>隐式转换发生：</p>
<ul>
<li>大多数表达式中，比int小的整型值会提升为较大整数类型</li>
<li>初始化过程中初始值转换为变量的类型</li>
<li>......</li>
</ul>
<h4 id="算术转换">算术转换</h4>
<p>如果带符号类型和无符号类型共存，且无符号类型不小于带符号类型，则带符号转换为无符号</p>
<h4 id="显式转换">显式转换</h4>
<p><strong>尽量避免使用强制类型转换！</strong></p>
<p>命名的强制类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expr);</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong></p>
<p>任何明确定义的类型转换，只要不包含底层const，都可以使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i)/j;</span><br></pre></td></tr></table></figure>
<p>场景：较大算术类型赋值给较小的，执行显示转换后不会发出警告信息；对编译器无法自动执行的类型转换也非常有用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>
<p><strong>const_cast</strong></p>
<p>只能改变运算对象底层const</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);</span><br></pre></td></tr></table></figure>
<p>如果pc指向的char不是常量，那么转换获得写权限是合法行为，否则会产生未定义的后果</p>
<p><strong>reinterpret_cast</strong></p>
<p>从位模式上重新解释运算对象，依赖于机器，非常危险</p>
<p>旧式强制类型转换执行与之相似的功能</p>
<p><strong>dynamic_cast</strong></p>
<h2 id="第五章">第五章</h2>
<h3 id="简单语句">简单语句</h3>
<p>空语句：语法上需要但逻辑上不需要时使用</p>
<p>复合语句：语法上需要一条语句但逻辑上需要多条语句时使用</p>
<h3 id="条件语句">条件语句</h3>
<p>switch语句的case标签必须是整型常量表达式</p>
<p>switch的控制流：如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显式break这一过程</p>
<h3 id="迭代语句">迭代语句</h3>
<p>C++11 范围for语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r:v)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>范围for语句不能递增vector的对象，因为存储了end()的值，改变vec序列的元素数量后end函数的值可能无效</strong></p>
<h3 id="跳转语句">跳转语句</h3>
<h3 id="try语句块和异常处理">try语句块和异常处理</h3>
<p>异常检测部分使用throw表达式引发异常</p>
<p>异常处理部分使用try语句块处理异常</p>
<h4 id="throw">throw</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> expr;</span><br></pre></td></tr></table></figure>
<h4 id="try">try</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    program-statements<span class="comment">//需要异常检测的部分，可能抛出异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(exception-declaration)&#123;<span class="comment">//根据括号内异常声明，捕获并处理</span></span><br><span class="line">    handler</span><br><span class="line">&#125; <span class="built_in">catch</span>(exception-declaration)&#123;</span><br><span class="line">    handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找不到匹配的catch子句，程序将会转到terminate标准库函数，一般执行该函数将导致程序非正常退出</p>
<p>对于没有try语句块的异常也按照类似方式处理。</p>
<p><strong>异常发生后确保对象有效、资源无泄漏、程序处于合理状态等非常困难但重要</strong></p>
<h2 id="第六章">第六章</h2>
<h3 id="基础-1">基础</h3>
<p>函数调用完成两项工作：</p>
<ul>
<li>用实参初始化函数对应的形参</li>
<li>控制权转给被调用函数，主调函数的执行暂时中断</li>
</ul>
<p><strong>形参和实参存在对应关系，但没有规定实参的求值顺序</strong></p>
<p>作用域和生命周期：</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间</li>
</ul>
<p><strong>自动对象</strong>：只存在于块执行期间的对象</p>
<p>形参是一种自动对象，开始时为其申请存储空间，函数终止形参也被销毁</p>
<p><strong>局部静态对象：</strong>将局部变量定义为static类型可以获得，在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁。</p>
<p><strong>函数声明、函数原型：</strong>返回类型、函数名、形参类型描述函数接口</p>
<p>头文件声明，源文件定义</p>
<h3 id="参数传递">参数传递</h3>
<h4 id="值传递"><strong>值传递：</strong></h4>
<p>初始值被拷贝，对形参改动不会影响实参</p>
<p>指针形参时，可以通过解引用改变所指对象的值，但实参指针本身内容（指向的地址）不会发生改变</p>
<h4 id="引用传递"><strong>引用传递：</strong></h4>
<p>相当于实参别名，对形参的修改会影响实参</p>
<p><strong>使用引用传递无需拷贝，如果不需要修改可以声明为常量引用</strong></p>
<h4 id="const形参和实参"><strong>const形参和实参：</strong></h4>
<p>实参初始化形参时会忽略顶层const，即可以用非常量对象去初始化常量形参</p>
<p><strong>尽量使用常量引用</strong></p>
<h4 id="数组形参"><strong>数组形参：</strong></h4>
<p>数组无法被拷贝，所以无法以值传递方式使用数组参数；为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>应该提供额外信息确定数组确切尺寸：</p>
<ul>
<li>包含结束标记（C风格字符串）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cp)&#123;</span><br><span class="line">        <span class="keyword">while</span>(*cp) cout&lt;&lt;*cp++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用标准库规范</li>
</ul>
<p>传递首元素和尾后元素指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* beg,<span class="type">const</span> <span class="type">int</span>* end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg!=end) cout&lt;&lt;*beg++&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>显式传递数组大小形参</li>
</ul>
<p>形参也可以是数组的引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;&#125;<span class="comment">//维度10也是类型的一部分，传实参是要是含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="传递多维数组">传递多维数组</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>],<span class="type">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>仍然强调括号和维度必不可少，10为第二个维度，编译器会忽略<strong>第一个维度</strong></p>
<h4 id="含有可变形参的函数">含有可变形参的函数</h4>
<p><strong>如果所有实参类型相同</strong>，可以传递名为initializer_list的标准库类型（CPP11）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>();beg!=il.<span class="built_in">end</span>();++beg)&#123;</span><br><span class="line">        cout&lt;&lt;*beg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>initializer_list中的对象永远是常量值，无法改变其值</strong></p>
<p>在使用initializer_list时也可以同时拥有其他形参</p>
<p><strong>省略符形参：</strong></p>
<p>为了便于C++程序访问某些特殊的C代码，这些代码使用了varargs
C标准库功能。不应用于其他目的</p>
<p>仅用于C和C++通用的类型</p>
<p>只能出现在形参列表最后一个位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(params,...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="返回类型和return语句">返回类型和return语句</h3>
<p>不要返回局部对象的引用或指针</p>
<p>函数得到返回类型决定函数调用是否是左值，<strong>调用一个返回引用的函数得到左值，其他返回类型得到右值</strong></p>
<p>如果返回常量引用，则不能给调用的结果赋值</p>
<p><strong>返回数组指针：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];<span class="comment">//必须指出数组的维度且跟在函数名之后</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;<span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="type">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">decltypr</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)&#123;&#125;<span class="comment">//decltype不把数组转为指针，所以其结果是个数组，还需要加*返回指针</span></span><br></pre></td></tr></table></figure>
<h3 id="函数重载overload">函数重载（overload）</h3>
<p>同一作用域内名字相同但形参列表不同的若干函数</p>
<p><strong>不允许两个函数除了返回类型外其他要素都相同</strong></p>
<p><strong>由于顶层const不影响传入函数的对象，仅改变参数的顶层const不构成重载</strong>，但型参数指针或者引用，改变底层const区分指向的是常量对象还是非常量对象构成重载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;<span class="comment">//两个是重载函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account)</span></span>;<span class="comment">//两个不是重载函数</span></span><br></pre></td></tr></table></figure>
<h4 id="const_cast和重载">const_cast和重载</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string &amp;s2)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">shorterString</span><span class="params">(string&amp; s1,string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                           <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用重载函数">调用重载函数</h4>
<p>三种结果：</p>
<ul>
<li>找到与实参最佳匹配的函数，并生成调用该函数的代码</li>
<li>找不到任何一个函数与调用的实参匹配，编译器发出无匹配错误信息</li>
<li>有多于一个函数可以匹配，但都不是最佳选择，二义性调用</li>
</ul>
<h3 id="重载和作用域">重载和作用域</h3>
<p><strong>C++中名字查找发生在类型检查之前：</strong>局部作用域中声明的变量或函数与外层变量或函数重名时，编译器寻找到局部声明后，会忽略掉外层作用域中所有同名实体。之后才会检查调用函数是否有效。</p>
<h3 id="特殊用途语言特性">特殊用途语言特性</h3>
<h4 id="默认实参">默认实参</h4>
<p>可以为一个或多个形参定义默认值，但<strong>一旦某个形参被赋予默认值，它后面的所有形参都必须有默认值</strong></p>
<p>函数调用时实参按照位置解析，默认实参则负责填补函数调用缺少的尾部实参</p>
<p>多次声明同一个函数，在给定的作用域中一个形参只能被赋予一次默认实参，也即<strong>后续的声明都只能为之前没有默认值的形参添加默认实参，而且该形参右侧所有形参都必须有默认值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span>=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span>=<span class="string">&#x27;*&#x27;</span>)</span></span>;<span class="comment">//错误，重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz=<span class="number">24</span>,sz=<span class="number">22</span>,<span class="type">char</span>)</span></span>;<span class="comment">//正确，添加默认实参</span></span><br></pre></td></tr></table></figure>
<p><strong>局部变量不能作为默认实参</strong></p>
<h4 id="内联函数">内联函数</h4>
<p>将操作封装成函数可读性更好，可重复利用，修改更方便，但函数调用也会增加时间开销</p>
<p><strong>将函数指定为内联函数，可避免函数调用的开销</strong>，将函数在每个调用点上“内联地”展开</p>
<p><strong>内联说明只是向编译器发出的请求，编译器可以忽略该请求</strong></p>
<p>内联机制一般用于优化规模较小、流程直接、调用频繁的函数，很多编译器都不支持内联递归函数。</p>
<h4 id="constexpr函数">constexpr函数</h4>
<p>指能用于常量表达式的函数</p>
<p>定义时的要求：</p>
<ul>
<li>函数返回类型和所有形参类型都得是字面值类型</li>
<li>函数体中必须有且只有一条return语句</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();</span><br></pre></td></tr></table></figure>
<p>执行该初始化时，编译器把调用替换为结果值，且为了能在编译过程中随时展开，constexpr函数被隐式指定为内联函数。</p>
<p><strong>constexpr函数返回值可以为非常量</strong></p>
<p><strong>内联函数和constexpr函数通常定义在头文件内</strong>，因为编译器要展开函数不仅要声明还需要定义，且两类函数可能在程序中定义不止一次，此时必须保证在所有源文件中定义完全相同，放在头文件中可以确保这一点。</p>
<h4 id="调试帮助">调试帮助</h4>
<p>程序包含一些用于调试的代码，只在开发时使用，程序准备发布时，先屏蔽掉调试代码。该方法用到两项预处理功能</p>
<h5 id="assert预处理宏">assert预处理宏</h5>
<p>cassert头文件</p>
<p>assert(expr);</p>
<p>如果expr为0，输出信息终止执行；expr为真，什么也不做</p>
<p>常用于检查不能发生的条件</p>
<h5 id="ndebug预处理变量">NDEBUG预处理变量</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">size_t</span> sz)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    cerr&lt;&lt;_ _func_ _&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">assert</span>(sz&gt;<span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>_ _FILE_ _存放文件名的字符串字面值</li>
<li>_ _LINE_ _存放当前行号的整型字面值</li>
<li>_ _TIME_ _存放文件编译时间的字符串字面值</li>
<li>_ _DATE_ _存放文件编译日期的字符串字面值</li>
</ul>
<h3 id="函数匹配">函数匹配</h3>
<ol type="1">
<li>选定候选函数：与被调用函数同名，声明在调用点可见</li>
<li>选出可行函数：形参数量与调用实参数量相等，实参类型与对应形参类型相同且能转换</li>
<li>寻找最佳匹配（如果有）：实参和形参类型最接近的</li>
</ol>
<p><img src="image-20230412102729164.png" /></p>
<p>最接近的定义（排序）：</p>
<ol type="1">
<li>精确匹配：实参形参类型相同；实参从数组类型或函数类型转换为对应指针类型；实参添加或删除顶层const</li>
<li>const转换实现匹配</li>
<li>类型提升实现的匹配</li>
<li>算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样）</li>
<li>类类型转换实现的匹配</li>
</ol>
<h3 id="函数指针">函数指针</h3>
<p>声明一个指向函数的指针，只需要用指针替换函数名即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;);</span><br><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;dddd&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>重载函数的指针：</strong></p>
<p>使用重载函数时，上下文必须清晰界定到底选用哪个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*pf)(<span class="type">unsigned</span> <span class="type">int</span>)=ff;</span><br></pre></td></tr></table></figure>
<p>编译器通过指针类型决定选用哪个函数，必须与重载函数中的一个精准匹配</p>
<p><strong>函数指针形参：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2,<span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用typedef或declype定义别名简化</p>
<p>返回指向函数的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*,<span class="type">int</span>*);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">F* <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line"><span class="function">atuto <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span>-&gt;<span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="第七章">第七章</h2>
<p>类的基本思想：数据抽象、封装</p>
<p>数据抽象依赖于接口和实现分离的技术</p>
<p>定义在类内部的函数是隐式的inline函数</p>
<p>**this的类型默认情况下是指向类类型的非常量版本的常量指针T
*const**</p>
<p>将const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针（const
T *const)，有助于提高函数的灵活性</p>
<p><strong>常量对象、常量对象的引用或指针都只能调用常量成员函数</strong></p>
<h3 id="构造函数">构造函数：</h3>
<p>构造函数不能被声明成const,当创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此在const对象构造过程中构造函数可以向其写值。</p>
<p>默认构造函数：如果存在类内初始值，用它来初始化成语；否则默认初始化该成员。</p>
<p>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数</p>
<p>如果需要默认行为，可以在参数列表后面加上=default要求编译器生成构造函数（CPP11）</p>
<p>构造函数初始值列表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_date</span>(<span class="type">const</span> string&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝赋值析构">拷贝、赋值、析构</h3>
<h3 id="访问控制和封装">访问控制和封装</h3>
<p>public:成员在整个程序内可被访问，public成员定义了类的接口</p>
<p>private：成员可被类的成员函数访问，隐藏类的实现细节</p>
<h3 id="classstruct">class/struct</h3>
<p>class的默认访问权限为private,struct的默认访问权限为public</p>
<h3 id="友元">友元</h3>
<p>类可以允许其他类或函数访问它的非公有成员，方法是令其他类或函数成为它的友元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>友元声明只能出现在类定义的内部，但不受所声明区域访问控制级别的约束</strong></p>
<p>一般最好在类定义开始或结束前的位置集中声明友元</p>
<p><strong>友元的声明仅指定了访问权限，如果希望类的用户能调用某个友元函数，则必须在友元声明之外再专门对函数进行一次声明</strong></p>
<h3 id="类的其他特性">类的其他特性</h3>
<p>可变成员函数：永远不会是const，即使它是const对象的成员
mutable关键字</p>
<p>类可以把其他的类定义为友元，也可以把其他类的成员函数定义为友元（必须指出该成员函数属于哪个类）</p>
<p><strong>友元不存在传递性</strong></p>
<p>就算在类内部定义了友元函数，也必须在类外部提供相应的声明</p>
<h3 id="类的作用域">类的作用域</h3>
<p>类外部的成员函数，由于返回类型通常在函数名之前，所以返回类型中使用的名字都位于类的作用域之外。这时，必须指明返回类型是哪个类的成员。</p>
<h4 id="名字查找">名字查找</h4>
<ul>
<li>在名字所在块中寻找其声明语句，只考虑在名字使用之前出现的声明</li>
<li>如果没找到，继续查找外层作用域</li>
<li>如果最终没有找到匹配的声明，则程序报错</li>
</ul>
<p>对类内成员函数而言，解析其中的名字的方式与上述稍有区别</p>
<ul>
<li>在成员函数内查找该名字声明，只考虑在名字使用前出现的声明</li>
<li>如果没找到，在类内继续查找，这时类的所有成员都可以被考虑</li>
<li>类内也没找到，在成员函数定义之前的作用域继续查找</li>
</ul>
<h3 id="构造函数plus">构造函数plus</h3>
<p>构造函数的初始值有时必不可少</p>
<p>e.g.
如果成员是const或者引用或者某种未提供默认构造函数的类类型的话，必须将其初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii)</span><br><span class="line">&#123;</span><br><span class="line">    i = ii;</span><br><span class="line">    ci = ii;<span class="comment">//错误，不能给const赋值</span></span><br><span class="line">    ri = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii):<span class="built_in">i</span>(ii),<span class="built_in">ci</span>(ii),<span class="built_in">ri</span>(i)&#123;&#125;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h4 id="成员初始化顺序"><strong>成员初始化顺序</strong></h4>
<p>初始化列表不限定初始化的具体执行顺序，在初始化列表中的顺序可能不是初始化顺序。</p>
<p>成员初始化顺序与它们在类定义中的出现顺序一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val):<span class="built_in">j</span>(val),<span class="built_in">i</span>(j)&#123;&#125;<span class="comment">//先初始化i，但此时j未定义！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>尽量避免使用某些成员初始化其他成员</strong></p>
<h4 id="构造函数中的默认实参">构造函数中的默认实参</h4>
<p><strong>如果一个构造函数为所有参数都指定了默认实参，则它实际上也定义了默认构造函数</strong></p>
<h4 id="委托构造函数c11">委托构造函数（C++11）</h4>
<p>委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">double</span> k;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val,<span class="type">int</span> val2,<span class="type">double</span> dval):<span class="built_in">i</span>(val),<span class="built_in">j</span>(val2),<span class="built_in">k</span>(dval)&#123;&#125;<span class="comment">//被委托构造</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="type">double</span> val):<span class="built_in">X</span>(<span class="number">0</span>,<span class="number">0</span>,val)&#123;&#125;<span class="comment">//委托构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>被委托函数的函数体也会被执行，然后控制权才会交还给委托者的函数体</p>
<h4 id="隐式的类类型转换">隐式的类类型转换</h4>
<p>转换构造函数：能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</p>
<p>编译器只能自动执行<strong>一步</strong>类类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);<span class="comment">//错误，这是先从字面值转换为string再转换为Sales_data</span></span><br><span class="line">item.<span class="built_in">comnime</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>explicit</strong>声明构造函数阻止隐式转换</p>
<p><strong>explicit关键字只对一个实参的构造函数有效，且只能在类内声明构造函数时使用</strong></p>
<p><strong>explicit构造函数只能用于直接初始化，不能用于拷贝初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;<span class="comment">//√</span></span><br><span class="line">Sales_date item2 = null_book;<span class="comment">//×</span></span><br></pre></td></tr></table></figure>
<p>explicit构造函数不能隐式转换，但可人为将其用于显式转换。</p>
<h3 id="聚合类">聚合类</h3>
<p>条件：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类没有虚函数</li>
</ul>
<p>这样的类可以由封闭的大括号用逗号分隔开初始化列表。</p>
<h3 id="字面值常量类">字面值常量类</h3>
<p>数据成员都是字面值类型的聚合类</p>
<h3 id="类的静态成员">类的静态成员</h3>
<p>成员与类本身直接相关而非与各个对象相关</p>
<p>static关键字</p>
<p>使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r = Account::<span class="built_in">rate</span>();<span class="comment">//使用作用域运算符访问静态成员</span></span><br><span class="line">r = ac.<span class="built_in">rate</span>();<span class="comment">//类的对象、指针、引用也可以直接访问</span></span><br><span class="line"><span class="comment">//成员函数不需其他即可访问</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》笔记</title>
    <url>/2023/04/12/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《MySQL必知必会》笔记</p>
<span id="more"></span>
<h2 id="章">1-7章</h2>
<p>主键：一列（多列组合），其值能唯一区分表中每个行</p>
<p>主键值规则：任意两行不具有相同的主键值；主键列不允许NULL值</p>
<p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db;</span><br></pre></td></tr></table></figure>
<p>选择数据库 USE语句</p>
<p>显示信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">SHOW</span>语句</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;<span class="operator">/</span><span class="operator">/</span>获得数据库表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;<span class="operator">/</span><span class="operator">/</span>获得数据库内的表</span><br><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> table1;<span class="operator">/</span><span class="operator">/</span>显示表列</span><br><span class="line"><span class="keyword">SHOW</span> STATUS;<span class="operator">/</span><span class="operator">/</span>显示广泛的服务器状态信息</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>检索信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">SELECT</span>语句，给出想选择什么，从什么地方选</span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name,prod_price <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<p>检索不同数据，只返回不同的值，DISTINCT关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<p>限制检索结果，LIMIT子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products LIMIT <span class="number">5</span>;<span class="operator">/</span><span class="operator">/</span>前<span class="number">5</span>行</span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products LIMIT <span class="number">5</span>,<span class="number">5</span>;<span class="operator">/</span><span class="operator">/</span>从第<span class="number">5</span>行开始返回<span class="number">5</span>行</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>没有足够的行只返回能返回的所有行</span><br></pre></td></tr></table></figure>
<p>排序，ORDER BY子句，默认升序，LIMIT子句要在ORDER BY之后</p>
<p>DESC关键字降序排列，只应用于其之前的列名，想在多个列降序，需要对每个列指定DESC关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price,prod_name;<span class="operator">/</span><span class="operator">/</span>按多个列排序，按照<span class="keyword">ORDER</span> <span class="keyword">BY</span>规定的顺序排序</span><br><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>,prod_name;</span><br></pre></td></tr></table></figure>
<p>WHERE子句指定搜索条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price<span class="operator">=</span><span class="number">2.50</span>;</span><br></pre></td></tr></table></figure>
<p>BETWEEN AND关键字：在指定的两个值之间（闭区间）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>空值：NULL，用IS NULL检查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>WHERE子句可以通过AND或OR组合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id<span class="operator">=</span><span class="number">1003</span> <span class="keyword">AND</span> prod_price<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id<span class="operator">=</span><span class="number">1002</span> <span class="keyword">OR</span> vend_id<span class="operator">=</span><span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<p><strong>AND优先级更高，先处理AND</strong></p>
<p>IN操作符，与OR功能相同但更直观，计算次序更清楚，比OR执行更快，可以包含其他SELECT子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>NOT在WHERE子句中否定后跟条件</p>
<p>MySQL支持使用NOT对IN、BETWEEN和
EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件
取反有很大的差别</p>
<h2 id="第8章-用通配符进行过滤">第8章 用通配符进行过滤</h2>
<p>通配符（wildcard）用来匹配值的一部分特殊字符</p>
<p>搜索模式（search
pattern）由字面值、通配符或两者组合构成的搜索条件。（如'jet%'，'%anvil%'）</p>
<h3 id="通配符">%通配符</h3>
<p>%通配符表示任何字符出现任意次数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;jet%&#x27;</span>;<span class="operator">/</span><span class="operator">/</span>找出所有以jet开头的</span><br><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%anvil%&#x27;</span>;<span class="operator">/</span><span class="operator">/</span>所有包含anvil的</span><br><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;s%e&#x27;</span>;<span class="operator">/</span><span class="operator">/</span>所有以s开头以e结尾的</span><br></pre></td></tr></table></figure>
<p><strong>%通配符不能匹配NULL</strong></p>
<h3 id="下划线通配符">下划线通配符</h3>
<p>_通配符与%用途一样，但<strong>只匹配单个字符</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;_ ton anvil&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="技巧">技巧</h3>
<ul>
<li>不要过度使⽤通配符。如果其他操作符能达到相同的⽬的，应该使⽤其他操作符。</li>
<li>在确实需要使⽤通配符时，除⾮绝对有必要，即使在有必要的情况下也不要把它们⽤在搜索模式的开始处。</li>
<li>把通配符置于搜索模式的开始处，搜索起来是最慢的，因为这样就是全⽂检索了。（比如%jet会对每个对象一直匹配至最后几个字符才会比较jet）</li>
</ul>
<h2 id="第9章-正则表达式进行搜索">第9章 正则表达式进行搜索</h2>
<p>正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;<span class="operator">/</span><span class="operator">/</span>prod_name包含<span class="number">1000</span>的所有行</span><br></pre></td></tr></table></figure>
<p><strong>REGEXP</strong>告诉SQL后面跟的东西作为正则表达式处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;1000&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>第一句会返回一行，第二句不返回数据</p>
<p>因为LIKE匹配整个列（将搜索模式和整个列值做比较，找值等于1000的行），REGEXP在值内进行匹配（每个列值中包含搜索模式1000的行）</p>
<p>.匹配任意<strong>一个</strong>字符。</p>
<p><strong>OR匹配|：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000|2000&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p><strong>匹配几个字符之一[]：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[123] Ton&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;<span class="operator">/</span><span class="operator">/</span>匹配prod_name中包含 <span class="number">1</span> ton<span class="operator">/</span><span class="number">2</span> ton<span class="operator">/</span><span class="number">3</span> ton的</span><br></pre></td></tr></table></figure>
<p>[123] Ton是[1|2|3]
Ton的缩写，一定要把或的内容括在一个集合里，否则会应用于整个串</p>
<p>否定：[^123]匹配除这些字符外的任何东西</p>
<p><strong>匹配范围：</strong></p>
<p>使用-定义一个范围</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[1-5] Ton&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p><strong>匹配特殊字符：</strong></p>
<p>使用\为前导</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name <span class="keyword">FROM</span> vendors <span class="keyword">WHERE</span> vend_name REGEXP <span class="string">&#x27;\.&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p><strong>匹配字符类：</strong></p>
<p><img src="image-20230205210313527.png" /></p>
<p><strong>匹配多个实例：</strong></p>
<p><img src="image-20230205211103262.png" /></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;\\([0-9] sticks?\\)&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>说明：\\(匹配左括号，[0-9]匹配任意数字，s?匹配s出现0次或1次，也即stick或者sticks，\\)匹配右括号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[[:digit:]]&#123;4&#125;&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>说明：[:digit:]匹配任意数字，{4}要求前面的字符出现4次，即任意4位数字。</p>
<p><strong>定位符：</strong></p>
<p><img src="image-20230205211621835.png" /></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;^[0-9\\.]&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;、、匹配以数字和小数点开头的所有产品</span><br></pre></td></tr></table></figure>
<p><strong>^在集合中表示否定该集合，在集合外表示文本开始处的定位符</strong></p>
<p><strong>利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使
REGEXP的作用与LIKE一样（LIKE匹配整个串，REGEXP匹配子串）</strong></p>
<h2 id="第10章-创建计算字段">第10章 创建计算字段</h2>
<p>只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。</p>
<p><strong>拼接，将值联结到一起构成单个值</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(vend_name,<span class="string">&#x27;(&#x27;</span>,vend_country,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">FROM</span> vendors <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p><strong>多数DBMS使用+或||来实现拼接，
MySQL则使用Concat()函数来实现。</strong></p>
<p><strong>Trim() LTrim() RTrim()</strong>去除值左右的空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(RTrim(vend_name),<span class="string">&#x27;(&#x27;</span>,RTrim(vend_country),<span class="string">&#x27;)&#x27;</span>) <span class="keyword">FROM</span> vendors <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p><strong>AS关键字赋予别名（导出列）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(vend_name,<span class="string">&#x27;(&#x27;</span>,vend_country,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> vend_title <span class="keyword">FROM</span> vendors <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p>任何客户机应用都可以按名引用 这个列，就像它是一个实际的表列一样</p>
<p><img src="image-20230206135900369.png" /></p>
<h2 id="第11章-使用数据处理函数">第11章 使用数据处理函数</h2>
<p><strong>文本处理函数：</strong></p>
<p><img src="image-20230206140032089.png" /></p>
<p><img src="image-20230206140053391.png" /></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, <span class="built_in">Upper</span>(vend_name) <span class="keyword">AS</span> vend_name_upcase <span class="keyword">FROM</span> vendors <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>
<p>Soundex()是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，主要目的是根据声音比较字符串之间的相似性。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Soundex(<span class="string">&#x27;sea&#x27;</span>) <span class="keyword">AS</span> sea_soundex, Soundex(<span class="string">&#x27;see&#x27;</span>) <span class="keyword">AS</span>  see_soundex;<span class="operator">/</span><span class="operator">/</span>均为<span class="number">5000</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> Soundex(cust_contact) <span class="operator">=</span> Soundex(<span class="string">&#x27;Y Lie&#x27;</span>);<span class="operator">/</span><span class="operator">/</span>返回Y Lee一行</span><br></pre></td></tr></table></figure>
<p><strong>日期和时间处理函数：</strong></p>
<p>日期和时间采用相应的数据类型和特殊的格式存储，应用程序一般不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。</p>
<p><img src="image-20230206141025622.png" /></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,order_num <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> <span class="type">Date</span>(order_date)<span class="operator">=</span><span class="string">&#x27;2005-09-01&#x27;</span></span><br></pre></td></tr></table></figure>
<p>应该总是使用yyyy-mm-dd格式，如果需要日期则使用Date()，即便知道相应的列只包含日期</p>
<p>检索某一段日期的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,order_num <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> <span class="type">Date</span>(order_date) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2005-09-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2005-09-30&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,order_num <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> <span class="keyword">Year</span>(order_date)<span class="operator">=</span><span class="number">2005</span> <span class="keyword">AND</span> <span class="keyword">Month</span>(order_date)<span class="operator">=</span><span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p><strong>数值处理函数：</strong></p>
<p><img src="image-20230206141447396.png" /></p>
<h2 id="第12章-汇总数据">第12章 汇总数据</h2>
<h3 id="avg">AVG()</h3>
<p>对表中特定列或特定行的平均值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id<span class="operator">=</span><span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<p>对多个列分别求平均值需要使用多个AVG()函数</p>
<h3 id="count">COUNT()</h3>
<p>计数</p>
<p>COUNT(*)对行数目进行计数</p>
<p>COUNT(column)对列中有值的进行计数，<strong>忽略NULL</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(cust_email) <span class="keyword">AS</span> num_cust <span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>
<h3 id="maxmin">MAX()/MIN()</h3>
<p>要求指定列名，<strong>忽略NULL</strong></p>
<h3 id="sum">SUM()</h3>
<p>返回指定列值的总和，也可以合计 计算值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> items_ordered <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num<span class="operator">=</span><span class="number">20005</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(item_price<span class="operator">*</span>quantity) <span class="keyword">AS</span> total_price <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num<span class="operator">=</span><span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<h3 id="聚集不同值">聚集不同值</h3>
<p>在上述函数中使用DISTINCT关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> vend_id<span class="operator">=</span><span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<p><strong>DISTINCT只能用于列名，不能用于计算或表达式</strong></p>
<h2 id="第13章-分组数据">第13章 分组数据</h2>
<p>GROUP BY子句创建分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP
BY子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列
中有多行NULL值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
<li>GROUP BY子句可以包含任意数目的列。</li>
</ul>
<p>HAVING子句过滤分组</p>
<p><strong>WHERE过滤的是行，HAVING过滤的是分组，（WHERE在分组前过滤数据，HAVING在分组后过滤数据）HAVING支持所有WHERE操作符</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> orders <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_price<span class="operator">&lt;=</span><span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span>;<span class="operator">/</span><span class="operator">/</span>有<span class="number">2</span>个以上价格为<span class="number">10</span>以上的产品的供应商，返回 <span class="number">1003</span> <span class="number">4</span>、<span class="number">1005</span> <span class="number">2</span>两组</span><br><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span>;<span class="operator">/</span><span class="operator">/</span>返回四组，没有过滤价格为<span class="number">10</span>以上</span><br></pre></td></tr></table></figure>
<h2 id="第14章-使用子查询">第14章 使用子查询</h2>
<p>一般来说子查询最好不要嵌套太多层</p>
<h2 id="第15章-联结表">第15章 联结表</h2>
<p>关系表的设计就是要保证把信息分解成多个表，一类数据
一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p>
<p>外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>使用联结可以将储存在多个表中的数据通过单条SELECT语句检索出，联结不是物理实体，存在于查询的执行当中。</p>
<p>创建联结：规定要联结的所有表以及如何关联即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price <span class="keyword">FROM</span> vendors,products <span class="keyword">WHERE</span> vendors.vend_id<span class="operator">=</span>products.vend_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name,prod_name;</span><br></pre></td></tr></table></figure>
<p>vend_name在一个表中，prod_name和prod_price在另一个表中；WHERE子句联结两个表，这里需要完全限定列名，避免出现二义性。<strong>应该保证所有联结都有正确的WHERE子句。</strong></p>
<p>以下内部联结语法返回同样的内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price <span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products <span class="keyword">ON</span> vendors.vend_id<span class="operator">=</span>products.vend_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name,prod_name;</span><br></pre></td></tr></table></figure>
<p>联结表的数目没有限制，基本规则也相同，首先列出所有表，然后定义表之间的关系</p>
<p><strong>但是不要联结不必要的表，联结越多性能下降越多。</strong></p>
<h2 id="第16章-创建高级联结">第16章 创建高级联结</h2>
<p><strong>使用表别名：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_concat <span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o,orderitems <span class="keyword">AS</span> oi <span class="keyword">WHERE</span> c.cust_id<span class="operator">=</span>o.cust_id <span class="keyword">AND</span> oi.order_num<span class="operator">=</span>o.order_num <span class="keyword">AND</span> prod_id<span class="operator">=</span><span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>自联结：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查找ID为DTNTR物品的供应商生产的其他物品</span><br><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name <span class="keyword">FROM</span> products WHRER vend_id<span class="operator">=</span>(<span class="keyword">SELECT</span> vend_id <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_id<span class="operator">=</span><span class="string">&#x27;DTNTR&#x27;</span>);<span class="operator">/</span><span class="operator">/</span>子查询</span><br><span class="line"><span class="keyword">SELECT</span> p1.prod_id,p1.prod_name <span class="keyword">FROM</span> products <span class="keyword">AS</span> p1,products <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.vend_id<span class="operator">=</span>p2.vend_id <span class="keyword">AND</span> p2.prod_id<span class="operator">=</span><span class="string">&#x27;DTNTR&#x27;</span>;<span class="operator">/</span><span class="operator">/</span>自联结查询，别名表解决二义性问题</span><br></pre></td></tr></table></figure>
<p>有时候处理联结远比处理子查询快得多。应该试一
下两种方法，以确定哪一种的性能更好。</p>
<p><strong>自然联结：</strong></p>
<p>标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。<strong>自然联结排除多次出现，使每个列只返回一次。</strong></p>
<p><strong>外部联结：</strong></p>
<p>内部联结关联两个表中有关系的行，外部联结还包括没有关联的行</p>
<p>使用OUTER
JOINT时必须用RIGHT或LEFT指定包括其所有行的表，RIGHT指出右边的表包含所有行，LEFT指出左边。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id,orders.order_num <span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> customers.cust_name,customers.cust_id,<span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord <span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> customers.cust_name,customers.cust_id,<span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord <span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<h2 id="第17章-组合查询">第17章 组合查询</h2>
<p>UNION规则：</p>
<ul>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔</li>
<li>UNION中的每个查询必须包含相同的列、表达式或聚集函数</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型</li>
</ul>
<p>UNION从查询结果集中自动去除重复的行，如果要保留可以使用UNION ALL</p>
<p><strong>在用UNION组合查询时，只 能使用一条ORDER
BY子句，它必须出现在最后一条SELECT语句之后，但用来排序所有SELECT语句返回的结果</strong></p>
<h2 id="第18章-全文本搜索">第18章 全文本搜索</h2>
<p><strong>并非所有引擎都支持全文本搜索，InnoDB不支持但MyISAM支持</strong></p>
<p>一般在创建表时启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO INCREMENT,</span><br><span class="line">    prod_id <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_date datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    note_text text <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>
<p><strong>不要在导入数据时使用FULLTEXT</strong>.
更新索引要花时间，如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然
后再修改表，定义FULLTEXT。</p>
<p>索引之后使用Match()和Against()执行全文本搜索，前者指定被搜索的列，后者指定要使用的搜索表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="image-20230207163251844.png" /></p>
<p>两行含有rabbit，被返回</p>
<p><strong>传递给Match()的值必须和FULLTEXT()中定义的相同，如果指定多个列必须列出它们且次序正确</strong></p>
<p>全文本搜索结果的排序返回以文本匹配的良好程度决定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text, <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;rabbit&#x27;</span>) <span class="keyword">AS</span> score <span class="keyword">FROM</span> productnotes;</span><br></pre></td></tr></table></figure>
<p>Match(note_text)Against('rabbit')建立了一个计算列包含全文本搜索计算出的匹配度，该得分由行中词的数目、唯一词的数目、整个索引中词的数目以及包含该词的行的数目计算得出。</p>
<p><strong>查询扩展（version&gt;=4.1.1）：</strong></p>
<p>举例：找出包含词anvils的注释与其他有关行（可能不包含该词）</p>
<p>MySQL执行过程：</p>
<ul>
<li>执行一个基本的全文本搜索，找出所有匹配搜索条件的行</li>
<li>检查这些行选择所有有用的词</li>
<li>用原来条件+有用的词再执行一次全文本搜索</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br></pre></td></tr></table></figure>
<p>查询扩展极大地增加了返回的行数，但这样做也增加了
你实际上并不想要的行的数目。</p>
<p>表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好。</p>
<p><strong>布尔文本搜索：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;heavy -rope*&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);<span class="operator">/</span><span class="operator">/</span>匹配包含heavy但不包含任意以rope开始的词的行</span><br></pre></td></tr></table></figure>
<p><img src="image-20230207171628475.png" /></p>
<p><strong>在布尔方式中，不按等级值降序排序返回的行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;+rabbit +bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);<span class="operator">/</span><span class="operator">/</span>包含rabbit和bait的行</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;rabbit bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);<span class="operator">/</span><span class="operator">/</span>包含rabbit或bait的行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;&quot;rabbit bait&quot;&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);<span class="operator">/</span><span class="operator">/</span>包含短语rabbit bait的行</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;&gt;rabbit &lt;bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);<span class="operator">/</span><span class="operator">/</span>包含rabbit或bait的行，前者优先级提高，后者优先级降低</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> note_text <span class="keyword">FROM</span> productnotes <span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text)Against(<span class="string">&#x27;+safe +(&lt;companion)&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);<span class="operator">/</span><span class="operator">/</span>包含safe和companion的行，前者优先级提高，后者优先级降低</span><br></pre></td></tr></table></figure>
<h2 id="第19章-插入数据">第19章 插入数据</h2>
<p><strong>插入完整的行：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;Pep E. LaPew&#x27;</span>,<span class="string">&#x27;100 Main Street&#x27;</span>,<span class="string">&#x27;Los Angeles&#x27;</span>,<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;90046&#x27;</span>,<span class="string">&#x27;USA&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>各个列必须以它们在表定义中出现的次序填充</strong></p>
<p>上面语法简单但并不安全，高度依赖表中列的定义次序，更安全的方法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;Pep E. LaPew&#x27;</span>,<span class="string">&#x27;100 Main Street&#x27;</span>,<span class="string">&#x27;Los Angeles&#x27;</span>,<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;90046&#x27;</span>,<span class="string">&#x27;USA&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>MySQL将用VALUES列表中的相应值填入列表中的对应项</p>
<p>如果列定义为允许NULL值切表定义中给出默认值，则在插入操作中可以省略这些列。</p>
<p>INSERT LOW-PRIORITY INTO可以降低插入的优先级</p>
<p><strong>插入多个行：</strong></p>
<p>VALUES中间用逗号分隔，每组值用一对圆括号括起来</p>
<p><strong>单条语句多个插入比使用多条语句快</strong></p>
<p><strong>插入检索出的数据：</strong></p>
<p>将SELECT语句的结果插入表中</p>
<p>假设想从另一个表中的客户列表合并到现有的customers表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(...) <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> custnew;</span><br></pre></td></tr></table></figure>
<p>...中的列名不一定要求匹配，两个位置的...分别对应</p>
<h2 id="第20章-更新和删除数据">第20章 更新和删除数据</h2>
<p>UPDATE语句更新表中所有行或特定行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers <span class="keyword">SET</span> cust_email<span class="operator">=</span><span class="string">&#x27;elmer@fudd.com&#x27;</span>,cust_name<span class="operator">=</span><span class="string">&#x27;The Fudds&#x27;</span> <span class="keyword">WHERE</span> cust_id<span class="operator">=</span><span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p>以要更新的表名开始，SET赋新值，WHERE指定要更新的行</p>
<p>UPDATE IGNORE可以在更新多行时即便发生错误也可以继续更新</p>
<p>DELETE从表中删除行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id<span class="operator">=</span><span class="number">10006</span>;</span><br></pre></td></tr></table></figure>
<p>如果要删除表中所有行，可以使用TRUNCATE
TABLE语句，该语句删除原来的表并重新创建一个，所以速度更快。</p>
<h2 id="第21章-创建和操纵表">第21章 创建和操纵表</h2>
<h3 id="创建表">创建表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(</span><br><span class="line">    cust_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    cust_address <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    cust_city <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    cust_state <span class="type">char</span>(<span class="number">5</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    cust_zip <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    cust_country <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    cust_contact <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    cust_email <span class="type">char</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (cust_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>主键必须唯一，如果使用单个列则值必须唯一；如果使用多个列则列的组合值必须唯一，主键不允许NULL值的列。</p>
<p>AUTO_INCREMENT告诉MySQL，本列每增加一行时自动对该列增量赋予该行一个可用值。</p>
<p><strong>每个表只允许一个AUTO_INCREMENT列，而且必须被索引（如，通
过使它成为主键）</strong></p>
<p>获得AUTO_INCREMENT列的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_insert_id();</span><br></pre></td></tr></table></figure>
<p><strong>指定默认值：</strong></p>
<p>在CREATE TABLE时列定义中用DEFAULT关键字指定</p>
<p><strong>与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</strong></p>
<p><strong>引擎类型：</strong></p>
<p><img src="image-20230208101639289.png" /></p>
<p><strong>外键不能跨引擎，即使用一个引擎的表不能引用使用不同引擎的表的外键</strong></p>
<h3 id="更新表">更新表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors <span class="keyword">ADD</span> vend_phone <span class="type">CHAR</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone <span class="type">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>ALTER TABLE之后给出要改的表名，所做更改的列表</p>
<p>ALTER TABLE定义外键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders <span class="keyword">FOREIGN</span> KEY(order_num) <span class="keyword">REFERENCES</span> orders;</span><br></pre></td></tr></table></figure>
<p><strong>使用ALTER
TABLE要极为小心，应该在进行改动前做一个完整的备份</strong></p>
<h3 id="删除表重命名表">删除表、重命名表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br><span class="line">RENAME <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> custermers, customers3 <span class="keyword">TO</span> custmers;</span><br></pre></td></tr></table></figure>
<h2 id="第22章-使用视图-mysql-5">第22章 使用视图（&gt;= MySQL 5）</h2>
<p>视图是虚拟的表。与包含数据的表不一样，<strong>视图只包含使用时动态检索数据的查询。</strong></p>
<h3 id="理解">理解</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact <span class="keyword">FROM</span> customers,orders,orderitems <span class="keyword">WHERE</span> customers.cust_id<span class="operator">=</span>orders.cust_id <span class="keyword">AND</span> orderitems.order_num<span class="operator">=</span>orders.order_num <span class="keyword">AND</span> prod_id<span class="operator">=</span><span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>该查询检索订购了某个特定产品的用户。</p>
<p>如果把整个查询包装成一个虚拟表名为productcustomers，则检索相同数据的语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact <span class="keyword">FROM</span> productcustomers <span class="keyword">WHERE</span> prod_id<span class="operator">=</span><span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>视图本身不包含数据，在添加或更改底层表中的数据时，视图将返回改变后的数据</strong></p>
<h3 id="规则和限制">规则和限制</h3>
<ul>
<li>唯一命名。</li>
<li>必须具有足够的访问权限才能创建视图。</li>
<li>可以嵌套。</li>
<li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也 含有ORDER
BY，那么该视图中的ORDER BY将被覆盖。</li>
<li>不能索引，也不能有关联的触发器或默认值</li>
<li>可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。</li>
</ul>
<h3 id="使用视图">使用视图</h3>
<ul>
<li>CREATE VIEW创建视图</li>
<li>DROP VIEW删除视图</li>
<li>SHOW CREATE VIEW查看创建视图的语句</li>
<li>更新视图时可以先DROP再CREATE，也可直接用CREATE OR REPLACE VIEW</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS </span><br><span class="line">SELECT cust_name,cust_contact FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id AND orderitems.order_num=orders.order_num AND prod_id=&#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>
<p>可以对视图进行更新（INSERT/UPDATE/DELETE），其实是对其基表进行更新</p>
<p>但是如果视图定义中有<strong>分组、联结、子查询、并、聚集函数、DISTINCT、导出列</strong>则不能更新视图（MySQL5中）</p>
<h2 id="第23章-使用存储过程mysql5">第23章 使用存储过程(MySQL5)</h2>
<h3 id="基本">基本</h3>
<p>存储过程简单来说，就是为以后的使用而保存
的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<p>执行存储过程（调用）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(<span class="variable">@pricelow</span>,<span class="variable">@pricehigh</span>,<span class="variable">@priceaverage</span>);<span class="operator">/</span><span class="operator">/</span>计算并返回产品最低、最高、平均价格</span><br></pre></td></tr></table></figure>
<p>创建存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> priceaverage <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在命令行执行上述过程可以先用DELIMITER
//更改分隔符为//，这样可以保留存储过程中的分号</strong></p>
<p>删除存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> productpricing;</span><br></pre></td></tr></table></figure>
<h3 id="使用参数">使用参数</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(<span class="keyword">OUT</span> pl <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">                               <span class="keyword">OUT</span> ph <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">                               <span class="keyword">OUT</span> pa <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(prod_price) <span class="keyword">INTO</span> pL</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">INTO</span> ph</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">INTO</span> pa</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用IN参数传入</p>
<h2 id="第24章-使用游标mysql5">第24章 使用游标（MySQL5）</h2>
<p>有时，需要在检索出来的行中前进或后退一行或多行。这就是使用
游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询，
它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游
标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<h2 id="第25章-使用触发器mysql5">第25章 使用触发器（MySQL5）</h2>
<p>想要某条语句（或某些语句）在事件发生时自动执行（如每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确）</p>
<p>触发器是MySQL响应<strong>DELETE/INSERT/UPDATE语句</strong>而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）</p>
<h3 id="创建触发器">创建触发器</h3>
<p><strong>需要给出信息：唯一的触发器名、触发器关联的表、触发器应该相应的活动、触发器何时执行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> products <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> <span class="string">&#x27;Product added&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>代码对每个插入行执行，显示Product added</p>
<p><strong>视图不支持触发器</strong></p>
<p><strong>每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器</strong></p>
<p><strong>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL
将不执行AFTER触发器（如果有的话）</strong></p>
<h3 id="删除触发器">删除触发器</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure>
<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，
然后再重新创建</p>
<h3 id="使用触发器">使用触发器</h3>
<p><strong>INSERT触发器</strong>在INSERT语句执行之前或之后执行。需要知道以下几点：</p>
<ul>
<li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行</li>
<li>在BEFORE
INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li>
<li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.order_num <span class="keyword">INTO</span> <span class="variable">@P</span>;</span><br></pre></td></tr></table></figure>
<p>创建触发器newoeder，在新数据插入到orders表后，MySQL生成一个新订单号保存到order_num中，触发器取得值并返回</p>
<p>MySQL5后触发器不支持返回结果集，需要用一个变量接收输出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(order_date, cust_id) <span class="keyword">VALUES</span>(NOW(), <span class="number">10001</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@p</span>;</span><br></pre></td></tr></table></figure>
<p>通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）</p>
<p><strong>DELETE触发器</strong>在DELETE语句执行之前或之后执行。需要知道以下两点:</p>
<ul>
<li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行</li>
<li>OLD中的值全都是只读的，不能更新</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders (order_num,order_date,cust_id) 					<span class="keyword">VALUES</span>(OLD.order_num,OLD.order_date, OLD.cust_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">YEAR</span>(order_date) <span class="operator">=</span> <span class="number">2019</span>;</span><br></pre></td></tr></table></figure>
<p><strong>UPDATE触发器</strong>在UPDATE语句执行之前或之后执行。需要知道以下几点:</p>
<ul>
<li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值</li>
<li>在BEFORE
UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</li>
<li>OLD中的值全都是只读的，不能更新</li>
</ul>
<h2 id="第26章-管理事务处理">第26章 管理事务处理</h2>
<p><strong>并非所有引擎都支持事务处理</strong></p>
<p>事务处理（transaction
processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行</p>
<p>MySQL使用下面语句标识事务开始</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;<span class="operator">/</span><span class="operator">/</span>不为空</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;<span class="operator">/</span><span class="operator">/</span>开始事务</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;<span class="operator">/</span><span class="operator">/</span>清空该表</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;<span class="operator">/</span><span class="operator">/</span>表为空</span><br><span class="line"><span class="keyword">ROLLBACK</span>;<span class="operator">/</span><span class="operator">/</span>回退</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;<span class="operator">/</span><span class="operator">/</span>回退后表不为空</span><br></pre></td></tr></table></figure>
<p>事务处理用来管理INSERT、UPDATE和
DELETE语句。不能回退SELECT语句。（这样做也没有什么意义。）不能回退CREATE或DROP操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;<span class="operator">/</span><span class="operator">/</span>开始事务</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;<span class="operator">/</span><span class="operator">/</span>清空该表</span><br><span class="line"><span class="keyword">COMMIT</span>;<span class="operator">/</span><span class="operator">/</span>提交事务</span><br></pre></td></tr></table></figure>
<p><strong>当COMMIT或ROLLBACK执行后，事务会自动关闭</strong></p>
<p>更复杂的事务处理可能需要部分提交或回退，这样做需要在事务处理块的合适位置放置占位符，如果需要回退可以回退到某个占位符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span>;<span class="operator">/</span><span class="operator">/</span>释放保留点</span><br></pre></td></tr></table></figure>
<p>保留点越多越好
可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，就越能按意愿灵活地进⾏回退。</p>
<h2 id="第28章-安全管理">第28章 安全管理</h2>
<p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">CREATE</span> USED ben INDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;p@$$w0rd&#x27;</span>;</span><br><span class="line">RENAME <span class="keyword">USER</span> ben <span class="keyword">TO</span> bforta;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> bforta;</span><br></pre></td></tr></table></figure>
<h2 id="第29章-数据库维护">第29章 数据库维护</h2>
<p>ANALYZE TABLE，用来检查表键是否正确</p>
<p>CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对
索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。
CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删
除的链接并进行键检验，QUICK只进行快速扫描。如下所示，CHECK
TABLE发现和修复问题</p>
<h2 id="第30章-改善性能">第30章 改善性能</h2>
<ul>
<li>如果你遇到显著的性能不良，可使用SHOW PROCESSLIST
显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li>
<li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句</li>
<li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快</li>
<li>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除
非你真正需要每个列）</li>
<li>LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE</li>
<li>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条
SELECT语句和连接它们的UNION语句，你能看到极大的性能改进</li>
<li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一
件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER
BY子句。如果一个简单的WHERE子句返回结果所花
的时间太长，则可以断定其中使用的列（或几个列）就是需要索 引的对象</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找模板</title>
    <url>/2023/04/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>二分查找</p>
<span id="more"></span>
<p>假设目标值在闭区间<span
class="math inline">\([l,r]\)</span>中，每次查找将区间长度缩小一半，当<span
class="math inline">\(l=r\)</span>时，找到目标值</p>
<p>模板1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bSearch1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bSearch2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板1就是在满足check()的区间内找到左边界，模板2在满足check()的区间内找到右边界。</p>
<p>如果目标是下面这个v，那麽就必须使用模板 1</p>
<p>................vooooooooo</p>
<p>假设经由 check 划分后，整个区间的属性与目标v如下，则我们必须使用模板
2</p>
<p>oooooooov...................</p>
<p>使用步骤：</p>
<ol type="1">
<li>确定check函数</li>
<li>根据check的结果看区间更新方式是要更新左界还是右界</li>
<li>如果是更新左界，则计算mid要+1</li>
</ol>
<p>求解立方根</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 0.0001f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">double</span> a;</span><br><span class="line">   <span class="keyword">while</span>(cin&gt;&gt;a)&#123;</span><br><span class="line">    <span class="type">double</span> l = <span class="built_in">min</span>(<span class="number">-1.0</span>,a);</span><br><span class="line">    <span class="type">double</span> r = <span class="built_in">max</span>(<span class="number">1.0</span>,a);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fabs</span>(r-l)&gt;eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid&lt;a)&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; fixed &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>大根堆</title>
    <url>/2023/04/12/%E5%A4%A7%E6%A0%B9%E5%A0%86/</url>
    <content><![CDATA[<p>大根堆的插入与删除操作</p>
<span id="more"></span>
<p>每个节点的值都大于等于其子节点的树为大根树</p>
<p>大根堆既是大根树也是完全二叉树</p>
<h3 id="插入操作">插入操作</h3>
<p>因为是完全二叉树，所以插入操作需要把元素插入新节点，然后沿着新节点到根节点的路径，执行起泡操作，直到父元素大于等于新元素，O(logn)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxHeap::push</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; ele)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heapSize==arr.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//内部数组已满，再插入新元素数组长度加倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> curNode = ++heapSize;</span><br><span class="line">    <span class="keyword">while</span>(curNode!=<span class="number">0</span>&amp;&amp;heap[curNode/<span class="number">2</span>]&lt;ele)&#123;</span><br><span class="line">        <span class="comment">//如果根节点小于插入元素</span></span><br><span class="line">        heap[curNode] = heap[curNode/<span class="number">2</span>];</span><br><span class="line">        curNode /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    heap[curNode] = ele;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作">删除操作</h3>
<p>大根堆中删除元素就是删除根节点的元素，删除之后需要进行重构。</p>
<p>将完全二叉树最后一个元素取出，删除该节点，把该元素插入到根节点中，在逐层将该元素沉底：选择左右孩子中较大的比该节点大的元素交换，直到满足大根堆要求。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树/前缀树（Trie）</title>
    <url>/2023/04/12/%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88Trie%EF%BC%89/</url>
    <content><![CDATA[<p>字典树的数据结构和常用操作</p>
<span id="more"></span>
<h2 id="基本操作">基本操作</h2>
<p>用于快速查询某个字符串/字符前缀是否存在</p>
<p>可以看作用边表示有无字符，用点记录是否为单词结尾和后续字符串是什么，从根节点到某一节点的路径代表了一个字符串</p>
<p><img
src="https://pic.leetcode-cn.com/1618369228-slAfrQ-IMG_1659.PNG" /></p>
<p>操作1：插入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    Trie* root = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> w : word)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children[w-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作2：查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    Trie* root = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> w : word)&#123;</span><br><span class="line">        <span class="type">int</span> i = w-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children[i]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;children[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作3：查询前缀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span></span>&#123;</span><br><span class="line">    Trie* root = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> w : word)&#123;</span><br><span class="line">        <span class="type">int</span> i = w-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children[i]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;children[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    Trie* children[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) children[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Trie</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(children[i]!=<span class="literal">NULL</span>) <span class="keyword">delete</span> children[i];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//搜索和插入都可以理解成构造边的过程，</span></span><br><span class="line">    <span class="comment">//插入中对字符串中每一个字符，初始化当前root的children，相当于生成对应该字符的一条边</span></span><br><span class="line">    <span class="comment">//搜索中可以理解成看所有的边是否都存在，如果有一条边不存在（遍历过程中子节点为NULL），</span></span><br><span class="line">    <span class="comment">//或者所有边都存在但最终节点之后还有连续的边（isEnd=false），则查找过程失败</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    	Trie* root = <span class="keyword">this</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> w : word)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(root-&gt;children[w-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            	root-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        	&#125;</span><br><span class="line">        	root = root-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">    	root-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    	Trie* root = <span class="keyword">this</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> w : word)&#123;</span><br><span class="line">        	<span class="type">int</span> i = w-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        	<span class="keyword">if</span>(root-&gt;children[i]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	root = root-&gt;children[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> root-&gt;isEnd;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span></span>&#123;</span><br><span class="line">    	Trie* root = <span class="keyword">this</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> w : prefix)&#123;</span><br><span class="line">        	<span class="type">int</span> i = w-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        	<span class="keyword">if</span>(root-&gt;children[i]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	root = root-&gt;children[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-211.-添加与搜索单词---数据结构设计">Leetcode 211. <a
href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">添加与搜索单词
- 数据结构设计</a></h2>
<p>请你设计一个数据结构，支持 添加新单词 和
查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<ul>
<li><p>WordDictionary() 初始化词典对象</p></li>
<li><p>void addWord(word) 将 word
添加到数据结构中，之后可以对它进行匹配</p></li>
<li><p>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回
true ；否则，返回 false 。word 中可能包含一些 '.' ，每个 .
都可以表示任何一个字母。</p></li>
</ul>
<blockquote>
<p>字典树的基础上加了一点变化，对插入还是先构建字典树，然后search的过程中，因为'.'可以匹配任何字符，则遍历出现'.'字符时当前节点的每一个子节点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TrieNode * root, <span class="type">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(node,word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(word,<span class="number">0</span>,node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(string word,<span class="type">int</span> cur_idx,TrieNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_idx==word.<span class="built_in">size</span>()) <span class="keyword">return</span> root-&gt;isEnd;</span><br><span class="line">        <span class="type">char</span> cur_char = word[cur_idx];</span><br><span class="line">        <span class="keyword">if</span>(cur_char==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">                TrieNode* tmp = root-&gt;children[i];</span><br><span class="line">                <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">                    <span class="type">bool</span> dfs_res = <span class="built_in">dfs</span>(word,cur_idx+<span class="number">1</span>,tmp);</span><br><span class="line">                    <span class="keyword">if</span>(dfs_res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TrieNode* tmp = root-&gt;children[cur_char-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(word,cur_idx+<span class="number">1</span>,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>额</title>
    <url>/2023/04/12/%E9%A2%9D/</url>
    <content><![CDATA[<p>之前的blog换电脑没了，吐了</p>
]]></content>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2023/04/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<ul>
<li><p>从a[0:n-1]中选择一个元素作为支点，组成中间段</p></li>
<li><p>把剩余元素分为左段left和右段right，使左段元素的关键字都不大于支点关键字；右段元素都不小于支点关键字</p></li>
<li><p>左段递归快速排序</p></li>
<li><p>右段递归快速排序</p></li>
<li><p>最终结果按左、中、右段排列</p>
<span id="more"></span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i = l,j = r;</span><br><span class="line">        <span class="type">int</span> tmp = s[l];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;s[j]&gt;=tmp)<span class="comment">//从右向左找第一个小于支点的元素</span></span><br><span class="line">                --j;</span><br><span class="line">            s[i] = s[j];<span class="comment">//小于支点的元素放在支点左侧</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;s[i]&lt;=tmp)<span class="comment">//从左向右找第一个大于支点的元素</span></span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) s[j] = s[i];</span><br><span class="line">		&#125;</span><br><span class="line">        s[l] = tmp;<span class="comment">//两次交换后空出了s[i]，填入支点元素</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition1</span>(A, low, high);</span><br><span class="line">     <span class="built_in">quickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">quickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
