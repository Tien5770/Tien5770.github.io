{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"leetcode刷题部分题解（2023.4.12之前）","text":"主要是链表相关的一些题目，也包含一些其他乱七八糟的 剑指offer 30. 包含min函数的栈 辅助栈，一个栈记录当前栈里的所有元素；另一个栈包含每次加入新元素时当前的最小值。 调用min函数时直接从辅助栈里返回栈顶元素。 pop时需要注意，如果原始栈顶的元素在辅助栈顶存在，则说明该元素被push时是一个最小值，同样需要被pop 1234567891011121314151617181920212223242526272829class MinStack {private: stack&lt;int&gt; originStack,minStack;public: /** initialize your data structure here. */ MinStack() { minStack.push(INT_MAX); } void push(int x) { if(x&lt;=minStack.top()) minStack.push(x); originStack.push(x); } void pop() { int tmp = originStack.top(); originStack.pop(); if(tmp==minStack.top()) minStack.pop(); } int top() { return originStack.top(); } int min() { if(minStack.top()!=INT_MAX) return minStack.top(); return minStack.top(); }}; 剑指offer 24. 反转链表 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 逐节点将next的关系反转即可，要做到这一点，需要做到如下步骤，假设输入链表中两个节点为prev和cur，且prev-&gt;next = cur： 先记录下当前节点的下一个节点tmp = cur-&gt;next; 反转两个节点的关系，即cur-&gt;next = prev; 继续处理下一组节点，更新prev = cur,cur = tmp; 根据以上的步骤，当cur在第一个节点时，prev应该为nullptr 123456789101112ListNode* reverseList(ListNode* head){ ListNode* cur = head; ListNode* prev = nullptr; while(cur){ ListNode* tmp = cur-&gt;next; cur-&gt;next = prev; prev = cur; cur = tmp; } return prev;} 剑指offer 35. 复制复杂的链表 链表中每个节点除了有next指向下一个节点之外，还有random指向一个随机节点。 复制过程中，在处理当前节点时，其random节点可能还没有生成，导致无法将二者连接 所以容易想到先遍历一遍，把每个节点对应的复制出来的新节点先存储起来，这个过程用哈希表存储。 然后在遍历一遍，这次遍历是对哈希表中存储的新节点（值）进行的，此时已经保证所有节点都生成了，将存储的所有节点next和random链接起来即可 1234567891011121314151617Node* copyRandomList(Node* head){ if(head==nullptr) return nullptr; unordered_map&lt;Node*,Node*&gt; mp; Node* cur = head; while(cur){ mp[cur] = new Node(cur-&gt;val);//复制新节点 cur = cur-&gt;next; } cur = head;//重新遍历新节点，此时相当于用原链表的节点做键去查找新节点 while(cur){ mp[cur]-&gt;next = mp[cur-&gt;next];//更新复制出来的节点的next关系 mp[cur]-&gt;random = mp[cur-&gt;random];//更新random关系 cur = cur-&gt;next; } return mp[head];} 节约空间：拼接+拆分 先将原链表每个节点之后复制一个新节点（完成复制所有节点） 访问原节点的random指向节点时，新节点为cur-&gt;next，由于每个节点对应的新节点都在其之后，所以其random指向节点应为cur-&gt;random-&gt;next（更新完所有random关系） 再遍历一遍链表，把旧节点拆分掉，两个链表设置好头节点然后间隔1个设置next关系即可（更新完所有next关系） 1234567891011121314151617181920212223242526272829Node* copyRandomList(Node* head){ if(head==nullptr) return nullptr; Node* cur = head; while(cur){ Node* tmp = new Node(cur-&gt;val); tmp-&gt;next = cur-&gt;next; cur-&gt;next = tmp; cur = tmp-&gt;next; } cur = head; while(cur){ if(cur-&gt;random){ cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; } cur = cur-&gt;next-&gt;next; } cur = head-&gt;next; Node* pre = head; Node* res = head-&gt;next; while(cur-&gt;next){ pre-&gt;next = pre-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; pre = pre-&gt;next; cur = cur-&gt;next; } pre-&gt;next = nullptr; return res;} 剑指offer 58. 左旋转字符串 将字符串前n个字符移动到字符串尾部 思路：字符串被分成了两部分，为了使这两部分的位置对调，可以考虑整体反转；但整体反转之后每部分的内部也发生了反转，所以先在每部分内部局部反转，再整体反转 123456789class Solution {public: string reverseLeftWords(string s, int n) { reverse(s.begin(),s.begin()+n); reverse(s.begin()+n,s.end()); reverse(s.begin(),s.end()); return s; }}; 类似题目：151. 反转字符串中的单词 给一个字符串s,反转其中单词的顺序 12输入：s = &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot; 思路是相同的，加上考虑原地反转降低空间复杂度至O(1) 1234567891011121314151617181920212223class Solution {public: string reverseWords(string s) { size_t k = 0;//k是负责原地复制反转的指针 size_t i = 0,j = 0;//i是探路的快指针，j是慢指针 while(1) { while(i&lt;s.size() &amp;&amp; s[i]==' ') i++;//快指针先去找所有连续的空格 if(i==s.size()) break;//快指针到结尾了，因为找空格是一次新的局部反转的开始，所以说明已经对最后一个单词做完了局部反转 j = i;//慢指针跟上，指到某个单词的开始位置 while(i&lt;s.size() &amp;&amp; s[i]!=' ') i++;//快指针继续找所有的单词字符 reverse(s.begin()+j,s.begin()+i);//局部反转 if(k!=0) s[k++] =' ';//k控制将所有单词从原字符串开头开始复制，所以如果k不在开头，要加一个空格将两个单词隔开 while(j!=i) s[k++] = s[j++];//复制反转后的单词 } s.erase(s.begin() + k,s.end());//擦除多余的空格 reverse(s.begin(),s.end());//全局反转 return s; }}; ![IMG_20230214_155323](C:\\Users\\er1so\\Documents\\Tencent Files\\540188512\\FileRecv\\MobileFile\\IMG_20230214_155323.jpg) 剑指offer 53 - I. 在排序数组中查找数字 I 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 以后排序数组的搜索先想想二分…… 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int leftRes = -1,rightRes = -1; int lb = 0,rb = nums.size()-1; //搜索最左边界 while(lb&lt;rb){ int mid = lb + (rb - lb) / 2; if(nums[mid]&gt;=target){ //搜最左边界时，如果大于等于target说明左边界不可能在mid右侧 rb = mid; } else{ lb = mid + 1; } } leftRes = lb; //搜索最右边界 lb = 0; rb = nums.size()-1; while(lb&lt;rb){ int mid = (lb+rb+1)&gt;&gt;1; if(nums[mid]&lt;=target){ //搜最右边界时，如果小于等于target说明有边界不可能在mid左侧 lb = mid; } else{ rb = mid-1; } } rightRes = lb; if(leftRes&gt;=0 &amp;&amp; leftRes&lt;nums.size() &amp;&amp; rightRes&gt;=0 &amp;&amp; rightRes&lt;nums.size() &amp;&amp; nums[rightRes]==target &amp;&amp; nums[leftRes]==target){ return rightRes - leftRes + 1; } return 0; }}; 剑指offer 53 - II. 0～n-1中缺失的数字 示例 1: 12输入: [0,1,3]输出: 2 示例 2: 12输入: [0,1,2,3,4,5,6,7,9]输出: 8 以后排序数组的搜索先想想二分…… 12345678910111213141516int missingNumber(vector&lt;int&gt;&amp; nums) { int lb = 0,rb = nums.size()-1; while(lb&lt;rb){ int mid = (lb+rb+1)&gt;&gt;1; if(nums[mid]=mid){ //如果mid的索引和元素值一致，说明其左边数字全是存在的，应该更新lb lb = mid; }else{ rb = mid-1; } } //当左边界与右边界相等时，可能已经指向该缺失的数字，但是还有一种可能是缺失的数字在数组之外 //正常应该return lb;，如果缺失数字则应该返回lb+1 if(nums[lb]!=lb) return lb; return lb+1;} 删除链表中倒数第N个结点 双指针 12345678910111213141516171819202122class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(0,head); ListNode* first = head; ListNode* second = dummy; int tmp = n-1; while(tmp){ first = first-&gt;next;//先把first移动n-1个位置，使first和second保持n-1的间距 tmp--; } while(first-&gt;next!=nullptr){ //同时移动直到first到达结尾节点，此时second指向待删除节点的前节点 first = first-&gt;next; second = second-&gt;next; } second-&gt;next = second-&gt;next-&gt;next; ListNode* res = dummy-&gt;next; delete dummy; return res; }}; 辅助栈 12345678910111213141516171819class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { stack&lt;ListNode*&gt; s; ListNode* dummy = new ListNode(0,head); ListNode* cur = dummy; while(cur){ s.push(cur); cur = cur-&gt;next; } for(int i = 0;i&lt;n;++i){ s.pop(); } ListNode* tmp = s.top(); tmp-&gt;next = tmp-&gt;next-&gt;next; ListNode* res = dummy-&gt;next; return res; }}; 剑指offer 04. 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617//n次二分class Solution {public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.size()==0||matrix[0].size()==0) return false; for(int i = 0;i&lt;matrix.size();i++){ int lb = 0,rb = matrix[0].size()-1; while(lb&lt;rb){ int mid = (lb+rb+1)&gt;&gt;1; if(matrix[i][mid]&lt;=target) lb = mid; else rb = mid-1; } if(matrix[i][lb]==target) return true; } return false; }}; 1234567891011121314//标志数class Solution {public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.size()==0||matrix[0].size()==0) return false; int i = 0,j = matrix[0].size()-1; while(i&lt;matrix.size()&amp;&amp;j&gt;=0){ if(matrix[i][j]&gt;target) j--; else if(matrix[i][j]&lt;target) i++; else return true; } return false; }}; 剑指offer 11. 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，称之为数组的旋转。 返回旋转数组的最小元素 因为「二分」的本质是二段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。 12345678910111213141516class Solution {public: int minArray(vector&lt;int&gt;&amp; nums) { int lb = 0,rb = nums.size()-1; while(lb&lt;rb &amp;&amp; nums[0]==nums[rb]) rb--; while(lb&lt;rb){ int mid = (lb+rb)&gt;&gt;1; if(nums[mid]&lt;=nums[rb]){ rb = mid; } else{ lb = mid+1; } } return nums[lb]; }}; 剑指offer 50. 第一个只出现一次的字符 1234567891011121314151617181920class Solution {public: char firstUniqChar(string s) { vector&lt;int&gt; keys;//记录keys被添加到哈希表里的顺序，第二次遍历直接按序遍历哈希表 unordered_map&lt;char,int&gt; mp; for(auto &amp;c :s){ if(mp.find(c)==mp.end()){ mp[c] = 1; keys.push_back(c); } else { mp[c]++; } } for(auto &amp;k : keys){ if(mp[k]==1) return k; } return ' '; }}; 12345678910111213141516171819class Solution {public: char firstUniqChar(string s) { queue&lt;char&gt; q; unordered_map&lt;char,int&gt; mp; for(auto&amp; c : s){ if(mp.find(c)==mp.end()){ mp[c] = 1; q.push(c); } else { //延迟删除，如果当前字符出现超过1次，但不在队首， //那么该字符不会影响最终结果，可以先不处理 mp[c]++; while(!q.empty() &amp;&amp; mp[q.front()]&gt;1) q.pop(); } } return q.empty()?' ':q.front(); }}; 求x的平方根 1234567891011121314151617181920//注意数据范围//这个地方虽然是求平方不超过x的最大的，但是该模板计算mid会溢出//所以改成求平方大于等于x的最小的，如果平方值为x则直接返回，否则-1class Solution {public: int mySqrt(int x) { if(x==0||x==1) return x; int lb = 1,rb = x; while(lb&lt;rb){ int mid = lb+(rb-lb)/2; if((long long)mid*mid&gt;=x){ rb = mid; } else if((long long)mid*mid&lt;x){ lb = mid+1; } } return (long long)lb*lb==(long long)x ? lb : lb-1; }}; 剑指offer 28. 对称的二叉树 123456789101112class Solution {public: bool check(TreeNode *p, TreeNode *q) { if (!p &amp;&amp; !q) return true; if (!p || !q) return false; return p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left); } bool isSymmetric(TreeNode* root) { return check(root, root); }}; 剑指offer 26. 树的子结构 要判断B是否是A的子结构，直接从根节点开始判断，递归比较每个节点即可 12345678910111213141516class Solution {public: bool isSubStructure(TreeNode* A, TreeNode* B) { if(A==nullptr||B==nullptr){ return false; } return contains(A,B); } bool contains(TreeNode* A, TreeNode* B){ if(B==nullptr) return true; //开始递归时保证了B不可能为空，此时B为空说明已经全部搜索完 if(A==nullptr||A-&gt;val!=B-&gt;val){ return false; } return contains(A-&gt;left,B-&gt;left) &amp;&amp; contains(A-&gt;right,B-&gt;right); }}; 但是，判断B是否是A的子结构，不一定从A的根节点开始判断 所以加入递归的条件，如果从根节点开始判断B不是A的子结构，那么再尝试从左右子树中判断 1234567891011121314151617class Solution {public: bool isSubStructure(TreeNode* A, TreeNode* B) { if(A==nullptr||B==nullptr){ return false; } return contains(A,B)||isSubStructure(A-&gt;left, B) ||isSubStructure(A-&gt;right, B) ; } bool contains(TreeNode* A, TreeNode* B){ if(B==nullptr) return true; //开始递归时保证了B不可能为空，此时B为空说明已经全部搜索完 if(A==nullptr||A-&gt;val!=B-&gt;val){ //B不为空但是A已经为空了，或者二者当前节点值不相等 return false; } return contains(A-&gt;left,B-&gt;left) &amp;&amp; contains(A-&gt;right,B-&gt;right); }}; 141. 环形链表 判断链表中是否有环 可以用哈希表记录是否出现过该节点判断 也可以用Floyd 判圈算法，假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 123456789101112131415161718class Solution {public: bool hasCycle(ListNode* head) { if (head == nullptr || head-&gt;next == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) { if (fast == nullptr || fast-&gt;next == nullptr) { return false; } slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return true; }}; 入环点位置分析 假设在紫色位置处快慢指针相遇 则慢指针走过a+ba+ba+b，快指针走过a+n(b+c)+b=a+(n+1)b+ca+n(b+c)+b=a+(n+1)b+ca+n(b+c)+b=a+(n+1)b+c 按照快慢指针的步幅关系，快指针的距离一定是慢指针的2倍 2(a+b)=a+(n+1)b+ca=(n−1)(b+c)+c2(a+b)=a+(n+1)b+c\\\\ a=(n-1)(b+c)+c 2(a+b)=a+(n+1)b+ca=(n−1)(b+c)+c 根据这个关系，在快慢指针相遇时，新指针ptr从链表头出发与慢指针以同样步幅移动，走过a到达入环点时，慢指针一定与其在入环点相遇 82. 删除排序链表中的重复元素 II 1234567891011121314151617181920class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(head==nullptr||head-&gt;next==nullptr) return head; ListNode* dummy = new ListNode(0,head); ListNode* cur = dummy; while(cur-&gt;next!=nullptr&amp;&amp;cur-&gt;next-&gt;next!=nullptr){ if(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val){ int tmp = cur-&gt;next-&gt;val; while(cur-&gt;next!=nullptr &amp;&amp; cur-&gt;next-&gt;val==tmp){ cur-&gt;next = cur-&gt;next-&gt;next; } } else{ cur = cur-&gt;next; } } return dummy-&gt;next; }};","link":"/2023/04/12/leetcode%E5%88%B7%E9%A2%98%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%882023-4-12%E4%B9%8B%E5%89%8D%EF%BC%89/"},{"title":"《C++ Primer》笔记（13-16章）","text":"《C++ Primer》 13-16章笔记 第13章 拷贝控制 拷贝构造函数、移动构造函数负责定义用同类型的另一个对象初始化本对象时做什么 拷贝赋值运算符、移动赋值运算符定义将同类型的另一个对象赋予同类型对象时做什么 析构函数定义了此类型对象销毁时做什么 拷贝、赋值与销毁 拷贝构造函数 构造函数+第一个参数是自身类类型的引用+任何额外参数都有默认值 拷贝函数在几种情况下都会被隐式的使用，因此拷贝函数不应该是explicit的 一般情况下，合成构造函数会将给定对象中每个非static参数成员逐个拷贝到正在创建的对象中。对类类型成员会使用其拷贝构造函数来拷贝；对内置类型成员则直接拷贝 拷贝初始化发生的情况： 用=定义变量时会发生 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 标准库容器初始化或是调用其insert或push成员 拷贝赋值运算符 赋值运算符通常应该返回一个指向其左侧运算对象的引用 将右侧对象中每个非static成员赋予左侧运算对象的对应成员 析构函数 释放对象使用的资源，销毁对象的非static数据成员 不能重载，每个类只有一个 析构函数首先执行函数体，然后销毁成员，按初始化顺序逆序销毁 销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。智能指针是类类型，具有析构函数，智能指针在析构阶段自动销毁 什么时候调用析构函数： 变量离开其作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器被销毁时，其中元素被销毁 动态分配的对象，对指向它的指针应用delete运算符被销毁时 对于临时对象，当创建它的完整表达式结束时被销毁 三/五法则 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符 需要拷贝操作的类也需要赋值操作，反之亦然 使用=default 在类内修饰成员声明时，会隐式的声明为内联的；如果不希望内联，应该仅在类外定义使用=default 阻止拷贝 例如，iostream类阻止了拷贝，避免多个对象写入或读取相同的IO缓冲 新标准下可以通过拷贝构造函数和拷贝赋值运算符定义为deleted function来阻止拷贝 123456struct NoCopy{ NoCopy()=default; NoCopy(const NoCopy&amp;)=delete; NoCopy &amp;operator = (const NoCopy&amp;)=delete; ~NoCopy()=default;} =delete必须出现在函数第一次声明的时候 可以对任何函数指定=delete，而只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default 析构函数不能是deleted function,否则，不能定义该类型的变量，也不能释放指向该类型动态分配对象的指针 合成的拷贝控制成员可能是deleted,如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为deleted function 拷贝控制和资源管理 行为像值的类：拷贝构造和拷贝赋值时对内部成员进行拷贝 行为像指针的类：拷贝构造拷贝赋值中使用shared_ptr的引用计数管理资源 交换操作 动态内存管理类 move函数，在utility头文件中 对象移动 移动而非拷贝对象在某些情况下会大幅提升性能 标准库容器、string和shared_ptr既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝 右值引用 回忆：左值和右值是表达式的属性，一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值 右值引用是必须绑定到右值的引用。我们通过&amp;&amp;获得右值引用。 右值引用有一个重要的性质：只能绑定到一个将要销毁的对象。 常规引用（左值引用）不能将其绑定到要求转换的表达式、字面常量或者返回右值的表达式上。右值引用可以，但不能直接将右值引用直接绑定到一个左值上 123456int i = 42;int &amp;r = i;//正确，左值引用int &amp;&amp;rr = i;//错误，i是个左值int &amp;r2 = i * 42;//错误，i*42是个右值const int &amp;r3 = i * 42;//正确，const引用可以绑定到右值上int &amp;&amp;rr2 = i * 42;//正确 进一步区分左值右值： 返回左值引用的函数，连同赋值、下标、解引用和前置递增、前置递减运算符，返回的都是左值表达式 返回非引用类型的函数，连同算术、关系、位、后置递增和后置递减运算符，都生成右值。可以将const左值引用或者右值引用绑定到这类表达式上 左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时对象。 变量是左值，即便该变量是右值引用类型它也是左值 标准库move函数： 显式地将一个左值转换为对应的右值引用类型，move函数可以获得绑定到左值上的右值引用 1int &amp;&amp;rr3 = std::move(rr1); 调用move意味着承诺除了对rr1赋值或者销毁之外，将不再使用它 使用move的代码应该使用std::move，这也可以避免潜在的名字冲突 移动构造函数和移动赋值运算符 让自己的类型支持移动操作，需要定义这两个成员 这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”而非拷贝资源 移动构造函数 移动构造函数的第一个参数是该类类型的一个引用，但是是右值引用。 移动构造函数除了完成资源移动外，还必须确保移动后源对象处于销毁无害的状态 移动构造函数不分配任何新内存 移动赋值运算符 必须正确处理自赋值。 移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。 合成的移动操作 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为之合成移动构造函数和移动赋值运算符了。 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。 如果拷贝构造和移动构造并存，根据构造或赋值传入参数的类型，处理方式是：移动右值，拷贝左值。但如果没有移动构造函数，右值也被拷贝 移动迭代器（cpp11） 移动迭代器解引用运算符生成的是一个右值引用 标准库的make_move_iterator函数可以将一个普通迭代器转换为一个移动迭代器。 原迭代器的所有其他操作在移动迭代器中都照常工作。 需要注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此只有在确信算法在为一个元素赋值或者将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法 右值引用和成员函数 12void push_back(const X&amp;);void push_back(X&amp;&amp;); 可以强制指出this指向的对象（左侧运算对象）的属性是左值或者右值，使用引用限定符&amp;或&amp;&amp;，位置在参数列表后放置 const限定和引用限定同时使用时，const限定必须在前 1234class F{public: Foo func() const &amp;;} 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符 第14章 重载运算与类型转换 基本概念 operator+要定义的运算符号 重载运算符函数的参数数量和运算符作用的运算对象数量一样多 除了operator()之外，其他重载运算符不能含有默认实参 如果一个运算符函数是成员函数，第一个运算对象绑定到隐式的this指针上，所以此时参数数量=运算符作用的运算对象-1 不能重定义内置类型的运算含义 重载运算符作为成员还是非成员函数的选择： 对于最后一条：如果重载被定义为类成员函数，那么左侧运算对象一定是所属类的一个对象。所以如果要使运算符有对称性，不应该定义为成员函数 比如string s = “hi” + s;是非法的，因为operator +被定义为string的类成员函数，该语句等价于“hi”.operator+(s);，而其类型为const char*，根本就无法调用。 输入和输出运算符 1ostream&amp; operator&lt;&lt;(ostream&amp; os,const X&amp; x); 第一个参数是非常量ostream对象的引用：非常量-&gt;向流写入内容会改变其状态；引用-&gt;流不允许拷贝。 输出运算符重载时尽量减少格式化操作，专注于输出对象的内容。使用户有权控制输出细节。 1istream&amp; operator&gt;&gt;(istream&amp; is,X&amp; x); 输入运算符必须处理可能的输入失败的情况，而输出运算符不需要 输入时可能发生下列错误： 流含有错误类型的数据读取操作时（输入和被赋值变量类型不匹配） 读取操作到达文件末尾或者遇到输入流的其他错误 输入运算符负责检测错误，同时从错误中恢复 算术和关系运算符 一般定义为非成员函数以允许对左侧或右侧对象进行转换 1X operator+(const X&amp; lhs,const X&amp; rhs); 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符: 123456X&amp; operator+=(const X&amp; rhs);X operator+(const X&amp; lhs,const X&amp; rhs){ X tmp = lhs; tmp+= rhs; return tmp;} 12bool operator==(const X&amp; lhs,const X&amp; rhs);bool operator!=(const X&amp; lhs,const X&amp; rhs); 相等运算符和不等运算符在实现中应该把具体工作委托给另外一个，而其只负责调用对方实现自身的功能。 对于关系运算符，如&lt;，如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑重载该运算符 如果类同时还包含==，则当且仅当&lt;定义和==产生的结果一致时才定义&lt;运算符 赋值运算符 1X&amp; X::operator=(initializer_list&lt;string&gt; il); 注意赋值运算符改变了左侧运算对象本身，按照之前的准则，应该定义为类成员函数，且返回左侧对象的引用。形参类型可以按照需求进行定义 复合赋值运算符也要返回左侧对象的引用。 下标运算符 12string&amp; operator[](size_t n);const string&amp; operator[](size_t n) const; 下标运算符必须是成员函数 如果一个类包含下标运算符，则通常会定义两个版本：一个返回普通引用，一个是类的常量成员并且返回常量引用 递增和递减运算符 建议设定为成员函数，要同时定义前置版本和后置版本 前置版本 12X&amp; operator++();X&amp; operator--(); 后置版本 为了区分前置盒后置版本，在后置重载的生命中增加一个额外的int形参，但该形参不会被使用。调用后置运算符时，编译器会为这个形参提供一个值为0的实参 123456X X::operator++(int){ X tmp = *this; ++*this; return tmp;}X operator--(int); 后置版本的实现可以调用前置版本来完成实际工作 因为内置的后置递增递减运算符返回的时对象运算之前的值，所以后置版本的重载返回类型设置为值类型。 成员访问运算符 箭头运算符完成的是解引用+成员访问 箭头运算符必须是类的成员，解引用运算符不必须是类的成员，但一般也设置为类的成员。 成员访问一般不会改变对象状态，所以重载函数定义为const成员， 1234string&amp; operator*() const;string* operator-&gt;() const{ return &amp;this-&gt;operator*();} 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象 函数调用运算符 如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象 12345678struct absInt{ int operator()(int val) const{ return val&lt;0?-val:val; }};int i = -42;absInt absObj;int ui = absObj(i); 如果类定义了调用运算符，则该类的对象称作函数对象 函数对象类中的包含的其他数据数据成员可以被用于定制调用运算符中的操作（比如定义一个打印字符串类，重载operator()，数据成员中有分隔符可以使用） 函数对象常常作为泛型算法的实参 lambda是函数对象 编写一个lambda后，编译器将表达式翻译为一个未命名类的对象，该类中含有一个重载的函数调用运算符。在默认情况下，该类的函数调用运算符是一个const成员函数 如果lambda的捕获变量为值捕获，这种类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数并初始化数据成员 标准库定义的函数对象 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，在functional头文件中 123plus&lt;int&gt; intAdd;int sum = intAdd(1,2);sort(v.begin(),v.end(),greater&lt;int&gt;()) 标准库规定其函数对象对于指针也同样适用。 可调用对象与function C++中可调用的对象：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。 调用形式（call signature）指明返回类型以及传递给调用的实参类型，一种调用形式对应一个函数类型。不同类型可能具有相同的调用形式 下面几个可调用对象共用一种调用形式 12345678//int(int,int)int add(int i,int j){return i+j;}auto mod = [](int i,int j){return i%j;}struct divide{ int operator()(int de,int di){ return de/di; }}; function定义于functional头文件中，是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，该信息表示对象的调用形式 1function&lt;int(int,int)&gt;; 1234function&lt;int(int,int)&gt; f1 = add;function&lt;int(int,int)&gt; f2 = divide();function&lt;int(int,int)&gt; f3 = [](int i,int j){return i*j;};cout&lt;&lt;f1(4,2)&lt;&lt;endl; 重载的函数与function 不能直接将重载函数的名字存入function类型的对象中，会产生二义性问题 解决方法：存储函数指针、使用lambda消除二义性 重载、类型转换与运算符 类型转换运算符 负责将一个类类型的值转换成其他类型 1operator type() const;//一般形式，type指某种类型 可以面向除void之外的任意类型进行定义，只要该类型能作为函数的返回类型 不允许转换成数组或者函数类型 允许转换为指针或者引用类型 没有显式的返回类型，没有形参 必须定义为类的成员函数 显式的类型转换运算符——explicit 声明为explicit之后，只能通过显式的请求进行类型转换 123SmallInt si = 3;si+3;//错误static_cast&lt;int&gt;(si)+3;//正确 避免含有二义性的类型转换 如果类中包含一个或多个类型转换，必须确保在类类型和目标类型之间只存在唯一一种转换方式。 考虑以下情况： A类中包含以B类为参数的转换构造函数，B类中存在转换成A类型的类型转换运算符。如果有以下语句 12345B b;A f(const A&amp;){ ...}A a = f(b); 则会产生二义性，因为不知道应该使用哪种方式将B类型的b转换为A类型 如果确实想执行该调用，就必须显式指明调用的类型转换方式 12A a1 = f(b.operator A());A a2 = f(A(b)); 无法使用强制类型转换来解决二义性 再考虑以下情况，类中定义的一组类型转换，其转换源或转换目标类型本身可以通过其他类型转换联系在一起 123456789101112struct A{ A(int = 0);//最好不要创建两个转换源都是算术类型的类型转换 A(double); operator int() const;//最好不要创建两个转换目标都是算术类型的类型转换 operator double() const; ...};void f2(long double);A a;f2(a);//二义性错误，f(A::operator int())或f(A::operator double())long lg;A a2(lg);//二义性错误，f(A::A(int))或f(A::A(double)) 根本原因是上述调用中所需要的标准类型转换级别一致 重载函数与转换构造函数 再考虑以下情况，二义性问题会进一步加重 123456789struct C{ C(int);};struct D{ D(int);};void manip(const C&amp;);void manip(const D&amp;);manip(10); 在传入实参时显式地构造类型可以消除二义性，但出现这种情况通常表示程序设计存在问题。 函数匹配与重载运算符 表达式中运算符的候选函数集既包括成员函数，也包括非成员函数 如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载运算符，会产生二义性问题 第15章 面向对象程序设计 OOP概述 核心思想：数据抽象、继承和动态绑定 数据抽象：将类接口和实现分离 继承：定义相似的类型并对其相似关系建模 动态绑定：一定程度上忽略相似类型的区别，以统一的方式使用其对象 基类、派生类 基类负责定义在层次关系中所有类共有的成员。每个派生类定义各自特有的成员 对于某些函数，基类希望其派生类各自定义适合自身的版本，此时基类将这些函数声明为虚函数。派生类必须在其内部对所有重新定义的虚函数进行声明 动态绑定 函数的运行版本由实参决定，即在运行时选择函数的版本 在CPP中，当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定 定义基类和派生类 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作 基本知识 成员函数与继承 基类的成员函数可以被分为两种： 希望派生类进行**覆盖（override）**的函数 希望派生类直接继承而不改变的函数 对于前者，基类通常将其定义为虚函数。当使用指针或者引用调用虚函数时，该调用将被动态绑定。根据指针或引用所绑定的对象类型不同，调用基类的版本或者派生类的版本 虚函数声明：virtual关键字，只能出现在类内部的声明语句而不能用于外部的函数定义 虚函数范围：任何构造函数之外的非静态函数都可以是虚函数 非虚函数的解析过程发生在编译时而非运行时 派生类的声明形式 使用类派生列表明确指出从哪个类继承而来 声明时不能包含派生列表 12class Bulk_quote;//声明class Bulk_quote : public Quote{...}; 派生类中的虚函数 如果派生类没有覆盖基类中某个虚函数，则该虚函数的行为类似于其他的普通成员。派生类会直接继承其在基类中的版本 派生类可以在覆盖的函数前使用virtual关键字，但不是必须 也可以在形参列表后边添加override关键字，override的次序在const后面或引用限定符&amp;、&amp;&amp;后面 派生类对象及派生类向基类的类型转换 编译器隐式执行派生类到基类的转换 12345Quote item;Bulk_quote bulk;Quote* p = &amp;item;p = &amp;bulk;Quote&amp; r = bulk; 能够进行转换的原因是每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该部分上。所以不存在基类向派生类的自动类型转换。 判断基类和派生类转换是否可行看的是被转换对象静态类型，因为编译器只能检查静态类型来推断转换是否合法。dynamic_cast请求类型转换的安全检查将在运行时执行。static_cast的转换可以强制覆盖掉编译器的检查工作。使用时要确保转换是安全的。 注意，派生类向基类之间的自动类型转换只对指针或引用类型有效。对于对象之间的转换，其实是调用了构造函数或者赋值运算符，一个对象作为参数传入，在该过程中发生了类型转换。 派生类构造函数 对于从基类中继承而来的成员，派生类必须使用基类的构造函数来初始化，即每个类控制它自己的成员初始化过程。 初始化顺序：初始化基类部分，按照声明顺序依次初始化派生类成员 派生类使用基类成员 可以访问基类的公有成员和受保护成员 继承与静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少派生类。 静态成员也遵循访问控制规则，即如果在基类中是private的，则派生类无权访问 1234567891011121314class Base{public: static void statemem();};class Derived : public Base{ void f(const Derived&amp;);};void Derived::f(cosnt Derived&amp; obj){ //以下访问都是合法的 Base::statemem(); Derived::statemem(); obj.statemem(); statemem();} 被用作基类的类 如果某个类被用作基类，则该类必须已经定义而非仅仅声明 直接基类、间接基类 防止继承的发生 C++11新标准，在类名后跟一个关键字final 类型转换与继承 之前提到，可以将基类的指针（包括智能指针）或引用绑定到派生类对象上，说明当使用基类指针时，实际上所绑定对象的真实类型可能是基类类型，也可能是派生类类型 静态类型与动态类型 静态类型：编译时已知，是在变量声明时的类型或表达式生成的类型 动态类型：运行时可知，是变量或表达式表示的内存中对象的类型 如果表达式既不是指针也不是引用，则动态类型和静态类型永远一致。 虚函数 总结： 这一节内容比较琐碎，可以大致分为三个： 虚函数在基类中的定义，需要virtual关键字，含义为想要子类去覆盖的函数 虚函数的通过指针或者引用的调用在运行时才会被解析，由此产生了本节中的默认实参或回避虚函数机制等小知识点 虚函数在派生类在的定义形式 其中最重要的是第二点，动态绑定 虚函数的调用在运行时才被解析 由于虚函数在运行时才能确定调用了哪个版本，所以所有虚函数都必须有定义。 动态绑定只有当通过指针或者引用调用虚函数时才会发生，如果使用普通类型的表达式调用虚函数时，编译时就会确定实际调用的版本。 派生类中的虚函数 不是必须加virtual关键字 如果在派生类中覆盖继承过来的虚函数，需要保持形参类型的完全一致 返回类型也必须匹配，除了一个例外情况：返回类型是类本身的引用或指针时 final和override说明符 override关键字说明派生类中的虚函数，好处是使得程序员的意图更加清晰（说明这个函数是虚函数的覆盖，而不是重载的新函数），并且让编译器可以发现一些错误 1234567891011struct B{ virtual void f1(int) const; virtual void f2(); void f3();};struct D1 : B{ void f1(int) const override; void f2(int) override;//错误，覆盖的虚函数一定要参数匹配，被认为是一个新函数 void f3() override;//错误，只有虚函数才能覆盖 void f4() override;//错误}; final关键字作用是禁止后续任何尝试覆盖该函数的操作 1234567struct D2 : B{ void f1(int) const final;//后续的继承不允许覆盖f1};struct D3 : D2{ void f2(); void f1(int) const;//错误} override和final说明符出现在形参列表和尾置返回类型之后 虚函数与默认实参 默认实参的判定是根据实际运行的函数版本中的默认实参来判定的。 如果虚函数使用默认实参，则基类与派生类中定义的默认实参最好一致。 回避虚函数的机制 某些情况下，希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本 方法：使用作用域运算符 1double undiscounted = baseP-&gt;Quote::net_price(42); 通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的机制 抽象基类 纯虚函数 引入目的： 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 纯虚函数实际上告诉用户（程序员）当前函数是没有实际意义的，并且告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。 纯虚函数无须定义，在函数声明语句最后加=0即可说明该函数为纯虚函数 =0只能出现在类内部的虚函数声明语句处 虚函数和纯虚函数 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。 定义一个函数为纯虚函数，才代表函数没有被实现（虽然纯虚函数也可以被定义，但从从目的上分析就是没有实现）。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 抽象基类 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 抽象基类负责定义接口，后续其他类可以覆盖接口 不能直接创建一个抽象基类的对象 值得注意的是。可以为纯虚函数提供定义，但函数体必须定义在类的外部。 访问控制和继承 protected 对用户而言不可访问 对派生类成员和友元来说可访问 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对象对基类对象中的受保护成员没有任何访问特权 对于最后一条，考虑如下例子 1234567891011class B{protected: int prot_mem;};class D : public B{ friend void f(D&amp;); friend void f(B&amp;); int j;};void f(D&amp; d){d.j = d.prot_mem = 0;}//正确void f(B&amp; b){b.prot_mem = 0}//错误 继承来的成员访问权限的影响来自两方面：1.成员在基类中的访问说明符 2.在派生类的派生列表中的访问说明符 派生访问说明符对派生类的成员和友元能否访问其直接基类的成员没什么影响，其目的是控制派生类用户（使用者和派生类的派生类）对基类成员的访问权限 原本访问权限\\继承方式 public继承方式 protected继承方式 private继承方式 public public protected private protected protected protected private private 不可用 不可用 不可用 上表中，比如原本在基类中为public成员，派生类通过private继承后，在派生类中的访问权限变为private，在非成员函数调用时或者进一步派生时变得不可访问 派生类向基类转换的可访问性 友元与继承 友元关系不能继承，每个类负责控制各自成员的访问权限 A类的友元不能访问A类派生类的private成员，但是可以访问派生类的基类部分（即派生类中基类部分由基类本身控制）；A类友元的派生类也不能访问A类的private成员。 改变个别成员的可访问性 123456789101112class B{public: size_t size() const {return n;}protected: size_t n;};class D:private B{public: using Base::size;protected: using Base::n;}; 本来size和n是D的私有成员，然而现在使用using语句改变了这些成员的可访问性 派生类只能为那些它可以访问的名字提供using声明 默认的继承保护级别 struct默认public继承，class默认private继承 继承中的类作用域 编译时的名字查找 即使动态类型和静态类型可能不一致，但能使用哪些成员仍然是由静态类型决定的 继承中的名字冲突 派生类的成员将隐藏同名的基类成员 可以使用作用域运算符来使用隐藏的成员 除了覆盖继承而来的虚函数之外，最好不要在派生类中重用其他定义在基类中的名字 从上图可知，名字查找先于类型检查 虚函数与作用域 只有基类和派生类中的虚函数有相同的形参列表，才能通过基类的指针或引用调用派生类的虚函数。 调用非虚函数时不会发生动态绑定，实际调用的函数版本又指针的静态类型决定 构造函数与拷贝控制 虚析构函数 基类通常应该定义一个虚析构函数，这样可以动态分配继承体系中的对象 基类中的析构函数是虚函数，将确保delete基类指针时运行正确的析构函数版本 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。 派生类的拷贝控制成员 默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式使用基类的拷贝（或移动）构造函数 派生类的赋值运算符也必须显式地为其基类部分赋值 析构的顺序与构造的顺序相反，派生类的析构函数首先执行，然后是基类的析构函数 继承的构造函数 C++11新标准中，派生类能够重用其直接基类定义的构造函数 1234class D : public B{public: using B::B;//重用B的构造函数} using作用域构造函数时，该语句令编译器产生代码。对基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数 构造函数的using声明不会改变该构造函数的访问级别，比如基类的私有构造函数在派生类中还是私有 using声明语句也不能指定explicit或者constexpr，如果基类的构造函数是explicit或者constexpr，则继承的构造函数也有相同的属性 基类的构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。 派生类不会继承构造函数的情况： 派生类定义的构造函数与基类构造函数有相同的参数列表 默认、拷贝、移动构造函数不会被继承 容器与继承 当派生类对象赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容 当希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针。这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型 123vector&lt;shared_ptr&lt;B&gt;&gt; vec;vec.push_back(make_shared&lt;B&gt;());vec.push_back(make_shared&lt;D&gt;()); 第16章 模板与泛型编程 定义模板 函数模板 12template&lt;typename T&gt;int funct(const T&amp;,const T&amp;); 模板定义中，模板参数列表不能为空 调用函数模板时，编译器通常用函数实参为我们推断模板实参 编译器用推断出的模板参数实例化一个特定版本的函数 模板中可以定义非类型参数，一个非类型参数表示一个值而非一个类型，通过类型名而非class或typename指定非类型参数 123template&lt;unsigned N,unsigned M&gt;int comp(const char (&amp;p1)[N],const char (&amp;p2)[M]){ return strcmp(p1,p2);} 非类型模板参数实参必须是常量表达式 inline和constexpr说明符要放在参数列表之后，返回类型之前 模板程序应该尽量减少对实参类型的要求 编译器遇到模板定义时，并不生成代码，只有当我们实例化出模板的一个特定版本时才会生成代码。 函数模板和类模板成员函数的定义通常放在头文件中，因为编译器生成一个实例化版本要掌握其定义 类模板 与函数模板的区别在于，编译器不能为类模板推断模板参数类型，必须在模板名后的尖括号中提供额外信息 默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化 在类模板的作用域内，我们可以直接使用模板名而不必指定模板实参 模板类型别名 123template&lt;typename T&gt; using twin = pair&lt;T,T&gt;;twin&lt;string&gt; authors;template&lt;typename T&gt; using partNo = pair&lt;T,unsigned&gt; 类模板中的static成员：不能把静态成员的定义放在类中，但是可以在类的外部通过使用范围解析运算符 :: 来定义静态变量从而对它进行初始化。 相同类型如int对应的类模板的对象之间的static成员是共享的，不同类型之间如int,float,char对应的类模板的对象之间的static是不共享的。 模板参数 声明中的模板参数与定义中的模板参数不必相同。 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。 对于模板代码而言，假定T是模板类型参数，当遇到T::mem这样的代码时，编译器不知道mem是一个类型名还是一个static数据成员的名字，直至实例化时才会知道。 1T::size_type * p; 编译器不知道是size_type数据成员与p相乘还是定义一个size_type类型的p 默认情况下，C++假定通过作用域运算符访问的是名字而非类型。 所以，如果想使用一个类型时，必须显式的告诉编译器 1typename T::value_type top(const T&amp;); C++11开始，可以为函数和类模板提供默认实参。无论何时使用类模板，模板名之后都要接尖括号，尖括号指明类必须从一个模板实例化而来。 如果希望使用提供的默认实参，就在模板名之后跟一个空的尖括号对 成员模板 类中包含的本身是模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数 控制实例化 模板实参推断 类型转换与模板类型参数 对函数模板传递的实参，通常不进行类型转换，而是生成一个新的模板实例，只有有限的几种类型转换会自动应用于实参： 顶层const无论在形参还是实参中都会被忽略。 非const对象的引用或指针传递给const的引用或指针形参。 形参不是引用类型，则可以对数组或函数类型的实参应用指针转换，数组实参转换为指向其首元素的指针；函数实参转换为一个该函数类型的指针。 如果不是模板参数，则可以对实参进行正常的类型转换 函数模板显式实参 重载与模板 可变参数模板 模板特例化","link":"/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/"},{"title":"《C++ Primer》笔记（8-12章）","text":"《C++ Primer》 8-12章笔记 第八章 IO类 IO对象无拷贝或赋值，进行IO操作的函数通常以引用方式传递和返回流 读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的 流的状态（iostate类型的constexpr值）： badbit置位，系统级错误，不可恢复 failbit置位，通常可修正，流可以继续使用 eofbit，文件结束位置，文件结束时failbit也会置位 goodbit，值为0表示流未发生错误，前三个任一个被置位则错误 1234auto oldState = cin.rdstate();//rdstate返回流当前状态cin.clear();process_input(cin);cin.setstate(oldState);//cin置为原有状态 管理输出缓冲 每个输出流都管理一个缓冲区，刷新缓冲的原因有： 程序正常结束，作为main函数return操作的一部分，缓冲区刷新 缓冲区满 endl操纵符显式刷新（另，flush刷新缓冲区但不输出额外字符，ends插入一个空字符然后刷新缓冲区） 每个输出操作后用操作符unitbuf设置流的内部状态，清空缓冲区。cerr默认是设置unitbuf的 一个输出流被关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新 12cout&lt;&lt;unitbuf;cout&lt;&lt;nounitbuf; 如果程序崩溃，输出缓冲区不会被刷新 关联输入和输出流 交互式系统，所有输出都会在读操作之前被打印 每个流最多同时关联到一个流，但多个流可以同时关联到一个ostream 文件输入输出 12ifstream in(inFile);//C++11中inFile可以是库类型string对象，也可以是C风格字符数组ofstream out; 一旦一个文件流被打开，就保持与对应文件的关联；为了关联另外一个文件，首先必须关闭close()已经关联的文件 fstream对象被销毁时，close会自动被调用 文件模式 app是每次写操作前定位到文件末尾；ate是打开文件后立刻定位到文件末尾 trunc是截断文件（打开文件时清空已打开的文件流） out模式默认是trunc模式 string流 sstream.str()返回string流所保存的string的拷贝 sstream.str(s)将s拷贝到string流中，返回void 第九章 顺序容器概述 容器 访问方式 操作特点 vector 快速随机访问（因为内存中连续存储） 尾部插入删除元素快 deque 快速随机访问 头尾插入删除元素快 list 只能双向顺序访问（额外内存开销较大） 在任何位置插入删除都很快 forward_list 只能单向顺序访问（额外内存开销较大） 在任何位置插入删除都很快 array 快速随机访问 不能添加删除元素 string 快速随机访问（因为内存中连续存储） 尾部插入删除元素快 forward_list和array是C++新标准增加的类型 array与内置数组比更安全更易用，其大小固定。 forward_list没有size操作，因为保存或计算其大小会多出额外开销 选择容器的一些基本原则： 没有很好的理由就用vector 程序有很多小元素且空间额外开销很重要，ban掉list和forward_list 要在容器中间插入删除，用list或forward_list 仅在头尾操作，deque 只需要在读取输入时在中间插入，读取完后随机访问：考虑在输入阶段用list，完成后拷贝到vector中 容器库概览 迭代器 forward_list不支持迭代器的–运算符 开头带r的反向迭代器 容器定义和初始化 只有顺序容器（不包括array）的构造函数才能接受大小参数 12C seq(n);C seq(n,t); 创建一个容器为另一个容器的拷贝时，两个容器的类型和元素类型必须匹配。但通过传递迭代器参数拷贝一个范围时，就不要求容器类型和元素类型是相同的了，只要能将拷贝的元素转换到所需类型即可 array具有固定大小 1array&lt;int,42&gt; a; 一个默认构造的array是非空的，包含与其大小一样多个元素，且元素均被默认初始化。 内置数组不能拷贝或为另一数组赋值，但array没有此限制 赋值和swap array不允许用花括号列表进行赋值（可以用于初始化），也不支持assign 赋值运算符要求左右运算对象具有相同的类型 顺序容器还定义一个名为assign的成员，允许从一个不同但相容的类型赋值，或者从容器的一个子序列赋值 除array外，swap操作中元素本身并未交换，无任何拷贝删除插入操作，只是交换两个容器的内部数据结构，保证常数时间内完成 对string调用swap会导致迭代器、引用、指针失效，其他容器不会 array完成swap操作后，原有的迭代器等绑定的元素不变，变得是元素值 其他顺序容器swap后，迭代器等指向仍然指向之前的元素，但是元素本身所属的容器已经发生了变化 顺序容器操作 添加元素 1234c.insert(p,t);c.emplace(p,args)//在迭代器p指向的元素之前创建值为t或由args创建的元素，返回指向新添加的元素的迭代器c.insert(p,n,t);//在p指向元素之前插入n个t，返回指向添加的第一个元素的迭代器c.insert(p,b,e);//将迭代器b和e指定范围内的元素添加到p之前，迭代器不能指向c中的元素,左闭右开区间b-ec.insert(p,il);//将一个元素值列表il插入到p之前 *forward_list有自己专有版本的insert和emplace *forward_list不支持push_back和emplace_back *vector和string不支持push_front和emplace_front 向vector或string或deque插入元素会使所有指向容器的迭代器引用指针都会失效 emplace构造而非拷贝元素（CPP11）,传入emplace的参数必须与元素类型的构造函数参数匹配 访问元素 1c.at(n)//返回下标为n的元素的引用 front back at返回的都是引用 12345c.front() = 42;auto&amp; v = c.back();//v是引用v = 1024;//如果c不是常量容器，可以改变c中元素auto v2 = c.back();//v2不是引用，是c.back()的拷贝v2 = 0;//并未改变c中元素 forward_list不使用back at只适用于string array deque vector 删除元素 12345c.pop_back();c.pop_front();c.erase(p);//删除p所指元素，返回指向被删元素之后元素的迭代器c.erase(b,e);//删除b和e所指定范围内的元素,左闭右开区间b-ec.clear();//删除c中所有元素 *forward_list有自己专有版本的erase *forward_list不支持pop_back *vector和string不支持pop_front 删除deque中除首尾位置之外的元素会使所有迭代器引用指针失效。指向vector或string删除点之后位置的迭代器引用指针都会失效 erase会保留原有的空间，但是容器的size参数会变化 forward_list中的特殊操作 因为单向链表无法访问一个元素的前驱，所以在单向链表中添加或删除元素是操作给定元素之后的元素完成的 改变容器大小 12c.resize(size);c.resize(size,newinit); resize缩小容器时，指向被删除元素的迭代器引用和指针都会失效；对vector/string/deque进行resize可能导致迭代器、指针、引用失效 容器操作可能导致迭代器失效 vector对象是如何增长的 vector元素连续存储 导致，添加元素时：若没有空间容纳新元素，容器必须分配新的内存空间将已有元素移动过去再添加新元素，释放旧空间 标准库实现中：当不得不获取新的内存空间时，vector和string的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用。 1234//容器大小管理操作c.capacity();//c可以保存的元素数，只适用于vector stringc.reserve(m);//分配至少能容纳m个元素的内存空间，只适用于vector stringc.shrink_to_fit()//将capacity减少为和size相同大小，只适用于vector string deque 需求大小小于当前容量时，reserve不会回收内存空间，而是什么也不做 resize不会改变容器的容量 shrink_to_fit是CPP11的新操作，但具体实现可以忽略其请求，也即调用该函数也不保证一定会退回内存空间 额外的string操作 确实。 容器适配器 适配器是标准库中的通用概念。容器、迭代器、函数都有适配器 stack queue priority_queue 没有提供与元素保存相关的数据结构实现，通过调用底层的基础容器来实现其功能 C++中的容器适配器是干什么的呢？我们已有容器（比如vector、list、deque），他们支持的的操作很多，比如插入，删除，迭代器访问等等。而我们希望这个容器表现出来的是栈的样子：先进后出，入栈出栈等等，此时，我们没有必要重新动手写一个新的数据结构，而是把原来的容器重新封装一下，改变它的接口，就能把它当做栈使用了。 原文链接：https://blog.csdn.net/qq_21989927/article/details/109392756 第十章 概述 大多数定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法 一般情况下，泛型算法不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作（比如find的==完成给定值和每个元素的比较） 算法永远不会执行容器的操作，只会运行于迭代器之上，执行迭代器的操作 初识泛型算法 只读算法 accumulate 1int sum = accumulate(vec.begin(),vec.end(),0); accumulate定义在头文件numeric中，第三个参数是和的初值。第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型 只读算法最好使用cbegin和cend，但是如果要使用返回的迭代器改变元素的值，则需要使用非常量版本 equal 1equal(roster1.cbegin(),roster1.cend(),roster2.cbegin()); 确定两个序列是否保存相同的值，roster1和roster2的容器类型和元素类型都不必相同，只要能用==比较即可 equal假设第二个序列至少与第一个序列一样长 写容器元素的算法 注意序列原大小至少不小于要求算法写入的元素数目 fill 12fill(vec.begin(),vec.end(),0);fill_n(vec.begin(),vec.size(),0);//从参数1开始指定参数2个元素赋值参数3 back_inserter 定义在头文件iterator中 一种保证算法有足够元素空间容纳输出数据的方法是使用插入迭代器 通过back_inserter赋值时，与赋值号右侧相等的元素被添加到容器中 12345vector&lt;int&gt; vec;//emptyauto it = back_inserter(vec);*it = 42;//vec = {42}, call push_back to add 42fill_n(back_inserter(vec),10,0); 拷贝算法 copy 123int a1[] = {0,1,2,3,4,5,6,7,8,9};int a2[sizeof(a1)/sizeof(*a1)];auto ret = copy(begin(a1),end(a1),a2); 前两个参数表示一个输入范围，第三个参数表示目的序列起始位置 目的序列至少要包含与输入序列同样多的元素 copy返回目的位置递增后的迭代器的值，上例中返回a2尾元素之后的位置 replace 12replace(il.begin(),il.end(),0,42);replace_copy(il.cbegin(),il.cend(),back_inserter(ivec),0,42);//保留原序列不变，第三个参数指出调整后序列的保存位置 Attention: 123vector&lt;int&gt;vec;vec.reserve(10);fill_n(vec.begin(),10,0); 这段程序是错误的，因为泛型算法对容器的要求是有足够的元素，而非足够的空间，即便使用了reserve，vec仍然为空，而fill_n在不适用back_inserter的情况下没有插入新元素的能力 重排容器的算法 sort排序 unique重排输入序列，将相邻重复项消除，并返回一个指向不重复值范围末尾的迭代器（不是真的删除元素，而是覆盖相邻的重复元素） 1234567891011vector&lt;string&gt; vec{ &quot;adsad&quot;,&quot;vsf&quot;,&quot;dsad&quot;,&quot;dsad&quot;,&quot;quie&quot; };sort(vec.begin(), vec.end());for (const auto&amp; v : vec) { cout &lt;&lt; v &lt;&lt; endl;}cout &lt;&lt; endl;auto ret = unique(vec.begin(), vec.end());vec.erase(ret, vec.end());for (const auto&amp; v : vec) { cout &lt;&lt; v &lt;&lt; endl;} 定制操作 向算法传递函数 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为一元谓词（接受一个参数）和二元谓词。接受谓词参数的算法对输入序列中的元素调用谓词。 lambda表达式（CPP11） 一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数，其形式如下 1[capture list](parameters list)-&gt;return type {function body} 捕获列表和函数体必须被包含，参数列表和返回类型可以忽略 lambda的调用方式也使用调用运算符 lambda不能有默认参数 lambda表达式只能使用明确指明的变量，将需要使用到局部变量包含在其捕获列表中使用 1for_each(begin,end,function) 对迭代器[begin,end)范围内的元素执行function操作 lambda捕获和返回 定义lambda时，编译器生成一个与lambda对应的新的未命名类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象，向函数传递的参数就是该对象，lambda所捕获的变量都有对应的类数据成员，在lambda对象创建时被初始化。 值捕获、引用捕获 值捕获的前提是变量可拷贝，被捕获变量的值在lambda创建时被拷贝 引用捕获的变量与其他任何类型的引用的行为相似。要保证被引用的对象在lambda执行时是存在的 尽量保持lambda的变量捕获简单化 隐式捕获 让编译器根据lambda体中的代码自动推断使用哪些变量 捕获列表中&amp;告诉编译器采用引用捕获方式；=表示采用值捕获方式 混合使用隐式捕获和显式捕获 12for_each(words.begin(),words.end(),[&amp;,c](const string&amp; s){});for_each(words.begin(),words.end(),[=,&amp;os](const string&amp; s){}); 需要为一个lambda定义返回类型时，必须使用尾置返回类型 参数绑定 可以将bind看作一个通用的函数适配器，接受一个可调用对象，生成新的可调用对象适应原对象的参数列表 1auto newCallable = bind(callable,args_list); args_list为参数列表，其中可能包含_1,_2等占位符 1234567bool check_size(const string &amp;s,string::size_type sz){ return s.size()&gt;=sz;}auto check6 = bind(check_size,_1,6);string s = &quot;test&quot;;bool b1 = check6(s);auto findif_ret = find_if(words.begin(),words.end(),bind(check_size,std::placeholders::_1,sz)); _1,_2等占位符定义在名为placeholders的命名空间中 auto check6 = bind(check_size,_1,6);指用check6调用时的第一个参数作为check_size的第一个参数，6作为check_size的第二个参数 123auto g = bind(f,a,b,_2,c,_1);g(X,Y);f(a,b,Y,c,X); 传给g的参数按照位置绑定至占位符，实际上调用的是f(a,b,Y,c,X); 绑定引用参数使用ref()或者cref()，二者返回一个对象包含给定参数的引用，该对象是可拷贝的。 因为bind函数中不是占位符的参数会通过拷贝传递给bind返回的可调用对象中，而有时被绑定的参数类型无法拷贝，或者希望以引用方式传递 再探迭代器 插入迭代器 是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素 back_inserter front_inserter inserter(只有在支持front或back相关操作时才能使用) inserter(c,iter)会将元素插入到c中iter指向的元素之前的位置 1234inserter(c,iter);//等价于it = c.insert(it,val);++it; iostream迭代器 istream_iterator ostream_iterator。将对应的流当作一个特定类型的元素序列来处理。使用流迭代器，可以用泛型算法从流对象读取数据或向流对象写入数据 创建流迭代器时，必须指定迭代器将要读写的对象类型 123istream_iterator&lt;int&gt; int_it(cin);//从cin读取intifstream in(&quot;aflie&quot;);istream_iterator&lt;string&gt; str_it(in);//从文件读取字符串 123456//流迭代器构造vectoristream_iterator&lt;int&gt; it_iter(cin),eof;vector&lt;int&gt; vec(it_iter,eof);//使用算法操作流迭代器istream_iterator&lt;int&gt; it_iter(cin),eof;cout&lt;&lt;accumulate(it_iter,eof)&lt;&lt;endl; 123456ostream_iterator&lt;int&gt; out_iter(cout,&quot; &quot;);//第二个参数为每个值后输出一个空格，该参数必须是字符串字面常量或指向空字符结尾的字符数组的指针for(auto e :vec){ *out_iter++ = e;}//通过copy打印copy(vec.begin(),vec.end(),out_iter); 反向迭代器 除了forward_list，其他容器都支持反向迭代器 反向迭代器的base()函数，返回其对应的普通迭代器 普通迭代器和反向迭代器的关系反映了左闭合区间的特性，关键在于[line.crbegin(),rcomma)[line.crbegin(),rcomma)[line.crbegin(),rcomma)和[rcomma.base(),line.cend())[rcomma.base(),line.cend())[rcomma.base(),line.cend())元素范围相同 泛型算法结构 对算法分类：算法需求的迭代器；算法是否读、写或重排序列、参数传递 5类迭代器 算法所要求的迭代器操作可以分为五类： 迭代器类型 支持的操作 输入迭代器 只读 不写 单遍扫描 只能递增 输出迭代器 只写 不读 单遍扫描 只能递增 前向迭代器 读写 多遍扫描 只能递增 双向迭代器 读写 多遍扫描 递增递减 随机访问迭代器 读写 多遍扫描 支持全部迭代器运算 向算法传递正确类型的迭代器 多个istream_iterator输入迭代器的问题：istream_iterator的是调用read()（*stream&gt;&gt;value）读取流中的一个值，所以对一个迭代器会导致另一个迭代器下次++时读取不到想要的值。因此只能用于单遍扫描的算法 算法形参模式 1234alg(beg,end,others);alg(beg,end,dest,others);alg(beg,end,beg2,others);alg(beg,end,beg2,end2,others); 算法命名规范 算法命名规范处理诸如：如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题 使用重载形式传递谓词，代替&lt;或==,如sort/unique _if版本接受谓词代替元素值，如find_if _copy拷贝版本将算法结果写入指定输出位置 特定容器算法 list和forward_list定义了若干个成员函数形式的算法 12345678910lst.merge(lst2);//将来自lst2的元素合并入lst，二者都必须是有序的，默认用&lt;运算符lst.merge(lst2,comp);//合并，但使用给定的比较操作//以上二者合并之后lst2都变为空lst.remove(val);//调用erase删除与给定值相等的每个元素lst.remove_if(pred);//调用erase删除令谓词为真的每个元素lst.reverse();//反转lst中元素lst.sort();lst.sort(comp);lst.unique();lst.unique(pred); 第11章 关联容器 关联容器支持高效的关键字查找和访问 8个关联容器，无序/有序 set/map 可重复/不重复 关联容器概述 关联容器不支持顺序容器位置相关的操作，如push_front push_back等 关联容器的迭代器都是双向的 初始化map时，必须提供关键字类型和值类型 1map&lt;string,string&gt; authors = {{&quot;Hoy&quot;,&quot;James&quot;},{&quot;Austin&quot;,&quot;Jane&quot;}}; 允许关键字相同时，使用multimap或者multiset 有序容器中，关键字类型必须定义元素比较的方法。可以定义自己的操作来代替关键字上的&lt;运算符，该操作必须在关键字类型上定义一个严格弱序（小于等于） 为了使用自己定义的操作，在定义multiset时必须提供关键字类型和比较操作类型 1234bool compareIsbn(const Sales_date &amp;lhs,const Sales_date&amp; rhs){ return lhs.sibn()&lt;rhs.isbn();}mulitset&lt;Sales_data,decltype(compareIsbn)*&gt; bookstore(compareIsbn); 当用decltype获得一个函数指针类型时，必须加上一个*指出我们要使用一个给定函数类型的指针。 pair类型 包含于utility头文件 map的每个元素就是一个pair对象 两个成员是public的，分别命名为first和second 关联容器操作 key_type指的是容器的关键字类型 mapped_type为每个关键字关联的类型（就是键值对中值的类型）,只有map系列容器有该类型 value_type是容器中元素的类型，map为pair 关联容器迭代器 set类型虽然同时定义了iterator和const_iterator，但两种类型都只能读访问set中的元素。 添加元素 向map中insert元素时，元素类型必须是pair 12word_count.insert({word,1});word_count.insert(make_pair(word,1)); c.insert(v)插入单一元素返回值为pair，first给出指向具有给定关键字元素的迭代器；second给出bool值，指出元素是插入成功还是已经存在容器中。 c.insert(b,e)/c.insert(il)插入若干个元素，返回值为void c.insert(p,v)从p指定位置开始搜索新元素应该存储的位置，返回值为一个迭代器 删除元素 可以传递给erase一个关键字或者一个迭代器或者一个范围 map下标操作 set类型不支持下标 只能对非const的map使用下标操作，因为下标运算符有可能插入一个新元素 加入对一个空map进行下标操作mp[“a”]=1; 在mp中搜索a关键字的元素，未找到 将一个新的键值对插入到mp中 取出新插入的元素，赋值1 访问元素 123c.lower_bound(k);//有序容器操作，指向第一个关键字不小于k的元素c.upper_bound(k);//有序容器操作，指向第一个关键字大于k的元素c.equal_range(k);//返回一个pair，表示关键字等于k的范围 无序容器 C++11新定义 不使用比较运算符组织元素，而是使用哈希函数和关键字类型的==运算符 不能直接定义关键字类型为自定义类类型的无序容器，需要提供函数代替==运算符和哈希值计算函数 第12章 动态内存 全局对象在程序启动时分配，程序结束时销毁 局部自动对象在进入其定义所在的程序块时被创建，离开块时被销毁 局部static对象在第一次使用前分配，程序结束时销毁 动态分配的对象生存期与在哪里创建无关，只有显式被释放时才会销毁对象 静态内存 保存局部static对象、类static数据成员、定义在任何函数之外的变量 栈内存 定义在函数内的非static对象 自由空间（堆） 存储程序运行时动态分配的对象 动态内存和智能指针 new和delete进行动态内存的管理：new在动态内存中为对象分配空间并返回一个指向该对象的指针；delete接受一个动态对象的指针，销毁对象，释放与之关联的内存 为了更容易且更安全地使用动态内存，新标准库在memory头文件中提供了两种智能指针，与普通指针的区别是它负责自动释放所指对象 share_ptr 允许多个指针指向同一个对象 unique_ptr 独占所指向的对象 weak_ptr 一种弱引用，指向shared_ptr所管理的对象 均支持的操作： 123p.get();//返回p中所保存的指针p.swap(q);swap(p,q);//交换p,q中的指针 shared_ptr 12shared_ptr&lt;string&gt; p1;shared_ptr&lt;list&lt;int&gt;&gt; p2; 默认初始化的智能指针中保存着一个空指针 1234make_shared&lt;T&gt;(args);//返回一个shared_ptr，指向动态分配的类型为T的用args初始化的对象shared_ptr&lt;T&gt; p(q);//拷贝，会递增q中的计数器p.use_count();//返回与p共享对象的智能指针数量，可能很慢，主要用于调试p.unique();// return true if p.use_count()==1; 可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。shared_ptr作为参数传递给函数以及作为函数的返回值时，所关联的计数器都会+1。shared_ptr赋值时会递增右侧指针的计数器，递减左侧指针的引用计数 一旦计数器变为0，就会自动释放自己所关管理的对象 12345auto r = make_shared&lt;int&gt;(42);r = q;//给r赋值令其指向另一个地址 //递增q指向的对象的引用计数 //递减r原来指向的对象的引用计数 //r原来指向的对象已没有引用者，会自动释放 程序使用动态内存的原因： 程序不知道自己需要使用多少对象 程序不知道所需对象的准确类型 程序需要在多个对象之间共享数据 直接管理内存 new动态分配和初始化对象 默认情况下动态分配的对象是默认初始化的 1int *pi = new int; 可以使用直接初始化方式 12int *pi = new int(1024);vector&lt;int&gt; *pv = new vector{0,1,2,3,4}; 也可以使用值初始化 1int *pi2 = new int(); 动态分配const对象 用new分配const对象是合法的： 1const int *pci = new const int(1024); 同样，一个动态分配的const对象必须进行初始化 内存耗尽 内存耗尽时new表达式失败，抛出一个bad_alloc类型的异常 阻止抛出异常 1int *p2 = new (nothrow) int; 这种方式称为定位new，如果定位new不能分配所需内存，会返回一个空指针 释放动态内存 delete表达式执行：销毁给定的指针指向的对象，释放对应的内存 指针值和delete 传递给delete的指针必须满足两个条件之一1.指向动态分配的内存；2.空指针 编译器不能分辨指针指向的是动态分配对象还是静态分配对象，也不能分辨指针所指向的内存是否已经释放了 空悬指针 一个问题是，即便delete释放内存后，再将指针设置为nullptr，也只能提供有限的保护，因为可能有其他指向该已释放内存的指针，这些指针变为空悬指针。 shared_ptr和new结合使用 可以用new返回的指针初始化智能指针 1shared_ptr&lt;int&gt; p(new int(42)); 接受指针参数的智能指针构造函数是explicit的，必须使用直接初始化形式 1shared_ptr&lt;int&gt; p1 = new int(42);//错误 默认情况下，用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放所关联的对象（除非提供自己的Deleter代替delete） 不要混合使用普通指针和智能指针 当一个shared_ptr绑定到一个普通指针时，就不应该再用内置指针访问shared_ptr所指向的内存了 1234int *x(new int(1024));process(x);//错误，不能进行隐式转换process(shared_ptr&lt;int&gt;(x));//合法，但内存会被释放int j = *x;//未定义行为，x是一个空悬指针 永远不要用get初始化另外一个智能指针或未另一个智能指针赋值：使用get初始化的智能指针与原智能指针是各自独立的，当一个智能指针的计数器为0释放内存后，另一个智能指针就会变为空悬指针。 智能指针和异常 发生异常退出函数时，局部对象会被销毁，如果局部对象是智能指针，则会在销毁时检查计数确定是否需要释放内存 而普通指针不会自动释放内存，需要在异常发生位置人为delete 智能指针基本规范： 不使用相同的内置指针值初始化或reset多个智能指针 不delete get()返回的指针 不使用get()初始化或reset另一个智能指针 如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了 如果用智能指针管理非动态分配资源，一定要传递一个删除器 unique_ptr 某个时刻只能有一个unique_ptr指向一个给定对象 需要将unique_ptr绑定到一个new返回的指针上，且必须采用直接初始化形式。因为unique_ptr不支持普通的拷贝或者赋值操作。 1234u.realease();//放弃对指针的控制权，返回指针，并将u置为空unique_ptr&lt;string&gt; p2(p1.release());unique_ptr&lt;string&gt; p3(new string(&quot;Trex&quot;));p2.reset(p3.release); 可以调用release或reset将指针的所有权从一个非const unique_ptr转移给另一个unique_ptr release不会释放内存，release如果不把控制权交给另一个指针，就要负责资源释放 unique_ptr不能拷贝的例外规则：可以拷贝或赋值一个将要被销毁的unique_ptr weak_ptr 不控制所指对象生存期的智能指针，指向一个由shared_ptr管理的对象 将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数，shared_ptr销毁时不会考虑是否有weak_ptr指向对象 weak_ptr与共享对象的shared_ptr共享计数器 w.expired(); return w.use_count()==0 ? true : false; w.lock(); 如果expired为true返回空shared_ptr，否则返回指向w的对象的shared_ptr 要用一个shared_ptr初始化weak_ptr 动态数组 new和数组 1int *pia = new int[get_size()];//方括号中必须是整型，但不必是常量 new得到的是数组元素类型的指针 分配的内存根本不是数组类型，所以不能对动态数组调用begin或者end 也不能用范围for语句处理动态数组中的元素 默认使用默认初始化，如下方式使用值初始化 12int *pia = new int[get_size()]();int *pia = new int[get_size()]{1,2,3,4,5}; 不能用auto分配数组 可以动态分配一个空数组，new返回一个非空指针，类似于尾后指针 allocator类 将内存分配和对象构造分离开 12345allocator&lt;string&gt; alloc;auto const p = alloc.allocate(n);alloc.deallocate(p,n);//从p地址开始的内存被释放，n必须是p创建时所要求的大小，p不能为空，必须指向allocator分配的内存alloc.construct(p,args);//args被传递给构造函数，在p指向的内存位置中构造一个对象alloc.destroy(p);//对p指向的对象执行析构函数","link":"/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%888-12%E7%AB%A0%EF%BC%89/"},{"title":"《C++ Primer》笔记（1-7章）","text":"《C++ Primer》 1-7章笔记 第一章 标准库定义的4个IO对象：cin cout cerr clog 输入输出运算符返回其左侧运算对象作为其计数结果 UNIX系统中，文件结束符输入使用ctrl+D 保持代码格式的一致性 使用文件重定向：$addItem &lt;inFile &gt; outFile 该命令从inFile文件中读取，并将输出结果写入outFile中 第二章 基本内置类型 C++定义了一套算术类型和空类型在内的基本数据类型 C语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long(C11)至少和一个long一样大 一个字节要至少能容纳机器基本字符集中的字符 字符型被分为了char,signed char,unsigned char,需要注意类型char和类型signed char并不一样，类型char会表现为signed char或unsigned char的一种，具体是哪种由编译器决定 在算术表达式中不要使用char或bool。因为char在不同机器上是有符号的或者无符号的。 执行浮点数运算选用double，因为float通常精度不够且双精度浮点数和单精度的计算代价相差无几 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。e.g. 8bit unsigned char表示0-255，如果赋值-1所得结果为255（-1%256） 整数商c=a/b 计算模或者取余 r = a - c*b 当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。 当符号不一致时，求模运算结果的符号和b一致，求余运算结果的符号和a一致。 取模和取余区别在于，取模运算在取c的值时向无穷小方向舍入（-1/5=-0.2向无穷小方向取整得-1）；取余运算在取c的值的时候向0方向舍入(-1/5=-0.2向0取整得到0)，第二步是相同的。 所以取模时计算机向无穷小方向舍入，即c=-1，r=(-1)-(-1)*256=255; -1转unsigned int类型原码表示为1000 0000 0000 0000 0000 0000 0000 0001 但在int类型在内存中的存储为补码（负数补码除符号位原码取反+1） 所以其在内存中表示为1111 1111 1111 1111 1111 1111 1111 1110+1 但unsigned类型认为是正数，所以其补码存储与原码相同 也就是2^32-1 所以强转为unsigned之后值为2^32-1 切勿混用带符号类型和无符号类型 如果反斜线后面跟着的八进制数字超过3个，只有前三个数字与之构成转义序列，而十六进制的\\x要用到后边跟着的所有数字。 变量 初始化和赋值是两个完全不同的操作，初始化的含义是创建变量时赋予其一个初始值，赋值的含义是把对象当前值擦除以一个新值代替。 **列表初始化：**C++11，用花括号初始化变量。如果使用列表初始化切初始值存在丢失信息的风险，则编译器将报错 123long double ld = 1.1415926536;int a{ld},b={ld}//错误，因为存在丢失信息风险int c(ld),d=ld;//正确,但是确实丢失了一部分值 变量定义与声明的关系 C++分离式编译，允许程序分割为若干文件，每个文件可被独立编译。 声明使得名字为程序所知，定义负责创建与名字关联的实体 如果要 声明一个变量而非定义它，就在变量名前加extern关键字 任何包含了显式初始化的声明即成为定义 123extern int i;//声明i但不定义int j;//声明并定义jextern double pi = 3.1416;//定义 在函数体内部，如果试图初始化一个由extern标记的变量，将引发错误。 变量只能被定义一次，但可以被多次声明。 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须且只能出现在一个文件中。 作用域 一旦声明之后，全局作用域内的名字在整个程序范围内都可使用。 覆盖规则 复合类型 引用 引用为对象起了另外一个名字。引用必须被初始化 12int ival = 42;int &amp;refVal = ival; 定义引用时，程序把引用和它的初始值绑定在一起，而不是拷贝给引用，所以，定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。 引用不是一个对象，所以不能定义引用的引用。 一句定义多个引用时，每个引用标识符都必须以&amp;开头 12int i = 1,i2=22;int &amp;ri = i,&amp;ri2 = i2; 引用不能绑定在字面值或者表达式计算结果上 123int &amp;refVal = 10;//wrongdouble dval = 3.14;int &amp;refVal = dval;//wrong 指针 指针本身就是一个对象，允许赋值和拷贝 取地址符&amp; 解引用符* 使用nullptr初始化得到空指针（C++11) NULL预处理变量，在cstdlib中定义，值为0 新标准下，最好使用nullptr，尽量避免使用NULL 把int变量直接赋给指针是错误的操作 如果两个指针存放的地址值相同则它们相等 void*指针可以存放任意对象的地址，但并不了解对象的类型 指向指针的引用 12345int i = 42;int *p;int *&amp;r = p;//r是对指针p的引用r = &amp;i;//相当于对p赋给i的地址*r = 0;//设置为空 要理解r的类型，最简单的方法是从右向左阅读r的定义，离变量名最近的符号对变量类型有最直接的影响 const限定符 必须初始化 默认状态下，const对象仅在文件内有效 定义一个常量之后，编译器在编译过程中把所有用到该常量的地方都替换成对应值。 文件之间共享：extern关键字，只需要定义一次 const的引用 指把引用绑定到const对象上 对常量的引用与普通引用的区别在于不能修改其所绑定的对象 所以也不能通过一个非常量引用去指向一个常量对象，因为非常量引用理论上是可以被修改的，二者相矛盾 1234const int ci = 1024;const int &amp;r1 = ci;//correctr1 = 42;//wrongint &amp;r2 = ci;//wrong 引用的类型必须与其所引用对象的类型一致，但例外1：初始化常量引用时允许使用任意表达式作为初始值，只要表达式结果能转换成引用的类型。 1234int i = 42;const int &amp;r1 = i;const int &amp;r2 = 42;const int &amp;r3 = r1 * 2; 理解 double dval = 3.14; const int &amp;ri = dval; 编译器为了确保让ri绑定一个整数，把上述代码变为： const int tmp = dval; const int &amp;ri = tmp; 所以绑定的是一个临时量，由于对const的引用不会改变值，所以是合法的 但如果ri不是常量，上述过程如果可以执行的话，改变ri相当于改变了绑定的临时量，而使用绑定肯定是想改变dval的值，所以这种方法不能达到目的，C++也就将这种行为归为非法 常量引用仅对可参与的操作进行了限定，对引用的对象本身是否是常量未作限定 12345int i = 42;int &amp;r1 = i;const int &amp;r2 = i;r1 = 0;r2 = 0;//wrong 个人理解：常量引用只是在引用上加const限定，被绑定对象本身是否为const类型均可，但无论何种情况都不能通过引用对被绑定对象进行修改。更多的可能还是用于参数传递时保证参数不被修改。 指针和const 指向常量的指针不能用于改变其所指1对象的值。要想存放常量对象地址，只能使用指向常量的指针 1234const double pi = 3.14;double *ptr = &amp;pi;//错误，必须使用指向常量的指针const double *cptr = &amp;pi;//correct*cptr = 32;//wrong; 同理于常量引用，上述例子中pi是非常量也是可以的。 const指针 指针与引用不同的地方在于，指针是对象，所以允许把指针本身设定为常量。常量指针必须初始化。 1234int errNumb = 0;int *const curErr = &amp;errNumb;const double pi = 3.14;const double *const pip = &amp;pi; 从右向左理解最后一行：pip是变量名，const说明pip是一个常量，*说明pip是一个常量指针，const double说明pip指向一个双精度浮点常量 理解： int errNumb = 0; int *const curErr = &amp;errNumb; 这个例子中，用errNumb = 3;或者*curErr = 15;这样的方法去修改值是合法的，这完全取决于被指向的变量类型是否为const。常量指针的意义在于其指向的地址是不可以修改的 顶层const 顶层const对任意类型适用，表示修饰对象本身是个常量，底层const表示指针或引用所指的对象是一个常量 底层const的限制不能忽视，当执行对象拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象数据类型必须能够转换。 1234567891011121314int i = 0;int *const p1 = &amp;i;//顶层const，不能改变p1const int ci =42;//顶层const,不能改变ciconst int *p2 = &amp;ci;//允许改变p2，底层constconst int *const p3 = p2;//右顶层，左底层const int &amp;r = ci;//底层consti = ci;//正确，ci顶层const无影响p2 = p3;//正确，p3顶层const，二者指向对象类型相同；int *p = p3;//错误，p3底层const，p1没有p2 = p3;//正确，二者都是底层constp2 = &amp;i;//正确，非常量向常量转换int &amp;r = ci;//错误，ci底层constconst int &amp;r2 = i;//正确 constexpr 值不会改变且编译过程能得到结果的表达式 一个表达式是否是常量表达式由其数据类型和初始值共同决定 123const int maxFiles = 20;const int limit = maxFiles + 1;//yint staffSize = 7;//n 声明为constexpr类型以便由编译器验证变量的值是否是常量表达式（cpp11） 一般来说，如果认定变量是一个常量表达式，就声明成constexpr类型 如果在constexpr声明中定义了一个指针，则constexpr限定符仅对指针有效，与其所指的对象无关 12const int *p = nullptr;//p是指向整型常量的指针constexpr int *q = nullptr;//q是指向整数的常量指针（顶层const） 处理类型 typedef using wages = double;(C++11) pstring是char*,const pstring修饰的是pstring，所以等同于 char *const const pstring cstr = 0与pstring const cstr=0是一样的意思 const char* 和char const *没有区别，const出现在base type旁边修饰的就是base type，与左右无关。 auto(cpp11) 让编译器去分析表达式所属的类型 使用auto在一条语句声明多个变量时，一条语句中变量的初始基本数据类型必须一样 12auto i = 0, *p = &amp;i;auto sz = 0, pi = 3.14;//wrong 使用引用时auto的类型是引用对象的类型 12int i = 0,&amp;r = i;auto a = r;//a is an int auto一般会忽略顶层const 1234const int ci = i,&amp;cr = ci;auto b = ci;//b is an intauto d = &amp;i;// d is a const pointerauto e = &amp;ci;//e is a pointer pointing to a const int. 使用const auto明确指出推断出的类型是一个顶层const decltype(c++11) 作用是选择并返回操作数的数据类型，但在此过程中编译器不实际计算表达式的值 1decltype(f()) sum = x; decltype返回的类型包括顶层const和引用在内 123const int ci = 0，&amp;cj = ci;decltype(ci) x = 0;//x类型为const intdecltype(cj) y = x;//y类型为const int&amp; 如果decltype使用的表达式不是变量，则decltype返回表达式结果对应的类型 有些表达式将向decltype返回一个引用类型，意味着该表达式的结果对象能作为一条赋值语句的左值 1decltype(*p) c; 解引用返回一个左值，该语句中c的类型为int&amp; 当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果： 如果 exp 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。 如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。 声明为返回（到对象的）左值引用/右值引用/对象的函数，用于函数调用表达式中时，形成的表达式值类别分别是左值/亡值/纯右值。然后 decltype 对该表达式的结果，还原了函数的返回类型。（https://www.zhihu.com/question/279641558） 自定义数据结构 C++11规定可以为数据成员提供一个类内初始值，创建对象时没有初始值的成员将被默认初始化 第三章 命名空间的using声明 12//using namspace::nameusing std::cin; 每个名字都要独立的using语句声明 头文件不应该包含using声明，因为头文件的内容会拷贝到所有引用它的文件中，导致所有的文件中都会有声明，可能产生冲突。 标准库类型string 可变长字符序列 1string s4(n'c');//连续n个字符c组成的串 使用=执行的是拷贝初始化，否则执行的是直接初始化 string对象上的操作 读取操作时会自动忽略开头空格、换行、制表等并从第一个真正的字符开始读入，直到下一处空白为止。 size函数返回string::size_type类型的值，该类型与机器无关，是一个无符号类型的值 如果一条表达式中已经有了size()就不要再混用int了 string的比较规则： 如果两个string长度不同且较短的string每个字符都与较长的string对应位置的字符相同，则较短的string小于较长的 一般比较的结果是string对象中第一对相异字符比较的结果。 使用加法时必须确保每个加号两侧对象至少有一个是string(不可均为字符字面值或字符串字面值) 为了与C兼容，CPP的字符串字面值不是标准库类型string的对象 处理string对象中的字符 范围for处理 123for(auto&amp; c : str){ //handle c here} 下标迭代处理 123for(auto idx = 0;idx!=str.size();idx++){ //handle c here} 标准库类型vector vector是一个类模板（不是类型），编译器根据类模板创建类的过程称为实例化。 初始化vector对象 12vector&lt;string&gt; v7{10};//10个默认初始化元素vector&lt;string&gt; v8{10,&quot;hi&quot;};//10个hi v7，v8提供的值不能作为元素初始值，编译器在确认无法执行列表初始化后，会尝试使用默认值初始化vector对象 向vector对象中添加元素 其他vector操作 使用size_type需要首先指定它是由那种类型定义的 12vector&lt;int&gt;::size_type//yvector::size_type//n 迭代器 end成员负责返回指向容器尾元素的下一位置的迭代器 如果容器为空，begin和end返回的都是尾迭代器 使用!=和迭代器判断而非下标：因为这种风格在标准库提供的所有容器上都有效 所有的标准库容器的迭代器都定义了==和!=,但大多数没有定义小于运算符 begin和end具体的返回类型由对象是否是常量决定，如果对象是常量，返回const_iterator，否则返回iterator cbegin和cend一定返回const_iterator 箭头运算符把解引用和成员访问两个操作结合在一起 12(*it).empty();it-&gt;empty();//二者等价 凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素（9.3.6） 迭代器运算 两个迭代器相减得到的是其距离，即右侧迭代器向前移动多少位置能追上左侧的，其类型为difference_type的带符号整数，即距离可正可负。 数组 数组大小确定不变，所以对某些特殊的应用程序而言运行时性能较好，但损失了灵活性 声明数组时其大小必须是一个常量表达式 列表初始化时： 没有指明维度，编译器根据初始值数量推测 指明维度，初始值总数量不应超出维度；如果小于维度，则其他的会被设置为默认值 字符数组注意留出空字符的空间 1const char a[6] = &quot;daniel&quot;;//wrong 数组不能拷贝和赋值（某些编译器扩展可以） 12int *ptrs[10];//含有10个指针的数组int (*pArr)[10];//指向含有10个整数的数组的指针 ![image-20230412102638060]image-20230412102638060.png) 指针和数组 大多数表达式中对数组对象的使用其实是使用一个指向首元素的指针 decltype对数组使用结果依然是数组 123int a[10]={...};decltype(a) a2;a2[2] = 3; end和begin函数分别以数组作为参数，返回指向尾元素下一位置和首元素的指针（C++11） 两个指针也可以相减，返回类型为ptrdiff_t,带符号机器相关类型 两个指针也可以&lt; !=等运算，类似于迭代器 123int *p = &amp;ia[2];int j = p[1];//ia[3]int k = p[-2];//ia[0] 数组初始化vector对象： 12vector&lt;int&gt; avec(begin(a),end(a));vector&lt;int&gt; avec2(a+1,a+3); 多维数组 第四章 基础 基本概念 一元运算符 二元运算符 三元运算符 左值和右值： 左值可以位于赋值语句左侧，右值则不能（C） 当一个对象被用作左值，用的是对象的身份（在内存中的位置）；被用作右值时，用的是对象的值（CPP） **重要原则：**需要右值的地方可以用左值代替，但不能把右值当作左值使用 几种情况： 赋值运算符需要一个非常量左值作为左侧运算对象，结果仍然是一个左值 取地址符作用于一个左值运算对象，返回指向该运算对象的指针，该指针是右值（？用的是指针的内容，也即运算对象的地址） 内置解引用运算符、下标运算符、迭代器解引用运算符、string/vector下标运算符求值结果为左值 内置类型和迭代器递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值 求值顺序 &amp;&amp; || ?: ,四种运算符只有当左侧条件成立才继续求右侧对象的值 算术运算符 算术运算符的运算对象和求值结果都是右值 除了-m导致溢出的情况，其他时候(-m)/n=m/(-n)=-(m/n)；m%(-n)=m%n,(-m)%n=-(m%n) 当m和m符号一致时，求模运算和求余运算所得的值一致，因此结果一致。 当符号不一致时，求模运算结果的符号和n一致，求余运算结果的符号和m一致。 逻辑和关系运算符 逻辑和关系运算符的运算对象和求值结果都是右值 赋值运算符 赋值运算符左侧运算对象必须是可修改的左值，运算结果也是左侧运算对象，并且是一个左值 赋值运算符满足右结合律 1ival = jval = 0; 赋值运算符优先级相对较低，通常需要给赋值部分加上括号使其符合原意 递增递减运算符 前置版本：先将对象±1，改变后的对象作为求值结果 后置版本：将对象±1，但求值结果是改变之前的值的副本 除非必须，否则不用后置版本（后置版本会进行原始值的储存。如果不需要修改前的值会造成浪费） 条件运算符 当条件运算符的两个表达式都是左值或者能转换为同一种左值类型时，运算结果为左值；否则结果为右值 条件运算符优先级非常低 位运算符 强烈建议位运算符只对无符号类型处理 e.g. 右移之后高位会插入符号位副本或者值为0的二进制位，视具体环境而定 sizeof运算符 12sizeof (type);//sizeof expr;// 第二章返回表达式结果类型的大小，并不实际计算运算对象的值。 sizeof返回值是一个常量表达式 对数组执行sizeof得到整个数组所占空间大小，等价于对数组中所有元素sizeof运算并求和 对string或vector运算只返回该类型固定部分的大小，不会计算对象中元素占用了多少空间 类型转换 隐式转换发生： 大多数表达式中，比int小的整型值会提升为较大整数类型 初始化过程中初始值转换为变量的类型 … 算术转换 如果带符号类型和无符号类型共存，且无符号类型不小于带符号类型，则带符号转换为无符号 显式转换 尽量避免使用强制类型转换！ 命名的强制类型转换： 1cast-name&lt;type&gt;(expr); static_cast 任何明确定义的类型转换，只要不包含底层const，都可以使用 1double slope = static_cast&lt;double&gt;(i)/j; 场景：较大算术类型赋值给较小的，执行显示转换后不会发出警告信息；对编译器无法自动执行的类型转换也非常有用 12void* p = &amp;d;double *dp = static_cast&lt;double*&gt;(p); const_cast 只能改变运算对象底层const 12const char *pc;char *p = const_cast&lt;char*&gt;(pc); 如果pc指向的char不是常量，那么转换获得写权限是合法行为，否则会产生未定义的后果 reinterpret_cast 从位模式上重新解释运算对象，依赖于机器，非常危险 旧式强制类型转换执行与之相似的功能 dynamic_cast 第五章 简单语句 空语句：语法上需要但逻辑上不需要时使用 复合语句：语法上需要一条语句但逻辑上需要多条语句时使用 条件语句 switch语句的case标签必须是整型常量表达式 switch的控制流：如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显式break这一过程 迭代语句 C++11 范围for语句 1for(auto &amp;r:v){} 范围for语句不能递增vector的对象，因为存储了end()的值，改变vec序列的元素数量后end函数的值可能无效 跳转语句 try语句块和异常处理 异常检测部分使用throw表达式引发异常 异常处理部分使用try语句块处理异常 throw 1throw expr; try 1234567try{ program-statements//需要异常检测的部分，可能抛出异常} catch(exception-declaration){//根据括号内异常声明，捕获并处理 handler} catch(exception-declaration){ handler} 找不到匹配的catch子句，程序将会转到terminate标准库函数，一般执行该函数将导致程序非正常退出 对于没有try语句块的异常也按照类似方式处理。 异常发生后确保对象有效、资源无泄漏、程序处于合理状态等非常困难但重要 第六章 基础 函数调用完成两项工作： 用实参初始化函数对应的形参 控制权转给被调用函数，主调函数的执行暂时中断 形参和实参存在对应关系，但没有规定实参的求值顺序 作用域和生命周期： 名字的作用域是程序文本的一部分，名字在其中可见 对象的生命周期是程序执行过程中该对象存在的一段时间 自动对象：只存在于块执行期间的对象 形参是一种自动对象，开始时为其申请存储空间，函数终止形参也被销毁 **局部静态对象：**将局部变量定义为static类型可以获得，在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁。 **函数声明、函数原型：**返回类型、函数名、形参类型描述函数接口 头文件声明，源文件定义 参数传递 值传递： 初始值被拷贝，对形参改动不会影响实参 指针形参时，可以通过解引用改变所指对象的值，但实参指针本身内容（指向的地址）不会发生改变 引用传递： 相当于实参别名，对形参的修改会影响实参 使用引用传递无需拷贝，如果不需要修改可以声明为常量引用 const形参和实参： 实参初始化形参时会忽略顶层const，即可以用非常量对象去初始化常量形参 尽量使用常量引用 数组形参： 数组无法被拷贝，所以无法以值传递方式使用数组参数；为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 123void print(const int*);void print(const int[]);void print(const int[10]); 应该提供额外信息确定数组确切尺寸： 包含结束标记（C风格字符串） 12345void print(const char* cp){ if(cp){ while(*cp) cout&lt;&lt;*cp++; }} 使用标准库规范 传递首元素和尾后元素指针 123void print(const int* beg,const int* end){ while(beg!=end) cout&lt;&lt;*beg++&lt;&lt;endl;} 显式传递数组大小形参 形参也可以是数组的引用 1void print(int (&amp;arr)[10]){}//维度10也是类型的一部分，传实参是要是含有10个整数的数组 传递多维数组 1void print(int (*matrix)[10],int rowSize); 仍然强调括号和维度必不可少，10为第二个维度，编译器会忽略第一个维度 含有可变形参的函数 如果所有实参类型相同，可以传递名为initializer_list的标准库类型（CPP11） 12345void error_msg(initializer_list&lt;string&gt; il){ for(auto beg = il.begin();beg!=il.end();++beg){ cout&lt;&lt;*beg&lt;&lt;endl; }} initializer_list中的对象永远是常量值，无法改变其值 在使用initializer_list时也可以同时拥有其他形参 省略符形参： 为了便于C++程序访问某些特殊的C代码，这些代码使用了varargs C标准库功能。不应用于其他目的 仅用于C和C++通用的类型 只能出现在形参列表最后一个位置 12void foo(...);void foo(params,...); 返回类型和return语句 不要返回局部对象的引用或指针 函数得到返回类型决定函数调用是否是左值，调用一个返回引用的函数得到左值，其他返回类型得到右值 如果返回常量引用，则不能给调用的结果赋值 返回数组指针： 1234int (*func(int i))[10];//必须指出数组的维度且跟在函数名之后auto func(int i) -&gt; int(*)[10];//尾置返回类型int odd[]={1,3,5,7,9};decltypr(odd) *arrPtr(int i){}//decltype不把数组转为指针，所以其结果是个数组，还需要加*返回指针 函数重载（overload） 同一作用域内名字相同但形参列表不同的若干函数 不允许两个函数除了返回类型外其他要素都相同 由于顶层const不影响传入函数的对象，仅改变参数的顶层const不构成重载，但型参数指针或者引用，改变底层const区分指向的是常量对象还是非常量对象构成重载。 12345Record lookup(Account&amp;);Record lookup(const Account&amp;);//两个是重载函数Record lookup(Account);Record lookup(const Account);//两个不是重载函数 const_cast和重载 1234567const string &amp;shorterString(const string&amp; s1,const string &amp;s2);string&amp; shorterString(string&amp; s1,string&amp; s2){ auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;(r);} 调用重载函数 三种结果： 找到与实参最佳匹配的函数，并生成调用该函数的代码 找不到任何一个函数与调用的实参匹配，编译器发出无匹配错误信息 有多于一个函数可以匹配，但都不是最佳选择，二义性调用 重载和作用域 **C++中名字查找发生在类型检查之前：**局部作用域中声明的变量或函数与外层变量或函数重名时，编译器寻找到局部声明后，会忽略掉外层作用域中所有同名实体。之后才会检查调用函数是否有效。 特殊用途语言特性 默认实参 可以为一个或多个形参定义默认值，但一旦某个形参被赋予默认值，它后面的所有形参都必须有默认值 函数调用时实参按照位置解析，默认实参则负责填补函数调用缺少的尾部实参 多次声明同一个函数，在给定的作用域中一个形参只能被赋予一次默认实参，也即后续的声明都只能为之前没有默认值的形参添加默认实参，而且该形参右侧所有形参都必须有默认值 123string screen(sz,sz,char=' ');string screen(sz,sz,char='*');//错误，重复声明string screen(sz=24,sz=22,char);//正确，添加默认实参 局部变量不能作为默认实参 内联函数 将操作封装成函数可读性更好，可重复利用，修改更方便，但函数调用也会增加时间开销 将函数指定为内联函数，可避免函数调用的开销，将函数在每个调用点上“内联地”展开 内联说明只是向编译器发出的请求，编译器可以忽略该请求 内联机制一般用于优化规模较小、流程直接、调用频繁的函数，很多编译器都不支持内联递归函数。 constexpr函数 指能用于常量表达式的函数 定义时的要求： 函数返回类型和所有形参类型都得是字面值类型 函数体中必须有且只有一条return语句 12constexpr int new_sz(){return 42;}constexpr int foo = new_sz(); 执行该初始化时，编译器把调用替换为结果值，且为了能在编译过程中随时展开，constexpr函数被隐式指定为内联函数。 constexpr函数返回值可以为非常量 内联函数和constexpr函数通常定义在头文件内，因为编译器要展开函数不仅要声明还需要定义，且两类函数可能在程序中定义不止一次，此时必须保证在所有源文件中定义完全相同，放在头文件中可以确保这一点。 调试帮助 程序包含一些用于调试的代码，只在开发时使用，程序准备发布时，先屏蔽掉调试代码。该方法用到两项预处理功能 assert预处理宏 cassert头文件 assert(expr); 如果expr为0，输出信息终止执行；expr为真，什么也不做 常用于检查不能发生的条件 NDEBUG预处理变量 123456void print(size_t sz){#ifndef NDEBUG cerr&lt;&lt;_ _func_ _&lt;&lt;endl; assert(sz&gt;10);#endif} _ _FILE_ _存放文件名的字符串字面值 _ _LINE_ _存放当前行号的整型字面值 _ _TIME_ _存放文件编译时间的字符串字面值 _ _DATE_ _存放文件编译日期的字符串字面值 函数匹配 选定候选函数：与被调用函数同名，声明在调用点可见 选出可行函数：形参数量与调用实参数量相等，实参类型与对应形参类型相同且能转换 寻找最佳匹配（如果有）：实参和形参类型最接近的 最接近的定义（排序）： 精确匹配：实参形参类型相同；实参从数组类型或函数类型转换为对应指针类型；实参添加或删除顶层const const转换实现匹配 类型提升实现的匹配 算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样） 类类型转换实现的匹配 函数指针 声明一个指向函数的指针，只需要用指针替换函数名即可。 12345bool (*pf)(const string&amp;,const string&amp;);pf = lengthCompare;pf = &amp;lengthCompare;bool b1 = pf(&quot;aaaa&quot;,&quot;dddd&quot;);bool b2 = (*pf)(&quot;aaaa&quot;,&quot;dddd&quot;); 重载函数的指针： 使用重载函数时，上下文必须清晰界定到底选用哪个函数 123void ff(int*);void ff(unsigned int);void (*pf)(unsigned int)=ff; 编译器通过指针类型决定选用哪个函数，必须与重载函数中的一个精准匹配 函数指针形参： 1void useBigger(const string&amp; s1,const string&amp; s2,bool (*pf)(const string&amp;,const string&amp;)); 使用typedef或declype定义别名简化 返回指向函数的指针 123456using F = int(int*,int*);using PF = int(*)(int*,int);PF f1(int);F* f1(int);int (*f1(int))(int*,int);atuto f1(int)-&gt;int(*)(int*,int); 第七章 类的基本思想：数据抽象、封装 数据抽象依赖于接口和实现分离的技术 定义在类内部的函数是隐式的inline函数 *this的类型默认情况下是指向类类型的非常量版本的常量指针T const 将const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针（const T *const)，有助于提高函数的灵活性 常量对象、常量对象的引用或指针都只能调用常量成员函数 构造函数： 构造函数不能被声明成const,当创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此在const对象构造过程中构造函数可以向其写值。 默认构造函数：如果存在类内初始值，用它来初始化成语；否则默认初始化该成员。 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数 如果需要默认行为，可以在参数列表后面加上=default要求编译器生成构造函数（CPP11） 构造函数初始值列表 1Sales_date(const string&amp; s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n){} 拷贝、赋值、析构 访问控制和封装 public:成员在整个程序内可被访问，public成员定义了类的接口 private：成员可被类的成员函数访问，隐藏类的实现细节 class/struct class的默认访问权限为private,struct的默认访问权限为public 友元 类可以允许其他类或函数访问它的非公有成员，方法是令其他类或函数成为它的友元 1friend std::istream &amp;read(std::istream&amp;,Sales_data&amp;); 友元声明只能出现在类定义的内部，但不受所声明区域访问控制级别的约束 一般最好在类定义开始或结束前的位置集中声明友元 友元的声明仅指定了访问权限，如果希望类的用户能调用某个友元函数，则必须在友元声明之外再专门对函数进行一次声明 类的其他特性 可变成员函数：永远不会是const，即使它是const对象的成员 mutable关键字 类可以把其他的类定义为友元，也可以把其他类的成员函数定义为友元（必须指出该成员函数属于哪个类） 友元不存在传递性 就算在类内部定义了友元函数，也必须在类外部提供相应的声明 类的作用域 类外部的成员函数，由于返回类型通常在函数名之前，所以返回类型中使用的名字都位于类的作用域之外。这时，必须指明返回类型是哪个类的成员。 名字查找 在名字所在块中寻找其声明语句，只考虑在名字使用之前出现的声明 如果没找到，继续查找外层作用域 如果最终没有找到匹配的声明，则程序报错 对类内成员函数而言，解析其中的名字的方式与上述稍有区别 在成员函数内查找该名字声明，只考虑在名字使用前出现的声明 如果没找到，在类内继续查找，这时类的所有成员都可以被考虑 类内也没找到，在成员函数定义之前的作用域继续查找 构造函数plus 构造函数的初始值有时必不可少 e.g. 如果成员是const或者引用或者某种未提供默认构造函数的类类型的话，必须将其初始化 1234567891011121314151617class ConstRef{public: ConstRef(int ii);private: int i; const int ci; int &amp;ri;};ConstRef::ConstRef(int ii){ i = ii; ci = ii;//错误，不能给const赋值 ri = i;}ConstRef::ConstRef(int ii):i(ii),ci(ii),ri(i){}//正确 成员初始化顺序 初始化列表不限定初始化的具体执行顺序，在初始化列表中的顺序可能不是初始化顺序。 成员初始化顺序与它们在类定义中的出现顺序一致。 123456class X{ int i; int j;public: X(int val):j(val),i(j){}//先初始化i，但此时j未定义！}; 尽量避免使用某些成员初始化其他成员 构造函数中的默认实参 如果一个构造函数为所有参数都指定了默认实参，则它实际上也定义了默认构造函数 委托构造函数（C++11） 委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。 12345678class X{ int i; int j; double k;public: X(int val,int val2,double dval):i(val),j(val2),k(dval){}//被委托构造 X(double val):X(0,0,val){}//委托构造}; 被委托函数的函数体也会被执行，然后控制权才会交还给委托者的函数体 隐式的类类型转换 转换构造函数：能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则 编译器只能自动执行一步类类型转换 12item.combine(&quot;9-999-99999-9&quot;);//错误，这是先从字面值转换为string再转换为Sales_dataitem.comnime(string(&quot;9-999-99999-9&quot;)); explicit声明构造函数阻止隐式转换 explicit关键字只对一个实参的构造函数有效，且只能在类内声明构造函数时使用 explicit构造函数只能用于直接初始化，不能用于拷贝初始化 12Sales_data item1(null_book);//√Sales_date item2 = null_book;//× explicit构造函数不能隐式转换，但可人为将其用于显式转换。 聚合类 条件： 所有成员都是public的 没有定义任何构造函数 没有类内初始值 没有基类没有虚函数 这样的类可以由封闭的大括号用逗号分隔开初始化列表。 字面值常量类 数据成员都是字面值类型的聚合类 类的静态成员 成员与类本身直接相关而非与各个对象相关 static关键字 使用 123r = Account::rate();//使用作用域运算符访问静态成员r = ac.rate();//类的对象、指针、引用也可以直接访问//成员函数不需其他即可访问","link":"/2023/04/12/%E3%80%8ACPP-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%881-7%E7%AB%A0%EF%BC%89/"},{"title":"《MySQL必知必会》笔记","text":"《MySQL必知必会》笔记 1-7章 主键：一列（多列组合），其值能唯一区分表中每个行 主键值规则：任意两行不具有相同的主键值；主键列不允许NULL值 创建数据库 1CREATE DATABASE db; 选择数据库 USE语句 显示信息 123456//SHOW语句SHOW DATABASES;//获得数据库表SHOW TABLES;//获得数据库内的表SHOW COLUMNS FROM table1;//显示表列SHOW STATUS;//显示广泛的服务器状态信息... 检索信息 1234//SELECT语句，给出想选择什么，从什么地方选SELECT prod_name FROM products;SELECT prod_id,prod_name,prod_price FROM products;SELECT * FROM products; 检索不同数据，只返回不同的值，DISTINCT关键字 1SELECT DISTINCT vend_id FROM products; 限制检索结果，LIMIT子句 123SELECT prod_name FROM products LIMIT 5;//前5行SELECT prod_name FROM products LIMIT 5,5;//从第5行开始返回5行//没有足够的行只返回能返回的所有行 排序，ORDER BY子句，默认升序，LIMIT子句要在ORDER BY之后 DESC关键字降序排列，只应用于其之前的列名，想在多个列降序，需要对每个列指定DESC关键字 123SELECT prod_name FROM products ORDER BY prod_name;SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price,prod_name;//按多个列排序，按照ORDER BY规定的顺序排序SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC,prod_name; WHERE子句指定搜索条件 1SELECT prod_name,prod_price FROM products WHERE prod_price=2.50; BETWEEN AND关键字：在指定的两个值之间（闭区间） 1SELECT prod_name, prod_price FROM products WHERE prod_price BETWEEN 5 AND 10; 空值：NULL，用IS NULL检查 1SELECT cust_id FROM customers WHERE cust_email IS NULL; WHERE子句可以通过AND或OR组合 12SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id=1003 AND prod_price&lt;=10;SELECT prod_name,prod_price FROM products WHERE vend_id=1002 OR vend_id=1003; AND优先级更高，先处理AND IN操作符，与OR功能相同但更直观，计算次序更清楚，比OR执行更快，可以包含其他SELECT子句 1SELECT prod_name,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name; NOT在WHERE子句中否定后跟条件 MySQL支持使用NOT对IN、BETWEEN和 EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件 取反有很大的差别 第8章 用通配符进行过滤 通配符（wildcard）用来匹配值的一部分特殊字符 搜索模式（search pattern）由字面值、通配符或两者组合构成的搜索条件。（如’jet%‘，’%anvil%'） %通配符 %通配符表示任何字符出现任意次数 123SELECT prod_id,prod_name FROM products WHERE prod_name LIKE 'jet%';//找出所有以jet开头的SELECT prod_id,prod_name FROM products WHERE prod_name LIKE '%anvil%';//所有包含anvil的SELECT prod_id,prod_name FROM products WHERE prod_name LIKE 's%e';//所有以s开头以e结尾的 %通配符不能匹配NULL 下划线通配符 _通配符与%用途一样，但只匹配单个字符 1SELECT prod_id,prod_name FROM products WHERE prod_name LIKE '_ ton anvil'; 技巧 不要过度使⽤通配符。如果其他操作符能达到相同的⽬的，应该使⽤其他操作符。 在确实需要使⽤通配符时，除⾮绝对有必要，即使在有必要的情况下也不要把它们⽤在搜索模式的开始处。 把通配符置于搜索模式的开始处，搜索起来是最慢的，因为这样就是全⽂检索了。（比如%jet会对每个对象一直匹配至最后几个字符才会比较jet） 第9章 正则表达式进行搜索 正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。 1SELECT prod_name FROM products WHERE prod_name REGEXP '1000' ORDER BY prod_name;//prod_name包含1000的所有行 REGEXP告诉SQL后面跟的东西作为正则表达式处理。 12SELECT prod_name FROM products WHERE prod_name REGEXP '1000' ORDER BY prod_name;SELECT prod_name FROM products WHERE prod_name LIKE '1000' ORDER BY prod_name; 第一句会返回一行，第二句不返回数据 因为LIKE匹配整个列（将搜索模式和整个列值做比较，找值等于1000的行），REGEXP在值内进行匹配（每个列值中包含搜索模式1000的行） .匹配任意一个字符。 OR匹配|： 1SELECT prod_name FROM products WHERE prod_name REGEXP '1000|2000' ORDER BY prod_name; 匹配几个字符之一[]： 1SELECT prod_name FROM products WHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name;//匹配prod_name中包含 1 ton/2 ton/3 ton的 [123] Ton是[1|2|3] Ton的缩写，一定要把或的内容括在一个集合里，否则会应用于整个串 否定：[^123]匹配除这些字符外的任何东西 匹配范围： 使用-定义一个范围 1SELECT prod_name FROM products WHERE prod_name REGEXP '[1-5] Ton' ORDER BY prod_name; 匹配特殊字符： 使用\\为前导 1SELECT vend_name FROM vendors WHERE vend_name REGEXP '\\.' ORDER BY vend_name; 匹配字符类： 匹配多个实例： 1SELECT prod_name FROM products WHERE prod_name REGEXP '\\\\([0-9] sticks?\\\\)' ORDER BY prod_name; 说明：\\\\(匹配左括号，[0-9]匹配任意数字，s?匹配s出现0次或1次，也即stick或者sticks，\\\\)匹配右括号。 1SELECT prod_name FROM products WHERE prod_name REGEXP '[[:digit:]]{4}' ORDER BY prod_name; 说明：[:digit:]匹配任意数字，{4}要求前面的字符出现4次，即任意4位数字。 定位符： 1SELECT prod_name FROM products WHERE prod_name REGEXP '^[0-9\\\\.]' ORDER BY prod_name;、、匹配以数字和小数点开头的所有产品 ^在集合中表示否定该集合，在集合外表示文本开始处的定位符 利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使 REGEXP的作用与LIKE一样（LIKE匹配整个串，REGEXP匹配子串） 第10章 创建计算字段 只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。 拼接，将值联结到一起构成单个值 1SELECT Concat(vend_name,'(',vend_country,')') FROM vendors ORDER BY vend_name; 多数DBMS使用+或||来实现拼接， MySQL则使用Concat()函数来实现。 **Trim() LTrim() RTrim()**去除值左右的空格 1SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')') FROM vendors ORDER BY vend_name; AS关键字赋予别名（导出列） 1SELECT Concat(vend_name,'(',vend_country,')') AS vend_title FROM vendors ORDER BY vend_name; 任何客户机应用都可以按名引用 这个列，就像它是一个实际的表列一样 第11章 使用数据处理函数 文本处理函数： 1SELECT vend_name, Upper(vend_name) AS vend_name_upcase FROM vendors ORDER BY vend_name; Soundex()是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，主要目的是根据声音比较字符串之间的相似性。 12SELECT Soundex('sea') AS sea_soundex, Soundex('see') AS see_soundex;//均为5000SELECT cust_name,cust_contact FROM customers WHERE Soundex(cust_contact) = Soundex('Y Lie');//返回Y Lee一行 日期和时间处理函数： 日期和时间采用相应的数据类型和特殊的格式存储，应用程序一般不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。 1SELECT cust_id,order_num FROM orders WHERE Date(order_date)='2005-09-01' 应该总是使用yyyy-mm-dd格式，如果需要日期则使用Date()，即便知道相应的列只包含日期 检索某一段日期的数据 12SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';SELECT cust_id,order_num FROM orders WHERE Year(order_date)=2005 AND Month(order_date)=9; 数值处理函数： 第12章 汇总数据 AVG() 对表中特定列或特定行的平均值 12SELECT AVG(prod_price) AS avg_price FROM products;SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id=1003; 对多个列分别求平均值需要使用多个AVG()函数 COUNT() 计数 COUNT(*)对行数目进行计数 COUNT(column)对列中有值的进行计数，忽略NULL 1SELECT COUNT(cust_email) AS num_cust FROM customers; MAX()/MIN() 要求指定列名，忽略NULL SUM() 返回指定列值的总和，也可以合计 计算值 12SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num=20005;SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num=20005; 聚集不同值 在上述函数中使用DISTINCT关键字 1SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id=1003; DISTINCT只能用于列名，不能用于计算或表达式 第13章 分组数据 GROUP BY子句创建分组 1SELECT vend_id,COUNT(*) AS num_prods FROM products GROUP BY vend_id; 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 GROUP BY子句可以包含任意数目的列。 HAVING子句过滤分组 WHERE过滤的是行，HAVING过滤的是分组，（WHERE在分组前过滤数据，HAVING在分组后过滤数据）HAVING支持所有WHERE操作符 123SELECT cust_id,COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*)&gt;=2;SELECT vend_id,COUNT(*) AS num_prods FROM products WHERE prod_price&lt;=10 GROUP BY vend_id HAVING COUNT(*)&gt;=2;//有2个以上价格为10以上的产品的供应商，返回 1003 4、1005 2两组SELECT vend_id,COUNT(*) AS num_prods FROM products GROUP BY vend_id HAVING COUNT(*)&gt;=2;//返回四组，没有过滤价格为10以上 第14章 使用子查询 一般来说子查询最好不要嵌套太多层 第15章 联结表 关系表的设计就是要保证把信息分解成多个表，一类数据 一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 使用联结可以将储存在多个表中的数据通过单条SELECT语句检索出，联结不是物理实体，存在于查询的执行当中。 创建联结：规定要联结的所有表以及如何关联即可： 1SELECT vend_name,prod_name,prod_price FROM vendors,products WHERE vendors.vend_id=products.vend_id ORDER BY vend_name,prod_name; vend_name在一个表中，prod_name和prod_price在另一个表中；WHERE子句联结两个表，这里需要完全限定列名，避免出现二义性。应该保证所有联结都有正确的WHERE子句。 以下内部联结语法返回同样的内容 1SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id=products.vend_id ORDER BY vend_name,prod_name; 联结表的数目没有限制，基本规则也相同，首先列出所有表，然后定义表之间的关系 但是不要联结不必要的表，联结越多性能下降越多。 第16章 创建高级联结 使用表别名： 1SELECT cust_name,cust_concat FROM customers AS c, orders AS o,orderitems AS oi WHERE c.cust_id=o.cust_id AND oi.order_num=o.order_num AND prod_id='TNT2'; 自联结： 123//查找ID为DTNTR物品的供应商生产的其他物品SELECT prod_id,prod_name FROM products WHRER vend_id=(SELECT vend_id FROM products WHERE prod_id='DTNTR');//子查询SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2 WHERE p1.vend_id=p2.vend_id AND p2.prod_id='DTNTR';//自联结查询，别名表解决二义性问题 有时候处理联结远比处理子查询快得多。应该试一 下两种方法，以确定哪一种的性能更好。 自然联结： 标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。 外部联结： 内部联结关联两个表中有关系的行，外部联结还包括没有关联的行 使用OUTER JOINT时必须用RIGHT或LEFT指定包括其所有行的表，RIGHT指出右边的表包含所有行，LEFT指出左边。 12345SELECT customers.cust_id,orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id;SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id; 第17章 组合查询 UNION规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔 UNION中的每个查询必须包含相同的列、表达式或聚集函数 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型 UNION从查询结果集中自动去除重复的行，如果要保留可以使用UNION ALL 在用UNION组合查询时，只 能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后，但用来排序所有SELECT语句返回的结果 第18章 全文本搜索 并非所有引擎都支持全文本搜索，InnoDB不支持但MyISAM支持 一般在创建表时启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句。 123456789CREATE TABLE productnotes( note_id int NOT NULL AUTO INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL, PRIMARY KEY(note_id), FULLTEXT(note_text))ENGINE=MyISAM; 不要在导入数据时使用FULLTEXT. 更新索引要花时间，如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然 后再修改表，定义FULLTEXT。 索引之后使用Match()和Against()执行全文本搜索，前者指定被搜索的列，后者指定要使用的搜索表达式。 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit'); 两行含有rabbit，被返回 传递给Match()的值必须和FULLTEXT()中定义的相同，如果指定多个列必须列出它们且次序正确 全文本搜索结果的排序返回以文本匹配的良好程度决定 1SELECT note_text, Match(note_text)Against('rabbit') AS score FROM productnotes; Match(note_text)Against(‘rabbit’)建立了一个计算列包含全文本搜索计算出的匹配度，该得分由行中词的数目、唯一词的数目、整个索引中词的数目以及包含该词的行的数目计算得出。 查询扩展（version&gt;=4.1.1）： 举例：找出包含词anvils的注释与其他有关行（可能不包含该词） MySQL执行过程： 执行一个基本的全文本搜索，找出所有匹配搜索条件的行 检查这些行选择所有有用的词 用原来条件+有用的词再执行一次全文本搜索 1SELECT note_text FROM productnotes WHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION); 查询扩展极大地增加了返回的行数，但这样做也增加了 你实际上并不想要的行的数目。 表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好。 布尔文本搜索： 1SELECT note_text FROM productnotes WHERE Match(note_text)Against('heavy -rope*' IN BOOLEAN MODE);//匹配包含heavy但不包含任意以rope开始的词的行 在布尔方式中，不按等级值降序排序返回的行 12345678910SELECT note_text FROM productnotes WHERE Match(note_text)Against('+rabbit +bait' IN BOOLEAN MODE);//包含rabbit和bait的行SELECT note_text FROM productnotes WHERE Match(note_text)Against('rabbit bait' IN BOOLEAN MODE);//包含rabbit或bait的行SELECT note_text FROM productnotes WHERE Match(note_text)Against('&quot;rabbit bait&quot;' IN BOOLEAN MODE);//包含短语rabbit bait的行SELECT note_text FROM productnotes WHERE Match(note_text)Against('&gt;rabbit &lt;bait' IN BOOLEAN MODE);//包含rabbit或bait的行，前者优先级提高，后者优先级降低SELECT note_text FROM productnotes WHERE Match(note_text)Against('+safe +(&lt;companion)' IN BOOLEAN MODE);//包含safe和companion的行，前者优先级提高，后者优先级降低 第19章 插入数据 插入完整的行： 1INSERT INTO Customers VALUES(NULL,'Pep E. LaPew','100 Main Street','Los Angeles','CA','90046','USA',NULL,NULL); 各个列必须以它们在表定义中出现的次序填充 上面语法简单但并不安全，高度依赖表中列的定义次序，更安全的方法如下： 12INSERT INTO Customers(cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email) VALUES(NULL,'Pep E. LaPew','100 Main Street','Los Angeles','CA','90046','USA',NULL,NULL); MySQL将用VALUES列表中的相应值填入列表中的对应项 如果列定义为允许NULL值切表定义中给出默认值，则在插入操作中可以省略这些列。 INSERT LOW-PRIORITY INTO可以降低插入的优先级 插入多个行： VALUES中间用逗号分隔，每组值用一对圆括号括起来 单条语句多个插入比使用多条语句快 插入检索出的数据： 将SELECT语句的结果插入表中 假设想从另一个表中的客户列表合并到现有的customers表 1INSERT INTO customers(...) SELECT ... FROM custnew; …中的列名不一定要求匹配，两个位置的…分别对应 第20章 更新和删除数据 UPDATE语句更新表中所有行或特定行 1UPDATE customers SET cust_email='elmer@fudd.com',cust_name='The Fudds' WHERE cust_id=10005; 以要更新的表名开始，SET赋新值，WHERE指定要更新的行 UPDATE IGNORE可以在更新多行时即便发生错误也可以继续更新 DELETE从表中删除行 1DELETE FROM customers WHERE cust_id=10006; 如果要删除表中所有行，可以使用TRUNCATE TABLE语句，该语句删除原来的表并重新创建一个，所以速度更快。 第21章 创建和操纵表 创建表 12345678910111213CREATE TABLE customers IF NOT EXISTS( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(5) NULL, cust_zip char(10) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(255) NULL, PRIMARY KEY (cust_id))ENGINE=InnoDB; 主键必须唯一，如果使用单个列则值必须唯一；如果使用多个列则列的组合值必须唯一，主键不允许NULL值的列。 AUTO_INCREMENT告诉MySQL，本列每增加一行时自动对该列增量赋予该行一个可用值。 每个表只允许一个AUTO_INCREMENT列，而且必须被索引（如，通 过使它成为主键） 获得AUTO_INCREMENT列的值 1SELECT last_insert_id(); 指定默认值： 在CREATE TABLE时列定义中用DEFAULT关键字指定 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。 引擎类型： 外键不能跨引擎，即使用一个引擎的表不能引用使用不同引擎的表的外键 更新表 12ALTER TABLE vendors ADD vend_phone CHAR(20);ALTER TABLE vendors DROP COLUMN vend_phone CHAR(20); ALTER TABLE之后给出要改的表名，所做更改的列表 ALTER TABLE定义外键： 1ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY(order_num) REFERENCES orders; 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份 删除表、重命名表 12DROP TABLE customers2;RENAME TABLE customers2 TO custermers, customers3 TO custmers; 第22章 使用视图（&gt;= MySQL 5） 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 理解 1SELECT cust_name,cust_contact FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id AND orderitems.order_num=orders.order_num AND prod_id='TNT2'; 该查询检索订购了某个特定产品的用户。 如果把整个查询包装成一个虚拟表名为productcustomers，则检索相同数据的语句可以写成： 1SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id='TNT2'; 视图本身不包含数据，在添加或更改底层表中的数据时，视图将返回改变后的数据 规则和限制 唯一命名。 必须具有足够的访问权限才能创建视图。 可以嵌套。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也 含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 不能索引，也不能有关联的触发器或默认值 可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。 使用视图 CREATE VIEW创建视图 DROP VIEW删除视图 SHOW CREATE VIEW查看创建视图的语句 更新视图时可以先DROP再CREATE，也可直接用CREATE OR REPLACE VIEW 12CREATE VIEW productcustomers AS SELECT cust_name,cust_contact FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id AND orderitems.order_num=orders.order_num AND prod_id='TNT2'; 可以对视图进行更新（INSERT/UPDATE/DELETE），其实是对其基表进行更新 但是如果视图定义中有分组、联结、子查询、并、聚集函数、DISTINCT、导出列则不能更新视图（MySQL5中） 第23章 使用存储过程(MySQL5) 基本 存储过程简单来说，就是为以后的使用而保存 的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。 执行存储过程（调用） 1CALL productpricing(@pricelow,@pricehigh,@priceaverage);//计算并返回产品最低、最高、平均价格 创建存储过程 1234CREATE PROCEDURE productpricing()BEGIN SELECT AVG(prod_price) AS priceaverage FROM products;END; 在命令行执行上述过程可以先用DELIMITER //更改分隔符为//，这样可以保留存储过程中的分号 删除存储过程 1DROP PROCEDURE productpricing; 使用参数 123456789101112CREATE PROCEDURE productpricing(OUT pl DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT MIN(prod_price) INTO pL FROM products; SELECT MAX(prod_price) INTO ph FROM products; SELECT AVG(prod_price) INTO pa FROM products;END; 也可以使用IN参数传入 第24章 使用游标（MySQL5） 有时，需要在检索出来的行中前进或后退一行或多行。这就是使用 游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游 标之后，应用程序可以根据需要滚动或浏览其中的数据。 第25章 使用触发器（MySQL5） 想要某条语句（或某些语句）在事件发生时自动执行（如每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确） 触发器是MySQL响应DELETE/INSERT/UPDATE语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句） 创建触发器 需要给出信息：唯一的触发器名、触发器关联的表、触发器应该相应的活动、触发器何时执行 1CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added'; 代码对每个插入行执行，显示Product added 视图不支持触发器 每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL 将不执行AFTER触发器（如果有的话） 删除触发器 1DROP TRIGGER newproduct; 触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建 使用触发器 INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点： 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值） 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 1CREATE TRIGGER neworder AFTER INSERT ON orders FOR EACH ROW SELECT NEW.order_num INTO @P; 创建触发器newoeder，在新数据插入到orders表后，MySQL生成一个新订单号保存到order_num中，触发器取得值并返回 MySQL5后触发器不支持返回结果集，需要用一个变量接收输出 12INSERT INTO orders(order_date, cust_id) VALUES(NOW(), 10001);SELECT @p; 通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据） DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点: 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行 OLD中的值全都是只读的，不能更新 12345CREATE TRIGGER deleteorder BEFORE DELETE ON orders FOR EACH ROWBEGIN INSERT INTO archive_orders (order_num,order_date,cust_id) VALUES(OLD.order_num,OLD.order_date, OLD.cust_id);END;DELETE from orders where YEAR(order_date) = 2019; UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点: 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）； OLD中的值全都是只读的，不能更新 第26章 管理事务处理 并非所有引擎都支持事务处理 事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行 MySQL使用下面语句标识事务开始 1START TRANSACTION 测试： 123456SELECT * FROM ordertotals;//不为空START TRANSACTION;//开始事务DELETE FROM ordertotals;//清空该表SELECT * FROM ordertotals;//表为空ROLLBACK;//回退SELECT * FROM ordertotals;//回退后表不为空 事务处理用来管理INSERT、UPDATE和 DELETE语句。不能回退SELECT语句。（这样做也没有什么意义。）不能回退CREATE或DROP操作。 123START TRANSACTION;//开始事务DELETE FROM ordertotals;//清空该表COMMIT;//提交事务 当COMMIT或ROLLBACK执行后，事务会自动关闭 更复杂的事务处理可能需要部分提交或回退，这样做需要在事务处理块的合适位置放置占位符，如果需要回退可以回退到某个占位符。 123SAVEPOINT delete1;ROLLBACK TO delete1;RELEASE SAVEPOINT;//释放保留点 保留点越多越好 可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，就越能按意愿灵活地进⾏回退。 第28章 安全管理 MySQL用户账号和信息存储在名为mysql的MySQL数据库中 12345USE mysql;SELECT user FROM user;CREATE USED ben INDENTIFIED BY 'p@$$w0rd';RENAME USER ben TO bforta;DROP USER bforta; 第29章 数据库维护 ANALYZE TABLE，用来检查表键是否正确 CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对 索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删 除的链接并进行键检验，QUICK只进行快速扫描。如下所示，CHECK TABLE发现和修复问题 第30章 改善性能 如果你遇到显著的性能不良，可使用SHOW PROCESSLIST 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。 使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快 决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列） LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE 你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条 SELECT语句和连接它们的UNION语句，你能看到极大的性能改进 必须索引数据库表以改善数据检索的性能。确定索引什么不是一 件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花 的时间太长，则可以断定其中使用的列（或几个列）就是需要索 引的对象","link":"/2023/04/12/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E7%AC%94%E8%AE%B0/"},{"title":"二分查找模板","text":"二分查找 假设目标值在闭区间[l,r][l,r][l,r]中，每次查找将区间长度缩小一半，当l=rl=rl=r时，找到目标值 模板1： 12345678int bSearch1(int l,int r){ while(l&lt;r){ int mid = (l+r)&gt;&gt;1; if(check(mid)) r = mid; else l = mid+1; } return l;} 模板2： 12345678int bSearch2(int l,int r){ while(l&lt;r){ int mid = (l+r+1)&gt;&gt;1; if(check(mid)) l = mid; else r = mid-1; } return l;} 模板1就是在满足check()的区间内找到左边界，模板2在满足check()的区间内找到右边界。 如果目标是下面这个v，那麽就必须使用模板 1 …vooooooooo 假设经由 check 划分后，整个区间的属性与目标v如下，则我们必须使用模板 2 oooooooov… 使用步骤： 确定check函数 根据check的结果看区间更新方式是要更新左界还是右界 如果是更新左界，则计算mid要+1 求解立方根 12345678910111213141516171819202122#include &lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#define eps 0.0001fusing namespace std;int main() { double a; while(cin&gt;&gt;a){ double l = min(-1.0,a); double r = max(1.0,a); while(fabs(r-l)&gt;eps){ double mid = (l+r)/2; if(mid*mid*mid&lt;a){ l = mid; } else r = mid; } cout &lt;&lt; setprecision(1) &lt;&lt; fixed &lt;&lt; l &lt;&lt; endl; } return 0;}","link":"/2023/04/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"},{"title":"大根堆","text":"大根堆的插入与删除操作 每个节点的值都大于等于其子节点的树为大根树 大根堆既是大根树也是完全二叉树 插入操作 因为是完全二叉树，所以插入操作需要把元素插入新节点，然后沿着新节点到根节点的路径，执行起泡操作，直到父元素大于等于新元素，O(logn) 123456789101112void maxHeap::push(const int&amp; ele){ if(heapSize==arr.size()-1){ //内部数组已满，再插入新元素数组长度加倍 } int curNode = ++heapSize; while(curNode!=0&amp;&amp;heap[curNode/2]&lt;ele){ //如果根节点小于插入元素 heap[curNode] = heap[curNode/2]; curNode /= 2; } heap[curNode] = ele;} 删除操作 大根堆中删除元素就是删除根节点的元素，删除之后需要进行重构。 将完全二叉树最后一个元素取出，删除该节点，把该元素插入到根节点中，在逐层将该元素沉底：选择左右孩子中较大的比该节点大的元素交换，直到满足大根堆要求。","link":"/2023/04/12/%E5%A4%A7%E6%A0%B9%E5%A0%86/"},{"title":"字典树/前缀树（Trie）","text":"字典树的数据结构和常用操作 用于快速查询某个字符串/字符前缀是否存在 可以看作用边表示有无字符，用点记录是否为单词结尾和后续字符串是什么，从根节点到某一节点的路径代表了一个字符串 操作1：插入 12345678910void insert(string word){ Trie* root = this; for(auto w : word){ if(root-&gt;children[w-'a']==NULL){ root-&gt;children[w-'a'] = new Trie(); } root = root-&gt;children[w-'a']; } root-&gt;isEnd = true;} 操作2：查询 1234567891011bool search(string word){ Trie* root = this; for(auto w : word){ int i = w-'a'; if(root-&gt;children[i]==NULL){ return false; } root = root-&gt;children[i]; } return root-&gt;isEnd;} 操作3：查询前缀 1234567891011bool startsWith(string prefix){ Trie* root = this; for(auto w : word){ int i = w-'a'; if(root-&gt;children[i]==NULL){ return false; } root = root-&gt;children[i]; } return true;} 完整数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Trie{private: bool isEnd; Trie* children[26];public: Trie(){ isEnd = false; for(int i = 0;i&lt;26;i++) children[i] = NULL; } ~Trie(){ for(int i = 0;i&lt;26;i++) { if(children[i]!=NULL) delete children[i]; } } //搜索和插入都可以理解成构造边的过程， //插入中对字符串中每一个字符，初始化当前root的children，相当于生成对应该字符的一条边 //搜索中可以理解成看所有的边是否都存在，如果有一条边不存在（遍历过程中子节点为NULL）， //或者所有边都存在但最终节点之后还有连续的边（isEnd=false），则查找过程失败 void insert(string word){ Trie* root = this; for(auto w : word){ if(root-&gt;children[w-'a']==NULL){ root-&gt;children[w-'a'] = new Trie(); } root = root-&gt;children[w-'a']; } root-&gt;isEnd = true; } bool search(string word){ Trie* root = this; for(auto w : word){ int i = w-'a'; if(root-&gt;children[i]==NULL){ return false; } root = root-&gt;children[i]; } return root-&gt;isEnd; } bool startsWith(string prefix){ Trie* root = this; for(auto w : prefix){ int i = w-'a'; if(root-&gt;children[i]==NULL){ return false; } root = root-&gt;children[i]; } return true; } };","link":"/2023/04/12/%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88Trie%EF%BC%89/"},{"title":"额","text":"之前的blog换电脑没了，吐了","link":"/2023/04/12/%E9%A2%9D/"},{"title":"快速排序","text":"从a[0:n-1]中选择一个元素作为支点，组成中间段 把剩余元素分为左段left和右段right，使左段元素的关键字都不大于支点关键字；右段元素都不小于支点关键字 左段递归快速排序 右段递归快速排序 最终结果按左、中、右段排列 1234567891011121314151617181920212223void partition(int s[],int l,int r){ if(l&lt;r){ int i = l,j = r; int tmp = s[l]; while(i&lt;j){ while(i&lt;j&amp;&amp;s[j]&gt;=tmp)//从右向左找第一个小于支点的元素 --j; s[i] = s[j];//小于支点的元素放在支点左侧 while(i&lt;j&amp;&amp;s[i]&lt;=tmp)//从左向右找第一个大于支点的元素 ++i; if(i&lt;j) s[j] = s[i]; } s[l] = tmp;//两次交换后空出了s[i]，填入支点元素 return i; }}void quickSort(int A[],int low,int high){ if (low &lt; high) { int pivot = Paritition1(A, low, high); quickSort(A, low, pivot - 1); quickSort(A, pivot + 1, high); }}","link":"/2023/04/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}