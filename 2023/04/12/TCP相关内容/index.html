<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="整理一下看过的TCP相关的内容，主要是顺着小林coding里的要点看下来的，有些不太明白的地方去《TCP&#x2F;IP详解 卷1》翻了翻 主要内容：TCP头部关键信息、TCP和UDP的区别、三次握手四次挥手、TCP重传、流量控制和拥塞控制">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP相关知识点">
<meta property="og:url" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/index.html">
<meta property="og:site_name" content="Tien&#39;s Blog">
<meta property="og:description" content="整理一下看过的TCP相关的内容，主要是顺着小林coding里的要点看下来的，有些不太明白的地方去《TCP&#x2F;IP详解 卷1》翻了翻 主要内容：TCP头部关键信息、TCP和UDP的区别、三次握手四次挥手、TCP重传、流量控制和拥塞控制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230412220953844.png">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230413093137164.png">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230413101400179.png">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230413104620567.png">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230413133935036.png">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230413164455176.png">
<meta property="og:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230413165618984.png">
<meta property="article:published_time" content="2023-04-12T10:12:40.000Z">
<meta property="article:modified_time" content="2023-04-13T10:44:47.967Z">
<meta property="article:author" content="Tien">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="TCP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20230412220953844.png">

<link rel="canonical" href="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP相关知识点 | Tien's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fe67470975a39feb91f9d59afeab846c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tien's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/12/TCP%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/34372430?v=4">
      <meta itemprop="name" content="Tien">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tien's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP相关知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 18:12:40" itemprop="dateCreated datePublished" datetime="2023-04-12T18:12:40+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-13 18:44:47" itemprop="dateModified" datetime="2023-04-13T18:44:47+08:00">2023-04-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>整理一下看过的TCP相关的内容，主要是顺着小林coding里的要点看下来的，有些不太明白的地方去《TCP/IP详解
卷1》翻了翻</p>
<p>主要内容：TCP头部关键信息、TCP和UDP的区别、三次握手四次挥手、TCP重传、流量控制和拥塞控制</p>
<span id="more"></span>
<h2 id="tcp头中的关键内容">TCP头中的关键内容</h2>
<p>32位序列号：在建立连接时生成随机数作为初始值（与时间有关，每4微妙值加1，同时也与一个根据四元组计算的哈希值有关），每发送N字节数据，该值就加N，通过此序列号<font color='red'><strong>可以保证接受到的数据包有序</strong></font></p>
<p>32位确认应答号：下一次希望收到的数据序列号，该应答号之前的数据已经被正常接收，可以<font color='red'><strong>用于处理丢包的问题</strong></font></p>
<p>控制位：<font color='red'><strong>ACK/RST/SYN/FIN</strong></font>/PSH/URG</p>
<p>源端口号、目的端口号</p>
<p>4位首部长度：存储的是首部长度有多少个4字节</p>
<p>校验和：校验首部+数据，如果接收方发现校验和有问题，会丢弃收到的段，发送方会超时重发</p>
<h2 id="tcp的特点以及与udp的区别">TCP的特点以及与UDP的区别</h2>
<p><font color='red'><strong>面向连接、可靠、字节流</strong></font></p>
<p>说明：必须一对一建立连接、保证报文一定能被接收方收到、不在字节流中插入记录标识符，每次发送的大小和接收的大小不一定相同，发送接收次数也不一定相同</p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">TCP</th>
<th style="text-align: center;">UDP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">先建立连接</td>
<td style="text-align: center;">即刻传输数据</td>
</tr>
<tr class="even">
<td style="text-align: center;">一对一</td>
<td style="text-align: center;">一对一、一对多、多对多</td>
</tr>
<tr class="odd">
<td style="text-align: center;">无差错、不丢失、不重复、有序</td>
<td style="text-align: center;">尽最大努力交付（QUIC可靠）</td>
</tr>
<tr class="even">
<td style="text-align: center;">有拥塞控制和流量控制</td>
<td style="text-align: center;">没有</td>
</tr>
<tr class="odd">
<td style="text-align: center;">首部20字节（不用选项的话）</td>
<td style="text-align: center;">固定8字节</td>
</tr>
<tr class="even">
<td style="text-align: center;">流式传输，没有边界</td>
<td style="text-align: center;">以数据包为单位发送</td>
</tr>
<tr class="odd">
<td style="text-align: center;">可以在传输层分片（大于MSS）</td>
<td
style="text-align: center;">不会在数据层分片，如果大于MTU会给IP层分片</td>
</tr>
<tr class="even">
<td style="text-align: center;">常用于 FTP文件传输； HTTP / HTTPS</td>
<td style="text-align: center;">常用于 DNS；
视频、音频等多媒体通信；广播</td>
</tr>
</tbody>
</table>
<h2 id="tcp连接">TCP连接</h2>
<p>建立TCP连接是为了客户端和服务端在以下方面达成共识：socket、序列号、窗口大小</p>
<p>一个TCP连接可以用<font color='cornflowerblue'><strong>（源地址、源端口、目的地址、目的端口）</strong></font>这样一个四元组表示</p>
<blockquote>
<p>如果协议不确定，（源地址、源端口、目的地址、目的端口、通信协议）这样一个五元组可以唯一确定一个会话（<font color='orange'><strong>隐含TCP和UDP是可以使用同样的端口的</strong></font>）</p>
<p>还有个七元组：（源地址、源端口、目的地址、目的端口、通信协议、服务类型、接口索引）</p>
</blockquote>
<h3 id="三次握手">三次握手</h3>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" /></p>
<blockquote>
<p>图片来源于<a
target="_blank" rel="noopener" href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-和-udp-可以使用同一个端口吗">小林coding</a></p>
</blockquote>
<p><font color='red'><strong>为什么是三次握手？</strong></font></p>
<ol type="1">
<li>双方都经过了发送-接收的过程，同时ACK位保证了对方已知自己能够成功接收，同时同步双方的初始序列号。（两次：发送方不知道接收方能否成功接收，也就无法同步序列号；四次：冗余）</li>
<li><font color='cornflowerblue'><strong>防止无效的历史连接造成资源浪费</strong></font>（考虑client发送了一个SYN报文之后宕机了，然后在server没收到之前重启，又重新发了一个新的SYN报文，如果两次就能建立连接，此时假设server收到了旧SYN报文，发送一个SYN+ACK连接就已经建立了，然后客户端还得发RST去断开旧连接。）；<font color='cornflowerblue'><strong>防止冗余连接造成资源浪费</strong></font>（考虑client第一次发的SYN报文堵塞了，然后超时重发，如果两次握手，server收到任何一个之后发送SYN+ACK就建立连接了，假设server不知道自己的SYN+ACK是否被收到，再收到另一个SYN就会重复的建立连接）</li>
</ol>
<p><font color='red'><strong>ISN为什么要随时间变化？</strong></font></p>
<ol type="1">
<li><font color='cornflowerblue'><strong>防止历史报文被下一个相同四元组的连接错误接收</strong></font>（上一次连接中发送的数据如果因为网络拥塞等原因没有及时到达，而是在下一次相同四元组标识的连接中到达，可能会恰好与当前序号相符合，导致被错误接收）</li>
<li><font color='cornflowerblue'><strong>防止伪造ISN造成安全问题</strong></font></li>
</ol>
<p><font color='red'><strong>三次握手中每一次丢失会发生什么？</strong></font></p>
<ul>
<li>第一次丢失：server收不到就不会发SYN+ACK，client超时之后会重传,第一次超时时间为RTO，RTO之后重新发送，超时时间会设置为2RTO，再超时4RTO……以此类推，每次是上一次超时时间的2倍。<font color='orange'><strong>如果达到最大重传次数还没能收到SYN+ACK，client会断开连接</strong></font></li>
</ul>
<p><img src="image-20230412220953844.png" /></p>
<blockquote>
<p>可以看到超时重传时间1s 2s 4s 8s</p>
</blockquote>
<ul>
<li>第二次丢失：SYN+ACK包含两部分作用，如果丢失，<font color='orange'><strong>对客户端来说会认为自己的SYN没发到，超时重传；对服务端来说，自己的SYN发了之后一直没收到ACK，会超时重传SYN+ACK</strong></font>.客户端达到最大重传次数后等待一段时间断开连接，服务端达到最大重传次数后等待一段时间也断开连接.</li>
<li>第三次丢失：server会认为自己的SYN+ACK没有被收到，会超时重传，达到最大重传次数后等待一段时间，断开连接</li>
</ul>
<h3 id="四次挥手">四次挥手</h3>
<p><img
src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" /></p>
<blockquote>
<p>图片来源于<a
target="_blank" rel="noopener" href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-和-udp-可以使用同一个端口吗">小林coding</a></p>
</blockquote>
<p><font color='red'><strong>为什么是四次挥手？</strong></font></p>
<p>TCP的半关闭连接，发送FIN意味着发送方不再发送数据了但是还可以接收数据。服务器在收到FIN之后，可能还有数据需要处理或发送回client，所以先发送一个ACK，当server也不会再发送数据时，才会发送FIN给client</p>
<p><font color='red'><strong>一定是四次挥手吗？</strong></font></p>
<p>也有可能是三次挥手，</p>
<ol type="1">
<li><font color='cornflowerblue'><strong>TCP延迟确认开启时</strong></font>，第二次第三次挥手会合并。</li>
</ol>
<p>TCP延迟确认的意思是：将ACK与数据一同发送，提高网络的利用效率，如果有需要发送的数据，会跟ACK一起发送；如果没有，会等待一段时间看是否有数据可以一同发送；如果等待过程中又接收到新的数据，ACK会停止等待立即发送。</p>
<p>（可以通过将socket设置里的TCP_QUICKACK置1关闭延迟确认）</p>
<ol start="2" type="1">
<li>server端没有数据要处理发送了，<font color='cornflowerblue'><strong>可能</strong></font>会将FIN和ACK合并发送</li>
</ol>
<p><font color='red'><strong>第一次挥手丢失了会发生什么？</strong></font></p>
<p>以client为主动关闭方。client会不断超时重传，直到达到上限（tcp_orphan_retries）后等待一段时间直接到close状态</p>
<p><font color='red'><strong>第二次挥手丢失了会发生什么？</strong></font></p>
<p>client收不到server的ACK，不断重传FIN报文，直到收到ACK或者到达最大重传次数，等待一段时间后client断开连接。</p>
<p><font color='red'><strong>第三次挥手丢失了会发生什么？</strong></font></p>
<p>server会不断超时重传，达到最大超时次数后，等待一段时间没收到就断开连接</p>
<p>client在收到第二次的ACK后，进入FIN_WAIT2状态，该状态有时长限制（tcp_fin_timeout），如果等不到server的FIN就会断开连接</p>
<p><font color='red'><strong>第四次挥手丢失了会发生什么？</strong></font></p>
<p>服务器收不到ACK报文，会不断重传第三次的FIN，直到到达最大重传次数，之后等待一段时间，退出LAST_ACK状态，CLOSE</p>
<p>客户端发送ACK之后，会进入TIME_WAIT状态并启动计时器（2Maximum Segment
Lifetime），每次如果能够收到重传的FIN，会重置计时器。如果收不到，等待2MSL后退出TIME_WAIT状态，CLOSE</p>
<p><font color='red'><strong>为什么TIME_WAIT等待时间是2MSL（为什么需要TIME_WAIT状态）？</strong></font></p>
<ol type="1">
<li>给FIN一次重发的机会。如果第一次FIN丢失或ACK丢失，第二次FIN重发和发送ACK返回到server的时间刚好能在第二个MSL内到达；或第二次FIN刚好能在2MSL之内到达，再次发送ACK</li>
<li>确保当前连接中的所有数据失效，不会留到下一个连接中造成影响。</li>
</ol>
<p><font color='red'><strong>TIME_WAIT过多的危害以及如何缓解</strong></font></p>
<p>TIME_WAIT状态时不会再有实际数据的传输，但仍然处于连接状态中：</p>
<ul>
<li>对client来说，会占用过多<font color='cornflowerblue'><strong>端口资源</strong></font>，导致无法处理新的连接</li>
<li>对server来说，由于每个TCP连接是由TCP四元组确定的，所以只要IP不同，端口资源的影响能够处理。但仍然会占用<font color='cornflowerblue'><strong>系统资源</strong></font>，如文件描述符、寄存器、CPU资源、内存资源等。</li>
</ul>
<p>优化方法：</p>
<ol type="1">
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps
选项。前者只能用于连接发起方，<strong>开启该功能后，在调用 connect()
函数时，内核会随机找一个 time_wait 状态超过 1
秒的连接给新的连接复用</strong>。后者开启了时间戳，所以有问题的数据包会根据时间戳是否过期进行丢弃，2MSL的一大作用失效。</li>
<li>net.ipv4.tcp_max_tw_buckets。<strong>当系统中处于 TIME_WAIT
的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT
连接状态重置</strong></li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ol>
<blockquote>
<p>SO_LINGER设置的是延迟关闭的时间，在l_linger为0，l_onoff非0的情况下，调用close后会立即发送RST，跳过四次挥手阶段</p>
<p>之前记混的一个：SO_REUSEADDR是允许完全重复的捆绑</p>
</blockquote>
<p><font color='red'><strong>服务器出现大量TIME_WAIT的原因</strong></font></p>
<p>TIME_WAIT状态是主动关闭方才会出现的状态，此情况说明服务器主动断开了大量TCP连接</p>
<ul>
<li>没有使用HTTP长连接</li>
</ul>
<p>HTTP长连接在HTTP/1.0中默认关闭，HTTP/1.1中默认开启。需要<font color='red'><strong>双方</strong></font>在请求-响应的header中开启Connection:
Keep-Alive选项。<font color='cornflowerblue'><strong>大多数 Web
服务的实现，不管哪一方禁用了 HTTP
Keep-Alive，都是由服务端主动关闭连接</strong></font>，那么此时服务端上就会出现
TIME_WAIT 状态的连接。</p>
<blockquote>
<p>TCP也有Keepalive，指的是<font color='cornflowerblue'><strong>TCP的保活机制</strong></font>。如果TCP连接中一直没有数据交互，触发了TCP保活机制，那么内核中的TCP协议栈会发送探测报文（一般保活功能是为服务器程序提供的）。客户主机必须处于以下四个状态之一：</p>
<ul>
<li><p>客户主机正常运行且从服务器可达。会正常响应探测报文，保活定时器复位</p></li>
<li><p>客户主机崩溃，并且关闭或者正在重新启动。无法响应探测报文，服务器将探测报文超时时间设置为75s，即每75s发送一个探测报文，如果10个之后没有收到响应，服务器认为客户主机已经关闭并终止连接（数值来自于《TCP/IP详解，卷1》，linux默认保活时间7200s，探测次数9次，时间间隔75s,也就是7875s之后会发现连接“死亡”）</p>
<p><img src="image-20230413093137164.png" /></p></li>
<li><p>客户主机正常运行，但从服务器不可达。与上边的状态相同</p></li>
<li><p>客户主机崩溃，但已经重新启动。服务器会收到响应，但是响应是一个RST，服务器终止连接</p></li>
</ul>
<p><font color='A2CD5A'><strong>P.S.
还有种情况是进程崩溃，这时OS会回收进程资源发送FIN报文，服务器是可以感知的</strong></font></p>
</blockquote>
<ul>
<li>HTTP长连接超时</li>
</ul>
<p>web服务软件一般会提供一个参数指定HTTP长连接的超时时间，以防止没有请求的连接占用资源。（nginx的keepalive_timeout参数）定时器到时间服务端会关闭该连接，出现TIME_WAIT状态</p>
<ul>
<li>HTTP长连接请求数量达到上限</li>
</ul>
<p>Web 服务端通常会有个参数，来定义一条 HTTP
长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。（nginx的keepalive_requests参数）</p>
<p><font color='red'><strong>服务器出现大量CLOSE_WAIT的原因</strong></font></p>
<p>CLOSE_WAIT出现是在收到FIN报文之后，向应用程序交付EOF，在调用close()之后会转为LAST_ACK状态</p>
<p><font color='cornflowerblue'><strong>当服务端出现大量 CLOSE_WAIT
状态的连接的时候，说明服务端的程序没有调用 close
函数关闭连接</strong></font></p>
<h2 id="tcp重传机制">TCP重传机制</h2>
<p>重传是TCP实现可靠传输的方式之一</p>
<h3 id="超时重传">超时重传</h3>
<p>发送数据时设置一个定时器，如果超时没有收到ACK（数据包丢失或者应答丢失），就会重发数据。</p>
<p>超时时间（RTO）的设定很重要，<font color='orange'><strong>过长：传输效率低；过短：不必要重传浪费资源，增加网络拥塞程度</strong></font></p>
<p>RTO的值应该略大于RTT（Round-Trip
Time）,因为RTT是描述数据包的往返时间的，如果正常的话，RTT内发送方会收到ACK应答。但是路由器和网络流量均会变化，因此<font color='cornflowerblue'><strong>RTT也可能会经常发生变化，所以TCP应该跟踪其变化并相应地改变RTO</strong></font></p>
<p>RTT的估计需要采样RTT的时间，并且要加权平均，因为网络状况是不断变化的；另外还需要采样RTT的波动范围：</p>
<p><img src="image-20230413101400179.png" /></p>
<p>A是加权平滑的RTT，M是新测量到的RTT，D是被平滑的均值偏差</p>
<p>g=0.125,h=0.25</p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP
的策略是<font color='cornflowerblue'><strong>超时间隔加倍</strong></font>。</p>
<p>也就是<font color='cornflowerblue'><strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></font></p>
<p><font color='red'><strong>超时重传的问题是超时周期可能相对较长</strong></font></p>
<h3 id="快速重传">快速重传</h3>
<p>快速重传<font color='cornflowerblue'><strong>以数据驱动重传</strong></font></p>
<p>快速重传的工作方式是当收到三个相同的 ACK
报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" /></p>
<p>快速重传解决了超时重传超时周期过长的问题，但仍然存在<font color='red'><strong>不确定需要重传的数据报文</strong></font>的问题</p>
<p>上图中只重传Seq2没有问题，但是如果Seq3-5中也有丢失（比如Seq3），此时发送方收到的仍然是ACK2，所以<font color='A2CD5A'><strong>重传之后会继续收到三个ACK3，然后再重传Seq3</strong></font></p>
<h3 id="sack-selective-acknowledgment">SACK (Selective
Acknowledgment)</h3>
<p>选择性确认，需要在TCP头部的选项字段中加一个SACK，含义为已收到的数据的信息，在ACK报文中将SACK返回给发送方。</p>
<p>发送方收到三个相同的ACK报文后，触发快速重传机制，同时读取SACK信息，确定后续丢失的数据并重传，比如上图中，收到三个ACK2，说明2之前的都已被成功接收，然后SACK=3-5，所以2之后的也没有丢失，只重传2</p>
<p>通过net.ipv4.tcp_sack可以确认该功能是否开启</p>
<p><img src="image-20230413104620567.png" /></p>
<h3 id="duplicate-sack">Duplicate SACK</h3>
<p>使用了 SACK
来告诉发送方有哪些数据<font color='red'><strong>被重复接收</strong></font>了</p>
<p>SACK是不是D-SACK，取决于ACK的值和SACK范围之间的大小关系，比如ACK=1000，SACK=1500-3000,那就说明是1000-1500没收到；如果ACK为3000，SACK=2000-2500，显然就是说2000-2500数据重复接收了</p>
<p>D-SACK的优点有：</p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK
包丢了</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了（被网络延迟的包可能会在快速重传之后到接收方，接收方这时候可以通过SACK反馈给发送方）</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了</li>
</ul>
<h2 id="tcp流量控制">TCP流量控制</h2>
<h3 id="滑动窗口">滑动窗口</h3>
<p>使用滑动窗口控制发送的数据量：</p>
<p><img src="image-20230413133935036.png" /></p>
<blockquote>
<p>图片来自《TCP/IP详解 卷1》，为发送窗口</p>
</blockquote>
<ul>
<li><font color='cornflowerblue'><strong>提供窗口</strong></font>的大小是由ACK中<font color='cornflowerblue'><strong>窗口大小字段</strong></font>控制的</li>
<li><font color='A2CD5A'><strong>可用窗口</strong></font>根据确认<font color='A2CD5A'><strong>序列号</strong></font>计算，指的是可以立即发送的数据量（无须等待之前的ACK）</li>
<li>关闭close：左边界右移，发生在已发送数据得到ACK确认时</li>
<li>打开open：右边界右移，发生在确认数据得到处理时</li>
<li>收缩shrink：右边界左移，RFC1122不支持该做法，但TCP必须要能处理该问题</li>
</ul>
<p><font color='red'><strong>总之，发送方的窗口由接收方通告，ACK确定左边界位置，头部窗口大小字段配合ACK确定右边界</strong></font></p>
<h3 id="流量控制">流量控制</h3>
<p>发送方根据接收方的实际接收能力控制发送的数据量</p>
<p>通过滑动窗口实现，而滑动窗口则是OS开辟的一块缓存空间，所以有可能会被OS调整。如果先减少缓存再收缩窗口，有可能出现丢包的现象。<font color='cornflowerblue'><strong>TCP
规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></font></p>
<p><img
src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" /></p>
<h3 id="窗口关闭">窗口关闭</h3>
<p>问题：接收方窗口为0后通知发送方，发送方会停止发送数据。如果之后接收方重新打开窗口，通知发送方的报文丢失，会导致双方相互等待，导致死锁。</p>
<p>解决：TCP为每个连接设定一个定时器，<font color='cornflowerblue'><strong>只要收到对方的0窗口通知，就启动定时器</strong></font>。定时器超时，会发送窗口探测报文，如果对方收到探测报文，会回答自己的接收窗口大小，此后：</p>
<ul>
<li>如果接收窗口还是0，那么重置计时器</li>
<li>如果接收窗口打开，那么死锁解除</li>
</ul>
<p>窗口探测一般为3次，每次大约30-60s</p>
<h3 id="糊涂窗口综合征silly-window-syndrome">糊涂窗口综合征（Silly
Window Syndrome）</h3>
<p>出现该问题时，发送方发送的都是一些较小的数据段，导致每个报文段中真正有用的数据相对于头部信息的比例较小，传输效率较低。（<font color='A2CD5A'><strong>比如，接收方处理数据的速度非常慢，然后慢慢发送方的窗口就变为0，然后接收方处理完几个字节的数据接着就通告对方窗口打开了，发送方欣喜若狂，直接发了几个字节还不如头部长的数据过去</strong></font>）</p>
<p>SWS会出现在基于窗口的流量控制中，尤其是在不使用固定大小报文段的情况。从上边这个例子可以看出，发送方和接收方都可能导致SWS：接收方有个小窗口就立即通告；发送方有个小数据段就立即发送。</p>
<p>对症下药，避免SWS的规则如下（<font color='cornflowerblue'><strong>同时满足</strong></font>）：</p>
<ol type="1">
<li><p><font color='red'><strong>接收端不通告小的窗口值。</strong></font>根据RFC1122描述的接收算法，当前窗口&lt;min(MSS,recv_buffer/2)时，不通告比当前窗口更大的窗口值。该规则可以使用在处理接收数据使得可用缓存增大中，或者响应窗口探测报文时</p></li>
<li><p><font color='red'><strong>发送端不发送小的报文段。</strong></font>主要用Nagle算法控制发送时机，为避免SWS，当满足以下条件<font color='cornflowerblue'><strong>之一</strong></font>时才能发送</p>
<ol type="1">
<li>全长（MSS）报文段，窗口大小大于MSS</li>
<li>数据段长度&gt;=接收端<font color='cornflowerblue'><strong>通告过的最大窗口值</strong></font>的一半（这个条件主要用于比较旧的原始主机）</li>
<li>之前所有数据的ACK都已被接收，或禁用了Nagle算法</li>
</ol>
<blockquote>
<p>根据<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc896">RFC
896</a>，Nagle实际上控制的是网络拥塞，其目的定义为“The solution is to
inhibit the sending of new TCP segments when new outgoing data arrives
from the user if any previously transmitted data on the connection
remains unacknowledged.”</p>
<p>也就是说每个TCP连接上最多只能有一个未被确认的数据段，如果之前的数据有ACK没收到不会继续发送</p>
<p>RFC9293中没有规定Nagle算法的实现，这里给个wikipidia上的伪代码描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> there is new data to send then</span><br><span class="line">    <span class="keyword">if</span> the window size ≥ MSS and available data is ≥ MSS then</span><br><span class="line">        send complete MSS segment now</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> there is unconfirmed data still in the pipe then</span><br><span class="line">            enqueue data in the buffer until an acknowledge is received</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            send data immediately</span><br><span class="line">        end <span class="keyword">if</span></span><br><span class="line">    end <span class="keyword">if</span></span><br><span class="line">end <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">getsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(<span class="type">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TCP_NODELAY opt: %d\n&quot;</span>,value);</span><br></pre></td></tr></table></figure>
<p>用上边的code测试了Nagle算法默认应该是关闭的，小林那里提到默认是打开的，应该是OS的默认设置啥的不一样吧233</p></li>
</ol>
<h2 id="tcp拥塞控制">TCP拥塞控制</h2>
<p>流量控制是避免发送方的数据不会填满接收方缓存，导致数据丢失</p>
<p>拥塞控制是对网络而言，避免发送方的数据填满整个网络。网络拥堵时如果继续发送大量数据，可能会导致延迟、丢失，然后TCP重传，恶性循环。</p>
<p>所以发送方会维护一个<font color='cornflowerblue'><strong>拥塞窗口</strong></font>cwnd,此时发送窗口的值为min(cwnd,rwnd)，其变化的基本逻辑就是出现拥塞减小；没有拥塞增大</p>
<p>所以就需要进行拥塞检测，但是没有一个明确的信号可以告知发送方拥塞发生，那发送方直接就看丢包。出现了丢包超时重传，就认为发生了网络拥塞</p>
<h3 id="慢启动">慢启动</h3>
<p>发生时间：TCP连接建立时；检测到重传超时导致的丢包；TCP发送端长时间处于空闲状态（可能）；</p>
<blockquote>
<p>RFC5681中对慢启动目的和使用情况的解释：Beginning transmission into a
network with unknown conditions requires TCP to slowly probe the network
to determine the available capacity, in order to avoid congesting the
network with an inappropriately large burst of data.The slow start
algorithm is used for this purpose at the beginning of a transfer, or
after repairing loss detected by the retransmission timer.</p>
</blockquote>
<p>这里假设初始窗口大小为1
SMSS（以下就省略SMSS这个单位了；另，具体的IW设定方式在RFC5681有介绍），收到一个数据段的ACK后cwnd=2，然后发送2个数据段，如果成功收到新的ACK，cwnd=4，cwnd=8……也就是<font color='red'><strong>当发送方每收到一个
ACK，拥塞窗口 cwnd 的大小就会加 1</strong></font></p>
<blockquote>
<p>可以看出慢启动的增长是个指数增长，看似很快，但称其为慢启动意思是与一开始就以最大可用速率发送相比已经算慢了</p>
</blockquote>
<p><img src="image-20230413164455176.png" /></p>
<blockquote>
<p>图源自《TCP/IP详解 卷1》</p>
</blockquote>
<p>慢启动发送数据段的数量达到慢启动门限（cwnd&gt;=ssthresh）后会进入拥塞避免算法</p>
<h3 id="拥塞避免">拥塞避免</h3>
<p>进入拥塞避免之后，cwnd的增长值变为线性，此时每接收到1个ACK,cwnd =
cwnd + SMSS*SMSS/cwnd.这个式子化简一下就是cwnd = cwnd + (1/k)*SMSS</p>
<blockquote>
<p>cwnd = cwnd + SMSS*SMSS/cwnd</p>
<p>cwnd = k*SMSS + SMSS*SMSS/(k*SMSS)</p>
<p>cwnd = k*SMSS + SMSS/k</p>
<p>将cwnd=k*SMSS代回，cwnd = cwnd + (SMSS/k)</p>
</blockquote>
<p>假设ssthresh=8，那么发送八个数据段，收到8个ACK后cwnd=9，然后再发9个数据段cwnd=10，就变为了一个累加增长。</p>
<p><img src="image-20230413165618984.png" /></p>
<h3 id="快速恢复">快速恢复</h3>
<p>cwnd继续增长，如果出现了快速重传中的三个相同ACK，TCP就认为现在发送超出了网络传输能力的范围，<font color='red'><strong>此时将ssthresh减小为cwnd/2，但不小于2*SMSS，cwnd=ssthresh+3</strong></font></p>
<p>之后：</p>
<ul>
<li>重传丢失的数据包</li>
<li>如果再收到重复ACK，cwnd+=1</li>
<li>如果收到新的ACK,cwnd=ssthresh</li>
</ul>
<p>这个过程中，首先目的是为了减小cwnd，因为已经发生了拥塞，然后中间cwnd的增加是为了尽快将丢失的数据包发送给目标，最后收到新的ACK说明重传成功了，然后再将cwnd减小。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
              <a href="/tags/TCP/" rel="tag"># TCP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/12/leetcode%E5%88%B7%E9%A2%98%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%882023-4-12%E4%B9%8B%E5%89%8D%EF%BC%89/" rel="prev" title="leetcode刷题部分题解（2023.4.12之前）">
      <i class="fa fa-chevron-left"></i> leetcode刷题部分题解（2023.4.12之前）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/13/%E5%B8%B8%E8%A7%81%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/" rel="next" title="常见数字图像处理方法">
      常见数字图像处理方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%86%85%E5%AE%B9"><span class="nav-number">1.</span> <span class="nav-text">TCP头中的关键内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E7%9A%84%E7%89%B9%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">TCP的特点以及与UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">TCP重传机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="nav-number">4.1.</span> <span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-number">4.2.</span> <span class="nav-text">快速重传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sack-selective-acknowledgment"><span class="nav-number">4.3.</span> <span class="nav-text">SACK (Selective
Acknowledgment)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#duplicate-sack"><span class="nav-number">4.4.</span> <span class="nav-text">Duplicate SACK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">TCP流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">5.1.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="nav-number">5.3.</span> <span class="nav-text">窗口关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81silly-window-syndrome"><span class="nav-number">5.4.</span> <span class="nav-text">糊涂窗口综合征（Silly
Window Syndrome）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-number">6.1.</span> <span class="nav-text">慢启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">6.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="nav-number">6.3.</span> <span class="nav-text">快速恢复</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tien"
      src="https://avatars.githubusercontent.com/u/34372430?v=4">
  <p class="site-author-name" itemprop="name">Tien</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tien5770" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tien5770" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/txvhuiu@163.com" title="E-Mail → txvhuiu@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tien</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">57k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>
<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/12/2023 09:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '50565f9d05a1db99e275',
      clientSecret: 'de517846c9a00de3d47423aa775f62b0da777d2e',
      repo        : 'Tien5770.github.io',
      owner       : 'Tien5770',
      admin       : ['Tien5770'],
      id          : '5e6bdfbb29ddbb31de36519b667db548',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
