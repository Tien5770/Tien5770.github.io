<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="《C++ Primer》 13-16章笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ Primer》笔记（13-16章）">
<meta property="og:url" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/index.html">
<meta property="og:site_name" content="Tien&#39;s Blog">
<meta property="og:description" content="《C++ Primer》 13-16章笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230303163225705.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230308151158091.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230309085907880.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230309090211045.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230309103334548.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230309111432646.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230309145325762.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230310094400689.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230310152341558.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230313185210156.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230313193243811.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230313193358593.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230314164638203.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230314164736325.png">
<meta property="og:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230316105433811.png">
<meta property="article:published_time" content="2023-04-12T02:33:28.000Z">
<meta property="article:modified_time" content="2023-04-12T08:46:05.378Z">
<meta property="article:author" content="Tien">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/image-20230303163225705.png">

<link rel="canonical" href="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《C++ Primer》笔记（13-16章） | Tien's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fe67470975a39feb91f9d59afeab846c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tien's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813-16%E7%AB%A0%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/34372430?v=4">
      <meta itemprop="name" content="Tien">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tien's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《C++ Primer》笔记（13-16章）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-12 10:33:28 / 修改时间：16:46:05" itemprop="dateCreated datePublished" datetime="2023-04-12T10:33:28+08:00">2023-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>《C++ Primer》 13-16章笔记</p>
<span id="more"></span>
<h2 id="第13章-拷贝控制"><a class="markdownIt-Anchor" href="#第13章-拷贝控制"></a> 第13章 拷贝控制</h2>
<p><strong>拷贝构造函数、移动构造函数</strong>负责定义用同类型的另一个对象初始化本对象时做什么</p>
<p><strong>拷贝赋值运算符、移动赋值运算符</strong>定义将同类型的另一个对象赋予同类型对象时做什么</p>
<p><strong>析构函数</strong>定义了此类型对象销毁时做什么</p>
<h3 id="拷贝-赋值与销毁"><a class="markdownIt-Anchor" href="#拷贝-赋值与销毁"></a> 拷贝、赋值与销毁</h3>
<h4 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h4>
<p>构造函数+<strong>第一个参数是自身类类型的引用+任何额外参数都有默认值</strong></p>
<p>拷贝函数在几种情况下都会被隐式的使用，因此拷贝函数不应该是explicit的</p>
<p>一般情况下，<strong>合成构造函数</strong>会将给定对象中每个<strong>非static参数成员</strong>逐个拷贝到正在创建的对象中。对类类型成员会使用其拷贝构造函数来拷贝；对内置类型成员则直接拷贝</p>
<p>拷贝初始化发生的情况：</p>
<ul>
<li>用=定义变量时会发生</li>
<li>将一个对象作为实参传递给一个<strong>非引用类型</strong>的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
<li>标准库容器初始化或是调用其insert或push成员</li>
</ul>
<h4 id="拷贝赋值运算符"><a class="markdownIt-Anchor" href="#拷贝赋值运算符"></a> 拷贝赋值运算符</h4>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用</p>
<p>将右侧对象中每个非static成员赋予左侧运算对象的对应成员</p>
<h4 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h4>
<p>释放对象使用的资源，销毁对象的非static数据成员</p>
<p>不能重载，每个类只有一个</p>
<p>析构函数<strong>首先执行函数体</strong>，然后销毁成员，按初始化顺序<strong>逆序销毁</strong></p>
<p>销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。<strong>智能指针是类类型，具有析构函数，智能指针在析构阶段自动销毁</strong></p>
<p>什么时候调用析构函数：</p>
<ul>
<li>变量离开其作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其中元素被销毁</li>
<li>动态分配的对象，对指向它的指针应用delete运算符被销毁时</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h4 id="三五法则"><a class="markdownIt-Anchor" href="#三五法则"></a> 三/五法则</h4>
<p><strong>如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符</strong></p>
<p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>
<h4 id="使用default"><a class="markdownIt-Anchor" href="#使用default"></a> 使用=default</h4>
<p>在类内修饰成员声明时，会隐式的声明为内联的；如果不希望内联，应该仅在类外定义使用=default</p>
<h4 id="阻止拷贝"><a class="markdownIt-Anchor" href="#阻止拷贝"></a> 阻止拷贝</h4>
<p>例如，iostream类阻止了拷贝，避免多个对象写入或读取相同的IO缓冲</p>
<p>新标准下可以通过拷贝构造函数和拷贝赋值运算符定义为deleted function来阻止拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span>&#123;</span><br><span class="line">    <span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span> = (<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>=delete</strong>必须出现在函数第一次声明的时候</li>
<li>可以对任何函数指定=delete，而只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default</li>
<li><strong>析构函数不能是deleted function</strong>,否则，不能定义该类型的变量，也不能释放指向该类型动态分配对象的指针</li>
<li><strong>合成的拷贝控制成员可能是deleted</strong>,如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为deleted function</li>
</ul>
<h3 id="拷贝控制和资源管理"><a class="markdownIt-Anchor" href="#拷贝控制和资源管理"></a> 拷贝控制和资源管理</h3>
<p>行为像值的类：拷贝构造和拷贝赋值时对内部成员进行拷贝</p>
<p>行为像指针的类：拷贝构造拷贝赋值中使用shared_ptr的引用计数管理资源</p>
<h3 id="交换操作"><a class="markdownIt-Anchor" href="#交换操作"></a> 交换操作</h3>
<h3 id="动态内存管理类"><a class="markdownIt-Anchor" href="#动态内存管理类"></a> 动态内存管理类</h3>
<p>move函数，在utility头文件中</p>
<h3 id="对象移动"><a class="markdownIt-Anchor" href="#对象移动"></a> 对象移动</h3>
<p>移动而非拷贝对象在某些情况下会大幅提升性能</p>
<p>标准库容器、string和shared_ptr既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝</p>
<h4 id="右值引用"><a class="markdownIt-Anchor" href="#右值引用"></a> 右值引用</h4>
<p><strong>回忆：左值和右值是表达式的属性，一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值</strong></p>
<p>右值引用是必须绑定到右值的引用。我们<strong>通过&amp;&amp;获得右值引用。</strong></p>
<p>右值引用有一个重要的性质：只能绑定到一个将要销毁的对象。</p>
<p>常规引用（左值引用）不能将其绑定到要求转换的表达式、字面常量或者返回右值的表达式上。<strong>右值引用可以，但不能直接将右值引用直接绑定到一个左值上</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;<span class="comment">//正确，左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;<span class="comment">//错误，i是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;<span class="comment">//错误，i*42是个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>;<span class="comment">//正确，const引用可以绑定到右值上</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><strong>进一步区分左值右值：</strong></p>
<ul>
<li>返回左值引用的函数，连同赋值、下标、解引用和前置递增、前置递减运算符，返回的都是左值表达式</li>
<li>返回非引用类型的函数，连同算术、关系、位、后置递增和后置递减运算符，都生成右值。可以将const左值引用或者右值引用绑定到这类表达式上</li>
<li>左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时对象。</li>
<li>变量是左值，<strong>即便该变量是右值引用类型它也是左值</strong></li>
</ul>
<p><strong>标准库move函数：</strong></p>
<p>显式地将一个左值转换为对应的右值引用类型，move函数可以获得绑定到左值上的右值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>
<p><strong>调用move意味着承诺除了对rr1赋值或者销毁之外，将不再使用它</strong></p>
<p>使用move的代码应该使用std::move，这也可以避免潜在的名字冲突</p>
<h4 id="移动构造函数和移动赋值运算符"><a class="markdownIt-Anchor" href="#移动构造函数和移动赋值运算符"></a> 移动构造函数和移动赋值运算符</h4>
<p>让自己的类型支持移动操作，需要定义这两个成员</p>
<p>这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”而非拷贝资源</p>
<hr />
<p><strong>移动构造函数</strong></p>
<p>移动构造函数的第一个参数是该类类型的一个引用，但是是右值引用。</p>
<p>移动构造函数除了完成资源移动外，还必须确保移动后<strong>源对象处于销毁无害的状态</strong></p>
<p>移动构造函数不分配任何新内存</p>
<hr />
<p><strong>移动赋值运算符</strong></p>
<p>必须正确处理自赋值。</p>
<p>移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p>
<hr />
<p><strong>合成的移动操作</strong></p>
<p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为之合成移动构造函数和移动赋值运算符了。</p>
<p><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。</strong></p>
<p><img src="image-20230303163225705.png" alt="image-20230303163225705" /></p>
<hr />
<p>如果拷贝构造和移动构造并存，根据构造或赋值传入参数的类型，处理方式是：移动右值，拷贝左值。<strong>但如果没有移动构造函数，右值也被拷贝</strong></p>
<hr />
<p><strong>移动迭代器（cpp11）</strong></p>
<p>移动迭代器解引用运算符生成的是一个右值引用</p>
<p>标准库的make_move_iterator函数可以将一个普通迭代器转换为一个移动迭代器。</p>
<p>原迭代器的所有其他操作在移动迭代器中都照常工作。</p>
<p>需要注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此只有在确信算法在为一个元素赋值或者将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法</p>
<h4 id="右值引用和成员函数"><a class="markdownIt-Anchor" href="#右值引用和成员函数"></a> 右值引用和成员函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以强制指出this指向的对象（左侧运算对象）的属性是左值或者右值，使用引用限定符&amp;或&amp;&amp;，位置在参数列表后放置</p>
<p>const限定和引用限定同时使用时，const限定必须在前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">func</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符</p>
<h2 id="第14章-重载运算与类型转换"><a class="markdownIt-Anchor" href="#第14章-重载运算与类型转换"></a> 第14章 重载运算与类型转换</h2>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<p>operator+要定义的运算符号</p>
<p>重载运算符函数的参数数量和运算符作用的运算对象数量一样多</p>
<p>除了operator()之外，其他重载运算符不能含有默认实参</p>
<p>如果一个运算符函数是成员函数，第一个运算对象绑定到隐式的this指针上，所以此时参数数量=运算符作用的运算对象-1</p>
<p><strong>不能重定义内置类型的运算含义</strong></p>
<p>重载运算符作为成员还是非成员函数的选择：</p>
<p><img src="image-20230308151158091.png" alt="image-20230308151158091" /></p>
<p>对于最后一条：如果重载被定义为类成员函数，那么左侧运算对象一定是所属类的一个对象。所以如果要使运算符有对称性，不应该定义为成员函数</p>
<p>比如string s = “hi” + s;是非法的，因为operator +被定义为string的类成员函数，该语句等价于“hi”.operator+(s);，而其类型为const char*，根本就无法调用。</p>
<h3 id="输入和输出运算符"><a class="markdownIt-Anchor" href="#输入和输出运算符"></a> 输入和输出运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> X&amp; x);</span><br></pre></td></tr></table></figure>
<p>第一个参数是非常量ostream对象的引用：非常量-&gt;向流写入内容会改变其状态；引用-&gt;流不允许拷贝。</p>
<p>输出运算符重载时尽量减少格式化操作，专注于输出对象的内容。使用户有权控制输出细节。</p>
<hr />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is,X&amp; x);</span><br></pre></td></tr></table></figure>
<p><strong>输入运算符必须处理可能的输入失败的情况，而输出运算符不需要</strong></p>
<p>输入时可能发生下列错误：</p>
<ul>
<li>流含有错误类型的数据读取操作时（输入和被赋值变量类型不匹配）</li>
<li>读取操作到达文件末尾或者遇到输入流的其他错误</li>
</ul>
<p>输入运算符负责检测错误，同时从错误中恢复</p>
<h3 id="算术和关系运算符"><a class="markdownIt-Anchor" href="#算术和关系运算符"></a> 算术和关系运算符</h3>
<p>一般定义为非成员函数以允许对左侧或右侧对象进行转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X <span class="keyword">operator</span>+(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> X&amp; rhs);</span><br><span class="line">X <span class="keyword">operator</span>+(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs)&#123;</span><br><span class="line">    X tmp = lhs;</span><br><span class="line">    tmp+= rhs;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> X&amp; lhs,<span class="type">const</span> X&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>相等运算符和不等运算符在实现中应该把具体工作委托给另外一个，而其只负责调用对方实现自身的功能。</p>
<hr />
<p>对于关系运算符，如&lt;，如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑重载该运算符</p>
<p>如果类同时还包含==，则当且仅当&lt;定义和==产生的结果一致时才定义&lt;运算符</p>
<h3 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il);</span><br></pre></td></tr></table></figure>
<p>注意赋值运算符改变了左侧运算对象本身，按照之前的准则，应该定义为类成员函数，且返回左侧对象的引用。形参类型可以按照需求进行定义</p>
<p>复合赋值运算符也要返回左侧对象的引用。</p>
<h3 id="下标运算符"><a class="markdownIt-Anchor" href="#下标运算符"></a> 下标运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> n);</span><br><span class="line"><span class="type">const</span> string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p>下标运算符必须是成员函数</p>
<p>如果一个类包含下标运算符，则通常会定义两个版本：一个返回<strong>普通引用</strong>，一个是<strong>类的常量成员</strong>并且返回<strong>常量引用</strong></p>
<h3 id="递增和递减运算符"><a class="markdownIt-Anchor" href="#递增和递减运算符"></a> 递增和递减运算符</h3>
<p>建议设定为成员函数，要同时定义前置版本和后置版本</p>
<hr />
<p><strong>前置版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X&amp; <span class="keyword">operator</span>++();</span><br><span class="line">X&amp; <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>
<p><strong>后置版本</strong></p>
<p>为了区分前置盒后置版本，在后置重载的生命中增加一个额外的int形参，但该形参不会被使用。调用后置运算符时，编译器会为这个形参提供一个值为0的实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X X::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    X tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">X <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>后置版本的实现可以调用前置版本来完成实际工作</p>
<p>因为内置的后置递增递减运算符返回的时对象运算之前的值，所以后置版本的重载返回类型设置为值类型。</p>
<h3 id="成员访问运算符"><a class="markdownIt-Anchor" href="#成员访问运算符"></a> 成员访问运算符</h3>
<p>箭头运算符完成的是解引用+成员访问</p>
<p>箭头运算符必须是类的成员，解引用运算符不必须是类的成员，但一般也设置为类的成员。</p>
<p>成员访问一般不会改变对象状态，所以重载函数定义为const成员，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</p>
<h3 id="函数调用运算符"><a class="markdownIt-Anchor" href="#函数调用运算符"></a> 函数调用运算符</h3>
<p>如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;<span class="number">0</span>?-val:val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;</span><br><span class="line"><span class="type">int</span> ui = <span class="built_in">absObj</span>(i);</span><br></pre></td></tr></table></figure>
<p><strong>如果类定义了调用运算符，则该类的对象称作函数对象</strong></p>
<p>函数对象类中的包含的其他数据数据成员可以被用于定制调用运算符中的操作（比如定义一个打印字符串类，重载operator()，数据成员中有分隔符可以使用）</p>
<p>函数对象常常作为泛型算法的实参</p>
<hr />
<h4 id="lambda是函数对象"><a class="markdownIt-Anchor" href="#lambda是函数对象"></a> lambda是函数对象</h4>
<p>编写一个lambda后，编译器将表达式翻译为一个未命名类的对象，该类中含有一个重载的函数调用运算符。<strong>在默认情况下，该类的函数调用运算符是一个const成员函数</strong></p>
<p>如果lambda的捕获变量为值捕获，这种类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数并初始化数据成员</p>
<p><img src="image-20230309085907880.png" alt="image-20230309085907880" /></p>
<h4 id="标准库定义的函数对象"><a class="markdownIt-Anchor" href="#标准库定义的函数对象"></a> 标准库定义的函数对象</h4>
<p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，在functional头文件中</p>
<p><img src="image-20230309090211045.png" alt="image-20230309090211045" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">intAdd</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())</span><br></pre></td></tr></table></figure>
<p>标准库规定其函数对象对于指针也同样适用。</p>
<h4 id="可调用对象与function"><a class="markdownIt-Anchor" href="#可调用对象与function"></a> 可调用对象与function</h4>
<p>C++中可调用的对象：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。</p>
<p>调用形式（call signature）指明返回类型以及传递给调用的实参类型，一种调用形式对应一个函数类型。<strong>不同类型可能具有相同的调用形式</strong></p>
<p>下面几个可调用对象共用一种调用形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int(int,int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123;<span class="keyword">return</span> i%j;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> de,<span class="type">int</span> di)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> de/di;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>function定义于functional头文件中，是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，该信息表示对象的调用形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;;</span><br></pre></td></tr></table></figure>
<p><img src="image-20230309103334548.png" alt="image-20230309103334548" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>重载的函数与function</strong></p>
<p>不能直接将重载函数的名字存入function类型的对象中，会产生二义性问题</p>
<p>解决方法：存储函数指针、使用lambda消除二义性</p>
<h3 id="重载-类型转换与运算符"><a class="markdownIt-Anchor" href="#重载-类型转换与运算符"></a> 重载、类型转换与运算符</h3>
<h4 id="类型转换运算符"><a class="markdownIt-Anchor" href="#类型转换运算符"></a> 类型转换运算符</h4>
<p>负责将一个类类型的值转换成其他类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//一般形式，type指某种类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以面向除void之外的任意类型进行定义，只要该类型能作为函数的返回类型</li>
<li><strong>不允许转换成数组或者函数类型</strong></li>
<li>允许转换为指针或者引用类型</li>
<li><strong>没有显式的返回类型，没有形参</strong></li>
<li><strong>必须定义为类的成员函数</strong></li>
</ul>
<hr />
<p><strong>显式的类型转换运算符</strong>——explicit</p>
<p>声明为explicit之后，只能通过显式的请求进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line">si+<span class="number">3</span>;<span class="comment">//错误</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si)+<span class="number">3</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><img src="image-20230309111432646.png" alt="image-20230309111432646" /></p>
<h4 id="避免含有二义性的类型转换"><a class="markdownIt-Anchor" href="#避免含有二义性的类型转换"></a> 避免含有二义性的类型转换</h4>
<p>如果类中包含一个或多个类型转换，必须确保在类类型和目标类型之间只存在唯一一种转换方式。</p>
<p>考虑以下情况：</p>
<p>A类中包含以B类为参数的转换构造函数，B类中存在转换成A类型的类型转换运算符。如果有以下语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">A a = <span class="built_in">f</span>(b);</span><br></pre></td></tr></table></figure>
<p>则会产生二义性，因为不知道应该使用哪种方式将B类型的b转换为A类型</p>
<p>如果确实想执行该调用，就必须显式指明调用的类型转换方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());</span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));</span><br></pre></td></tr></table></figure>
<p><strong>无法使用强制类型转换来解决二义性</strong></p>
<hr />
<p>再考虑以下情况，类中定义的一组类型转换，其转换源或转换目标类型本身可以通过其他类型转换联系在一起</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);<span class="comment">//最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//最好不要创建两个转换目标都是算术类型的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);<span class="comment">//二义性错误，f(A::operator int())或f(A::operator double())</span></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;<span class="comment">//二义性错误，f(A::A(int))或f(A::A(double))</span></span><br></pre></td></tr></table></figure>
<p><strong>根本原因是上述调用中所需要的标准类型转换级别一致</strong></p>
<hr />
<p><img src="image-20230309145325762.png" alt="image-20230309145325762" /></p>
<hr />
<p><strong>重载函数与转换构造函数</strong></p>
<p>再考虑以下情况，二义性问题会进一步加重</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> D&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>在传入实参时显式地构造类型可以消除二义性，但出现这种情况通常表示程序设计存在问题。</p>
<h4 id="函数匹配与重载运算符"><a class="markdownIt-Anchor" href="#函数匹配与重载运算符"></a> 函数匹配与重载运算符</h4>
<ul>
<li>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数</li>
<li>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载运算符，会产生二义性问题</li>
</ul>
<h2 id="第15章-面向对象程序设计"><a class="markdownIt-Anchor" href="#第15章-面向对象程序设计"></a> 第15章 面向对象程序设计</h2>
<h3 id="oop概述"><a class="markdownIt-Anchor" href="#oop概述"></a> OOP概述</h3>
<p>核心思想：数据抽象、继承和动态绑定</p>
<p>数据抽象：将类接口和实现分离</p>
<p>继承：定义相似的类型并对其相似关系建模</p>
<p>动态绑定：一定程度上忽略相似类型的区别，以统一的方式使用其对象</p>
<hr />
<p>基类、派生类</p>
<p>基类负责定义在层次关系中所有类共有的成员。每个派生类定义各自特有的成员</p>
<p>对于某些函数，基类希望其派生类各自定义适合自身的版本，<strong>此时基类将这些函数声明为虚函数。派生类必须在其内部对所有重新定义的虚函数进行声明</strong></p>
<hr />
<p>动态绑定</p>
<p>函数的运行版本由实参决定，即在运行时选择函数的版本</p>
<p>在CPP中，当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定</p>
<h3 id="定义基类和派生类"><a class="markdownIt-Anchor" href="#定义基类和派生类"></a> 定义基类和派生类</h3>
<p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作</p>
<hr />
<h4 id="基本知识"><a class="markdownIt-Anchor" href="#基本知识"></a> 基本知识</h4>
<p><strong>成员函数与继承</strong></p>
<p>基类的成员函数可以被分为两种：</p>
<ul>
<li>希望派生类进行**覆盖（override）**的函数</li>
<li>希望派生类直接继承而不改变的函数</li>
</ul>
<p>对于前者，基类通常将其定义为虚函数。当使用指针或者引用调用虚函数时，该调用将被动态绑定。根据指针或引用所绑定的对象类型不同，调用基类的版本或者派生类的版本</p>
<p>虚函数声明：virtual关键字，<strong>只能出现在类内部的声明语句而不能用于外部的函数定义</strong></p>
<p>虚函数范围：任何<strong>构造函数之外的非静态函数</strong>都可以是虚函数</p>
<p>非虚函数的解析过程发生在编译时而非运行时</p>
<hr />
<p><strong>派生类的声明形式</strong></p>
<p>使用类派生列表明确指出从哪个类继承而来</p>
<p><strong>声明时不能包含派生列表</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>;<span class="comment">//声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>派生类中的虚函数</strong></p>
<p>如果派生类没有覆盖基类中某个虚函数，则该虚函数的行为类似于其他的普通成员。<strong>派生类会直接继承其在基类中的版本</strong></p>
<p>派生类可以在覆盖的函数前使用virtual关键字，但不是必须</p>
<p>也可以在形参列表后边添加override关键字，override的次序在const后面或引用限定符&amp;、&amp;&amp;后面</p>
<hr />
<p><strong>派生类对象及派生类向基类的类型转换</strong></p>
<p>编译器隐式执行派生类到基类的转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;</span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote* p = &amp;item;</span><br><span class="line">p = &amp;bulk;</span><br><span class="line">Quote&amp; r = bulk;</span><br></pre></td></tr></table></figure>
<p>能够进行转换的原因是每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该部分上。所以不存在基类向派生类的自动类型转换。</p>
<p>判断基类和派生类转换是否可行看的是被转换对象静态类型，因为编译器只能检查静态类型来推断转换是否合法。dynamic_cast请求类型转换的安全检查将在运行时执行。static_cast的转换可以强制覆盖掉编译器的检查工作。使用时要确保转换是安全的。</p>
<p>注意，<strong>派生类向基类之间的自动类型转换只对指针或引用类型有效</strong>。对于对象之间的转换，其实是调用了构造函数或者赋值运算符，一个对象作为参数传入，在该过程中发生了类型转换。</p>
<hr />
<p><strong>派生类构造函数</strong></p>
<p>对于从基类中继承而来的成员，派生类必须<strong>使用基类的构造函数来初始化</strong>，即每个类控制它自己的成员初始化过程。</p>
<p><img src="image-20230310094400689.png" alt="image-20230310094400689" /></p>
<p>初始化顺序：初始化基类部分，按照声明顺序依次初始化派生类成员</p>
<hr />
<p><strong>派生类使用基类成员</strong></p>
<p>可以访问基类的公有成员和受保护成员</p>
<hr />
<p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的<strong>唯一定义</strong>。不论从基类中派生出多少派生类。</p>
<p>静态成员也遵循访问控制规则，即如果在基类中是private的，则派生类无权访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statemem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(cosnt Derived&amp; obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//以下访问都是合法的</span></span><br><span class="line">    Base::<span class="built_in">statemem</span>();</span><br><span class="line">    Derived::<span class="built_in">statemem</span>();</span><br><span class="line">    obj.<span class="built_in">statemem</span>();</span><br><span class="line">    <span class="built_in">statemem</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>被用作基类的类</strong></p>
<p>如果某个类被用作基类，则该类必须<strong>已经定义而非仅仅声明</strong></p>
<p>直接基类、间接基类</p>
<hr />
<p><strong>防止继承的发生</strong></p>
<p>C++11新标准，在类名后跟一个关键字<strong>final</strong></p>
<h4 id="类型转换与继承"><a class="markdownIt-Anchor" href="#类型转换与继承"></a> 类型转换与继承</h4>
<p>之前提到，可以将基类的指针（<strong>包括智能指针</strong>）或引用绑定到派生类对象上，说明<strong>当使用基类指针时，实际上所绑定对象的真实类型可能是基类类型，也可能是派生类类型</strong></p>
<p><strong>静态类型与动态类型</strong></p>
<p>静态类型：编译时已知，是在变量声明时的类型或表达式生成的类型</p>
<p>动态类型：运行时可知，是变量或表达式表示的内存中对象的类型</p>
<p><strong>如果表达式既不是指针也不是引用，则动态类型和静态类型永远一致。</strong></p>
<h3 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h3>
<blockquote>
<p>总结：</p>
<p>这一节内容比较琐碎，可以大致分为三个：</p>
<ol>
<li>虚函数在基类中的定义，需要virtual关键字，含义为想要子类去覆盖的函数</li>
<li>虚函数的通过指针或者引用的调用在运行时才会被解析，由此产生了本节中的默认实参或回避虚函数机制等小知识点</li>
<li>虚函数在派生类在的定义形式</li>
</ol>
<p>其中最重要的是第二点，动态绑定</p>
</blockquote>
<p><strong>虚函数的调用在运行时才被解析</strong></p>
<p>由于虚函数在运行时才能确定调用了哪个版本，所以<strong>所有虚函数都必须有定义。</strong></p>
<p><strong>动态绑定只有当通过指针或者引用调用虚函数时才会发生</strong>，如果使用普通类型的表达式调用虚函数时，编译时就会确定实际调用的版本。</p>
<hr />
<p><strong>派生类中的虚函数</strong></p>
<ul>
<li>不是必须加virtual关键字</li>
<li>如果在派生类中覆盖继承过来的虚函数，需要保持形参类型的完全一致</li>
<li>返回类型也必须匹配，除了一个例外情况：返回类型是类本身的引用或指针时</li>
</ul>
<hr />
<p><strong>final和override说明符</strong></p>
<p>override关键字说明派生类中的虚函数，好处是使得程序员的意图更加清晰（说明这个函数是虚函数的覆盖，而不是重载的新函数），并且让编译器可以发现一些错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;<span class="comment">//错误，覆盖的虚函数一定要参数匹配，被认为是一个新函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//错误，只有虚函数才能覆盖</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>final关键字作用是禁止<strong>后续</strong>任何尝试覆盖该函数的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;<span class="comment">//后续的继承不允许覆盖f1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span> : D2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>override和final说明符出现在形参列表和尾置返回类型之后</p>
<hr />
<p><strong>虚函数与默认实参</strong></p>
<p>默认实参的判定是根据实际运行的函数版本中的默认实参来判定的。</p>
<p>如果虚函数使用默认实参，则基类与派生类中定义的默认实参最好一致。</p>
<hr />
<p><strong>回避虚函数的机制</strong></p>
<p>某些情况下，希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本</p>
<p>方法：使用作用域运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p><strong>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的机制</strong></p>
<p><img src="image-20230310152341558.png" alt="image-20230310152341558" /></p>
<h3 id="抽象基类"><a class="markdownIt-Anchor" href="#抽象基类"></a> 抽象基类</h3>
<p><strong>纯虚函数</strong></p>
<p>引入目的：</p>
<p>1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p>
<p>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>纯虚函数实际上告诉用户（程序员）当前函数是没有实际意义的，并且告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>纯虚函数无须定义，在函数声明语句最后加=0即可说明该函数为纯虚函数</p>
<p>=0只能出现在<strong>类内部</strong>的虚函数声明语句处</p>
<blockquote>
<p><strong>虚函数和纯虚函数</strong></p>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了<strong>允许用基类的指针来调用子类的这个函数。</strong></p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现（虽然纯虚函数也可以被定义，但从从目的上分析就是没有实现）。</p>
<p>定义纯虚函数是为了<strong>实现一个接口，起到一个规范的作用</strong>，规范继承这个类的程序员必须实现这个函数。</p>
</blockquote>
<hr />
<p><strong>抽象基类</strong></p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类</p>
<p>抽象基类负责定义接口，后续其他类可以覆盖接口</p>
<p><strong>不能直接创建一个抽象基类的对象</strong></p>
<p>值得注意的是。<strong>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</strong></p>
<h3 id="访问控制和继承"><a class="markdownIt-Anchor" href="#访问控制和继承"></a> 访问控制和继承</h3>
<p><strong>protected</strong></p>
<ul>
<li>对用户而言不可访问</li>
<li>对派生类成员和友元来说可访问</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对象对基类对象中的受保护成员没有任何访问特权</li>
</ul>
<p>对于最后一条，考虑如下例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">(D&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">(B&amp;)</span></span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(D&amp; d)</span></span>&#123;d.j = d.prot_mem = <span class="number">0</span>;&#125;<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B&amp; b)</span></span>&#123;b.prot_mem = <span class="number">0</span>&#125;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<hr />
<p>继承来的成员访问权限的影响来自两方面：1.成员在基类中的访问说明符 2.在派生类的派生列表中的访问说明符</p>
<p><strong>派生访问说明符对派生类的成员和友元能否访问其直接基类的成员没什么影响</strong>，其目的是控制派生类用户（使用者和派生类的派生类）对基类成员的访问权限</p>
<table>
<thead>
<tr>
<th style="text-align:center">原本访问权限\继承方式</th>
<th style="text-align:center">public继承方式</th>
<th style="text-align:center">protected继承方式</th>
<th style="text-align:center">private继承方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">public</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">private</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">private</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
<p>上表中，比如原本在基类中为public成员，派生类通过private继承后，在派生类中的访问权限变为private，在非成员函数调用时或者进一步派生时变得不可访问</p>
<hr />
<p><strong>派生类向基类转换的可访问性</strong></p>
<p><img src="image-20230313185210156.png" alt="image-20230313185210156" /></p>
<hr />
<p><strong>友元与继承</strong></p>
<p>友元关系不能继承，每个类负责控制各自成员的访问权限</p>
<p>A类的友元不能访问A类派生类的private成员，<strong>但是可以访问派生类的基类部分（即派生类中基类部分由基类本身控制）</strong>；A类友元的派生类也不能访问A类的private成员。</p>
<hr />
<p><strong>改变个别成员的可访问性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">private</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本来size和n是D的私有成员，然而现在使用using语句改变了这些成员的可访问性</p>
<p><strong>派生类只能为那些它可以访问的名字提供using声明</strong></p>
<hr />
<p><strong>默认的继承保护级别</strong></p>
<p>struct默认public继承，class默认private继承</p>
<h3 id="继承中的类作用域"><a class="markdownIt-Anchor" href="#继承中的类作用域"></a> 继承中的类作用域</h3>
<p><strong>编译时的名字查找</strong></p>
<p>即使动态类型和静态类型可能不一致，但能使用哪些成员仍然是由<strong>静态类型</strong>决定的</p>
<p><strong>继承中的名字冲突</strong></p>
<p>派生类的成员将隐藏同名的基类成员</p>
<p>可以使用作用域运算符来使用隐藏的成员</p>
<p>除了覆盖继承而来的虚函数之外，最好不要在派生类中重用其他定义在基类中的名字</p>
<p><img src="image-20230313193243811.png" alt="image-20230313193243811" /></p>
<p>从上图可知，<strong>名字查找先于类型检查</strong></p>
<p><img src="image-20230313193358593.png" alt="image-20230313193358593" /></p>
<hr />
<p><strong>虚函数与作用域</strong></p>
<p>只有基类和派生类中的虚函数有相同的形参列表，才能通过基类的指针或引用调用派生类的虚函数。</p>
<p><strong>调用非虚函数时不会发生动态绑定，实际调用的函数版本又指针的静态类型决定</strong></p>
<h3 id="构造函数与拷贝控制"><a class="markdownIt-Anchor" href="#构造函数与拷贝控制"></a> 构造函数与拷贝控制</h3>
<h4 id="虚析构函数"><a class="markdownIt-Anchor" href="#虚析构函数"></a> 虚析构函数</h4>
<p>基类通常应该定义一个虚析构函数，这样可以动态分配继承体系中的对象</p>
<p>基类中的析构函数是虚函数，将确保delete基类指针时运行正确的析构函数版本</p>
<p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>
<h4 id="派生类的拷贝控制成员"><a class="markdownIt-Anchor" href="#派生类的拷贝控制成员"></a> 派生类的拷贝控制成员</h4>
<p>默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式使用基类的拷贝（或移动）构造函数</p>
<p><img src="image-20230314164638203.png" alt="image-20230314164638203" /></p>
<p>派生类的赋值运算符也必须显式地为其基类部分赋值</p>
<p><img src="image-20230314164736325.png" alt="image-20230314164736325" /></p>
<p>析构的顺序与构造的顺序相反，派生类的析构函数首先执行，然后是基类的析构函数</p>
<h4 id="继承的构造函数"><a class="markdownIt-Anchor" href="#继承的构造函数"></a> 继承的构造函数</h4>
<p>C++11新标准中，派生类能够重用其直接基类定义的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> B::B;<span class="comment">//重用B的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using作用域构造函数时，该语句令编译器产生代码。对基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数</p>
<p><strong>构造函数的using声明不会改变该构造函数的访问级别</strong>，比如基类的私有构造函数在派生类中还是私有</p>
<p>using声明语句也不能指定explicit或者constexpr，如果基类的构造函数是explicit或者constexpr，则继承的构造函数也有相同的属性</p>
<p>基类的构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p>
<p>派生类不会继承构造函数的情况：</p>
<ul>
<li>派生类定义的构造函数与基类构造函数有相同的参数列表</li>
<li>默认、拷贝、移动构造函数不会被继承</li>
</ul>
<h3 id="容器与继承"><a class="markdownIt-Anchor" href="#容器与继承"></a> 容器与继承</h3>
<p>当派生类对象赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容</p>
<p>当希望在容器中存放具有继承关系的对象时，实际上存放的通常是<strong>基类的指针</strong>。这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;B&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;B&gt;());</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;D&gt;());</span><br></pre></td></tr></table></figure>
<h2 id="第16章-模板与泛型编程"><a class="markdownIt-Anchor" href="#第16章-模板与泛型编程"></a> 第16章 模板与泛型编程</h2>
<h3 id="定义模板"><a class="markdownIt-Anchor" href="#定义模板"></a> 定义模板</h3>
<h4 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funct</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>模板定义中，模板参数列表不能为空</p>
<p>调用函数模板时，编译器通常用函数实参为我们推断模板实参</p>
<p>编译器用推断出的模板参数实例化一个特定版本的函数</p>
<p><strong>模板中可以定义非类型参数</strong>，一个非类型参数表示一个值而非一个类型，通过<strong>类型名</strong>而非class或typename指定非类型参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N,<span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非类型模板参数实参必须是常量表达式</strong></p>
<p>inline和constexpr说明符要放在参数列表之后，返回类型之前</p>
<p>模板程序应该尽量减少对实参类型的要求</p>
<p>编译器遇到模板定义时，并不生成代码，只有当我们实例化出模板的一个特定版本时才会生成代码。</p>
<p>函数模板和类模板成员函数的定义通常放在头文件中，因为编译器生成一个实例化版本要掌握其定义</p>
<hr />
<h4 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h4>
<p>与函数模板的区别在于，编译器不能为类模板推断模板参数类型，必须在模板名后的尖括号中提供额外信息</p>
<p>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化</p>
<p>在类模板的作用域内，我们可以直接使用模板名而不必指定模板实参</p>
<p>模板类型别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T,<span class="type">unsigned</span>&gt;</span><br></pre></td></tr></table></figure>
<p>类模板中的static成员：不能把静态成员的定义放在类中，但是可以在类的外部通过使用范围解析运算符 :: 来定义静态变量从而对它进行初始化。</p>
<p>相同类型如int对应的类模板的对象之间的static成员是共享的，不同类型之间如int,float,char对应的类模板的对象之间的static是不共享的。</p>
<hr />
<h4 id="模板参数"><a class="markdownIt-Anchor" href="#模板参数"></a> 模板参数</h4>
<p>声明中的模板参数与定义中的模板参数不必相同。</p>
<p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>
<p>对于模板代码而言，假定T是模板类型参数，当遇到T::mem这样的代码时，编译器不知道mem是一个类型名还是一个static数据成员的名字，直至实例化时才会知道。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T::size_type * p;</span><br></pre></td></tr></table></figure>
<p>编译器不知道是size_type数据成员与p相乘还是定义一个size_type类型的p</p>
<p>默认情况下，C++假定通过作用域运算符访问的是名字而非类型。</p>
<p>所以，如果想使用一个类型时，必须显式的告诉编译器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11开始，可以为函数和类模板提供默认实参。无论何时使用类模板，模板名之后都要接尖括号，尖括号指明类必须从一个模板实例化而来。</p>
<p>如果希望使用提供的默认实参，<strong>就在模板名之后跟一个空的尖括号对</strong></p>
<hr />
<h4 id="成员模板"><a class="markdownIt-Anchor" href="#成员模板"></a> 成员模板</h4>
<p>类中包含的本身是模板的成员函数，这种成员被称为成员模板。<strong>成员模板不能是虚函数</strong></p>
<hr />
<h4 id="控制实例化"><a class="markdownIt-Anchor" href="#控制实例化"></a> 控制实例化</h4>
<p><img src="image-20230316105433811.png" alt="image-20230316105433811" /></p>
<h3 id="模板实参推断"><a class="markdownIt-Anchor" href="#模板实参推断"></a> 模板实参推断</h3>
<h4 id="类型转换与模板类型参数"><a class="markdownIt-Anchor" href="#类型转换与模板类型参数"></a> 类型转换与模板类型参数</h4>
<p>对函数模板传递的实参，通常不进行类型转换，而是生成一个新的模板实例，只有有限的几种类型转换会自动应用于实参：</p>
<ul>
<li><strong>顶层const</strong>无论在形参还是实参中都会被忽略。</li>
<li>非const对象的引用或指针传递给const的引用或指针形参。</li>
<li><strong>形参不是引用类型</strong>，则可以对数组或函数类型的实参应用指针转换，数组实参转换为指向其首元素的指针；函数实参转换为一个该函数类型的指针。</li>
</ul>
<p>如果不是模板参数，则可以对实参进行正常的类型转换</p>
<h4 id="函数模板显式实参"><a class="markdownIt-Anchor" href="#函数模板显式实参"></a> 函数模板显式实参</h4>
<h3 id="重载与模板"><a class="markdownIt-Anchor" href="#重载与模板"></a> 重载与模板</h3>
<h3 id="可变参数模板"><a class="markdownIt-Anchor" href="#可变参数模板"></a> 可变参数模板</h3>
<h3 id="模板特例化"><a class="markdownIt-Anchor" href="#模板特例化"></a> 模板特例化</h3>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"># 编程语言</a>
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/12/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%888-12%E7%AB%A0%EF%BC%89/" rel="prev" title="《C++ Primer》笔记（8-12章）">
      <i class="fa fa-chevron-left"></i> 《C++ Primer》笔记（8-12章）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/12/%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88Trie%EF%BC%89/" rel="next" title="字典树/前缀树（Trie）">
      字典树/前缀树（Trie） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text"> 第13章 拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D-%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-number">1.1.</span> <span class="nav-text"> 拷贝、赋值与销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 拷贝赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 三&#x2F;五法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8default"><span class="nav-number">1.1.5.</span> <span class="nav-text"> 使用&#x3D;default</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.6.</span> <span class="nav-text"> 阻止拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text"> 拷贝控制和资源管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text"> 交换操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text"> 动态内存管理类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.5.</span> <span class="nav-text"> 对象移动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 移动构造函数和移动赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text"> 右值引用和成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text"> 第14章 重载运算与类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text"> 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text"> 输入和输出运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text"> 算术和关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.</span> <span class="nav-text"> 赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.</span> <span class="nav-text"> 下标运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.6.</span> <span class="nav-text"> 递增和递减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.7.</span> <span class="nav-text"> 成员访问运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.</span> <span class="nav-text"> 函数调用运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E6%98%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.8.1.</span> <span class="nav-text"> lambda是函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.8.2.</span> <span class="nav-text"> 标准库定义的函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction"><span class="nav-number">2.8.3.</span> <span class="nav-text"> 可调用对象与function</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.9.</span> <span class="nav-text"> 重载、类型转换与运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.9.1.</span> <span class="nav-text"> 类型转换运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%90%AB%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.9.2.</span> <span class="nav-text"> 避免含有二义性的类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.9.3.</span> <span class="nav-text"> 函数匹配与重载运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC15%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text"> 第15章 面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#oop%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text"> OOP概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text"> 定义基类和派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 基本知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 类型转换与继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text"> 虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">3.4.</span> <span class="nav-text"> 抽象基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">3.5.</span> <span class="nav-text"> 访问控制和继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.6.</span> <span class="nav-text"> 继承中的类作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">3.7.</span> <span class="nav-text"> 构造函数与拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.1.</span> <span class="nav-text"> 虚析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="nav-number">3.7.2.</span> <span class="nav-text"> 派生类的拷贝控制成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.3.</span> <span class="nav-text"> 继承的构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">3.8.</span> <span class="nav-text"> 容器与继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text"> 第16章 模板与泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.1.</span> <span class="nav-text"> 定义模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.1.1.</span> <span class="nav-text"> 函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.1.2.</span> <span class="nav-text"> 类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text"> 模板参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.1.4.</span> <span class="nav-text"> 成员模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">4.1.5.</span> <span class="nav-text"> 控制实例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="nav-number">4.2.</span> <span class="nav-text"> 模板实参推断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 类型转换与模板类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E5%8F%82"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 函数模板显式实参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.3.</span> <span class="nav-text"> 重载与模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.4.</span> <span class="nav-text"> 可变参数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text"> 模板特例化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tien"
      src="https://avatars.githubusercontent.com/u/34372430?v=4">
  <p class="site-author-name" itemprop="name">Tien</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tien5770" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tien5770" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/txvhuiu@163.com" title="E-Mail → txvhuiu@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tien</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
